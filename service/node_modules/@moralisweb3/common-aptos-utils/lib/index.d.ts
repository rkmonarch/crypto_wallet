import { Config, MoralisData, MoralisDataFormatted, BigNumberish, BigNumber, ConfigKey, Core, Module } from '@moralisweb3/common-core';

declare class CommonAptosUtilsConfigSetup {
    static register(config: Config): void;
}

/**
 * Valid input for a new AptosAddress instance.
 * This can be an existing AptosAddress or a valid address string.
 *
 * @example "0x54ad3d30af77b60d939ae356e6606de9a4da67583f02b962d2d3f2e481484e90"
 * @example AptosAddress.create("0x54ad3d30af77b60d939ae356e6606de9a4da67583f02b962d2d3f2e481484e90")
 */
type AptosAddressInput = AptosAddress | string;
type AptosAddressJSON = string;
/**
 * A representation of an address on the Aptos network.
 *
 * Use this class any time you work with an address.
 *
 * @category DataType
 */
declare class AptosAddress implements MoralisData {
    readonly address: string;
    /**
     * Create a new instance of AptosAddress from any valid address input.
     *
     * @example `const address = AptosAddress.create("0x54ad3d30af77b60d939ae356e6606de9a4da67583f02b962d2d3f2e481484e90")`
     * @throws an error when a passed address is invalid.
     */
    static create(address: AptosAddressInput): AptosAddress;
    static fromJSON(json: AptosAddressJSON): AptosAddress;
    private static parse;
    constructor(address: string);
    /**
     * @deprecated This method will be removed soon. To format the value, use one of the properties.
     */
    format(): MoralisDataFormatted;
    /**
     * Check the equality between two Aptos addresses
     * @example `AptosAddress.equals("0x54ad3d30af77b60d939ae356e6606de9a4da67583f02b962d2d3f2e481484e90", "0x54ad3d30af77b60d939ae356e6606de9a4da67583f02b962d2d3f2e481484e90")`
     */
    static equals(addressA: AptosAddressInput, addressB: AptosAddressInput): boolean;
    /**
     * Checks the equality of the current address with another Aptos address.
     * @example `address.equals("0x54ad3d30af77b60d939ae356e6606de9a4da67583f02b962d2d3f2e481484e90")`
     * @example `address.equals(AptosAddress.create("0x54ad3d30af77b60d939ae356e6606de9a4da67583f02b962d2d3f2e481484e90"))`
     */
    equals(address: AptosAddressInput): boolean;
    /**
     * @returns a string representing the address.
     * @example address.toString(); // "0x54ad3d30af77b60d939ae356e6606de9a4da67583f02b962d2d3f2e481484e90"
     */
    toString(): string;
    /**
     * @returns a string representing the address.
     * @example address.toJSON(); // "0x54ad3d30af77b60d939ae356e6606de9a4da67583f02b962d2d3f2e481484e90"
     */
    toJSON(): AptosAddressJSON;
    /**
     * @returns a string representing the address, the leading zeros are removed from the address.
     * @example address.short; // "0x1"
     */
    get short(): string;
}

declare const aptosNetworkNames: readonly ["mainnet", "testnet", "devnet"];
/**
 * A name of Aptos network.
 *
 * @example "mainnet"
 * @example "devnet"
 */
type AptosNetworkName = typeof aptosNetworkNames[number];
/**
 * A name of Aptos network.
 *
 * @example "mainnet"
 * @example "devnet"
 */
type AptosNetworkJSON = AptosNetworkName | string;
/**
 * Valid input for a new AptosNetwork instance.
 * This can be an existing AptosNetwork or a valid network name.
 *
 * @example "mainnet"
 * @example "devnet"
 * @example AptosNetwork.create("mainnet")
 */
type AptosNetworkInput = AptosNetwork | AptosNetworkJSON;
/**
 * A representation of a Aptos network.
 *
 * @category DataType
 */
declare class AptosNetwork implements MoralisData {
    readonly network: AptosNetworkName;
    /**
     * Returns MAINNET network
     *
     * @example AptosNetwork.MAINNET
     */
    static get MAINNET(): AptosNetwork;
    /**
     * Returns TESTNET network
     *
     * @example AptosNetwork.MAINNET
     */
    static get TESTNET(): AptosNetwork;
    /**
     * Returns DEVNET network
     *
     * @example AptosNetwork.MAINNET
     */
    static get DEVNET(): AptosNetwork;
    /**
     * Create a new instance of AptosNetwork from any valid network input.
     *
     * @example `const network = AptosNetwork.create("mainnet")`
     * @throws an error when a passed network is invalid.
     */
    static create(network: AptosNetworkInput): AptosNetwork;
    private static parse;
    private constructor();
    /**
     * @deprecated This method will be removed soon. To format the value, use one of the properties.
     */
    format(): MoralisDataFormatted;
    /**
     * Checks the equality of the current network with another Aptos network.
     * @example `network.equals("mainnet")`
     * @example `network.equals(AptosNetwork.create("mainnet"))`
     */
    equals(network: AptosNetworkInput): boolean;
    /**
     * @returns a string representing the network.
     * @example network.toJSON(); // "mainnet"
     */
    toJSON(): string;
    /**
     * @returns a string representing the network.
     * @example network.toString(); // "mainnet"
     */
    toString(): string;
}

/**
 * Type containing valid Aptos native units
 */
type AptosNativeUnit = 'aptos' | 'octas' | number;
/**
 * Valid input for a new AptosNative instance.
 * This can be an existing {@link AptosNative} or a valid {@link @moralisweb3/common-core!BigNumberish} type
 */
type AptosNativeInput = AptosNative | BigNumberish;
type AptosNativeJSON = string;
/**
 * The AptosNative class is a MoralisData that references to the value of Aptos native currency APT
 *
 * @category DataType
 */
declare class AptosNative implements MoralisData {
    private readonly rawValue;
    /**
     * Create a new instance of AptosNative from any valid {@link AptosNativeInput} value.
     * @param value - the value to create the AptosNative from
     * @param unit - the unit of the value (optional), defaults to `aptos`
     * @returns a new instance of AptosNative
     * @example
     * ```ts
     * const native = AptosNative.create(2, 'octas');
     * const native = AptosNative.create(2);
     *```
     */
    static create(value: AptosNativeInput, unit?: AptosNativeUnit): AptosNative;
    static fromJSON(json: AptosNativeJSON): AptosNative;
    private static parse;
    private constructor();
    /**
     * Compares two AptosNativeish values.
     * @param valueA - the first value to compare
     * @param valueB - the second value to compare
     * @returns true if the values are equal
     * @example
     * ```ts
     * AptosNative.equals(AptosNative.create(1), AptosNative.create(1)); // true
     * ```
     */
    static equals(valueA: AptosNativeInput, valueB: AptosNativeInput): boolean;
    /**
     * Compares AptosNative with current instance.
     * @param value - the value to compare with
     * @returns true if the values are equal
     * @example
     * ```ts
     * const native = AptosNative.create(2, 'octas');
     * native.equals(AptosNative.create(1)); // false
     * ```
     */
    equals(value: AptosNative): boolean;
    /**
     * @deprecated This method will be removed soon. To format the value, use one of the properties.
     */
    format(): MoralisDataFormatted;
    /**
     * Converts the AptosNative to a string.
     * @returns the value of the AptosNative as a string
     * @example `native.toJSON()`
     */
    toJSON(): AptosNativeJSON;
    /**
     * Converts the AptosNative to a string.
     * @returns the value of the AptosNative as a string
     * @example `native.toString()`
     */
    toString(): string;
    /**
     * @returns the value of the AptosNative as a BigNumber
     * @example `native.value`
     */
    get value(): BigNumber;
    /**
     * Converts the AptosNative to an aptos unit.
     * @returns the value of the AptosNative as an aptos string
     * @example `native.aptos`
     */
    get aptos(): string;
    /**
     * Converts the AptosNative to a string.
     * @returns the value of the AptosNative as a string
     * @example `native.lamports`
     */
    get octas(): string;
}

declare const CommonAptosUtilsConfig: {
    defaultAptosNetwork: ConfigKey<AptosNetworkInput>;
};

declare class AptosNetworkResolver {
    static resolve(network: AptosNetworkInput | undefined, core: Core): AptosNetworkName;
}

declare class CommonAptosUtils extends Module {
    static readonly moduleName = "aptosUtils";
    static create(core?: Core): CommonAptosUtils;
    private constructor();
    setup(): void;
    start(): void;
    get AptosAddress(): typeof AptosAddress;
    get AptosNative(): typeof AptosNative;
    get AptosNetwork(): typeof AptosNetwork;
}

type AptosNFTTokenResponseDefaultPropertiesJSON = object;
type AptosNFTTokenResponseDefaultPropertiesInput = object;
type AptosNFTTokenResponseDefaultPropertiesValue = object;
declare abstract class AptosNFTTokenResponseDefaultProperties {
    static create(input: AptosNFTTokenResponseDefaultPropertiesInput | AptosNFTTokenResponseDefaultPropertiesValue): AptosNFTTokenResponseDefaultPropertiesValue;
    static fromJSON(json: AptosNFTTokenResponseDefaultPropertiesJSON): AptosNFTTokenResponseDefaultPropertiesValue;
}

interface AptosNFTTokenResponseJSON {
    readonly collection_data_id_hash: string;
    readonly collection_name: string;
    readonly creator_address: AptosAddressJSON;
    readonly default_properties: AptosNFTTokenResponseDefaultPropertiesJSON;
    readonly description: string;
    readonly description_mutable: boolean;
    readonly largest_property_version: string;
    readonly last_transaction_timestamp: string;
    readonly last_transaction_version: string;
    readonly maximum: string;
    readonly maximum_mutable: boolean;
    readonly metadata_uri: string;
    readonly name: string;
    readonly payee_address: AptosAddressJSON;
    readonly properties_mutable: boolean;
    readonly royalty_mutable: boolean;
    readonly royalty_points_denominator: string;
    readonly royalty_points_numerator: string;
    readonly supply: string;
    readonly token_data_id_hash: string;
    readonly uri_mutable: boolean;
}
interface AptosNFTTokenResponseInput {
    readonly collectionDataIdHash: string;
    readonly collectionName: string;
    readonly creatorAddress: AptosAddressInput | AptosAddress;
    readonly defaultProperties: AptosNFTTokenResponseDefaultPropertiesInput | AptosNFTTokenResponseDefaultPropertiesValue;
    readonly description: string;
    readonly descriptionMutable: boolean;
    readonly largestPropertyVersion: string;
    readonly lastTransactionTimestamp: string;
    readonly lastTransactionVersion: string;
    readonly maximum: string;
    readonly maximumMutable: boolean;
    readonly metadataUri: string;
    readonly name: string;
    readonly payeeAddress: AptosAddressInput | AptosAddress;
    readonly propertiesMutable: boolean;
    readonly royaltyMutable: boolean;
    readonly royaltyPointsDenominator: string;
    readonly royaltyPointsNumerator: string;
    readonly supply: string;
    readonly tokenDataIdHash: string;
    readonly uriMutable: boolean;
}
declare class AptosNFTTokenResponse {
    static create(input: AptosNFTTokenResponseInput | AptosNFTTokenResponse): AptosNFTTokenResponse;
    static fromJSON(json: AptosNFTTokenResponseJSON): AptosNFTTokenResponse;
    /**
     * @description The identifier of the collection
     */
    readonly collectionDataIdHash: string;
    /**
     * @description The name of the collection
     */
    readonly collectionName: string;
    /**
     * @description The address of the creator of the collection
     */
    readonly creatorAddress: AptosAddress;
    /**
     * @description The default properties of the token
     */
    readonly defaultProperties: AptosNFTTokenResponseDefaultPropertiesValue;
    /**
     * @description The description of the collection
     */
    readonly description: string;
    /**
     * @description Whether the description can be changed
     */
    readonly descriptionMutable: boolean;
    /**
     * @description largest_property_version
     */
    readonly largestPropertyVersion: string;
    /**
     * @description The timestamp of the last transaction
     */
    readonly lastTransactionTimestamp: string;
    /**
     * @description The version of the last transaction
     */
    readonly lastTransactionVersion: string;
    /**
     * @description The maximum number of tokens that can be minted
     */
    readonly maximum: string;
    /**
     * @description Whether the maximum number of tokens can be changed
     */
    readonly maximumMutable: boolean;
    /**
     * @description The URI of the image of the token
     */
    readonly metadataUri: string;
    /**
     * @description The name of the token
     */
    readonly name: string;
    /**
     * @description The address that last payed for the token
     */
    readonly payeeAddress: AptosAddress;
    /**
     * @description Whether the properties of the token can be changed
     */
    readonly propertiesMutable: boolean;
    /**
     * @description Whether the royalty of the token can be changed
     */
    readonly royaltyMutable: boolean;
    /**
     * @description The denominator for royalty points
     */
    readonly royaltyPointsDenominator: string;
    /**
     * @description The numerator for royalty points
     */
    readonly royaltyPointsNumerator: string;
    /**
     * @description The number of tokens minted
     */
    readonly supply: string;
    /**
     * @description The identifier of the token
     */
    readonly tokenDataIdHash: string;
    /**
     * @description Whether the URI of the image can be changed
     */
    readonly uriMutable: boolean;
    private constructor();
    toJSON(): AptosNFTTokenResponseJSON;
}

interface GetNFTsByIdsOperationRequest {
    /**
     * @description The identifiers of the tokens to get
     */
    readonly tokenIds: string[];
    /**
     * @description The network of query. Defaults to mainnet.
     */
    readonly network?: AptosNetworkInput | AptosNetwork;
}
interface GetNFTsByIdsOperationRequestJSON {
    readonly token_ids: string[];
    readonly network?: AptosNetworkJSON;
}
declare const GetNFTsByIdsOperation: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosNFTTokenResponseJSON[]): AptosNFTTokenResponse[];
    serializeRequest(request: GetNFTsByIdsOperationRequest): GetNFTsByIdsOperationRequestJSON;
};

interface AptosNFTTokensByCollectionResponseJSON {
    readonly cursor: string;
    readonly hasNextPage: boolean;
    readonly result: AptosNFTTokenResponseJSON[];
}
interface AptosNFTTokensByCollectionResponseInput {
    readonly cursor: string;
    readonly hasNextPage: boolean;
    readonly result: AptosNFTTokenResponseInput[] | AptosNFTTokenResponse[];
}
declare class AptosNFTTokensByCollectionResponse {
    static create(input: AptosNFTTokensByCollectionResponseInput | AptosNFTTokensByCollectionResponse): AptosNFTTokensByCollectionResponse;
    static fromJSON(json: AptosNFTTokensByCollectionResponseJSON): AptosNFTTokensByCollectionResponse;
    /**
     * @description The cursor to use for the next page of results. (Cursor is null on last page)
     */
    readonly cursor: string;
    /**
     * @description Indicates if there is a next page of results
     */
    readonly hasNextPage: boolean;
    /**
     * @description The tokens for the given collection
     */
    readonly result: AptosNFTTokenResponse[];
    private constructor();
    toJSON(): AptosNFTTokensByCollectionResponseJSON;
}

interface GetNFTsByCollectionOperationRequest {
    /**
     * @description The collection data id hash of the collection
     */
    readonly collectionDataIdHash: string;
    /**
     * @description The number of results to return
     */
    readonly limit: number;
    /**
     * @description The number of results to skip
     */
    readonly offset?: number;
    /**
     * @description The cursor to use for getting the next page
     */
    readonly cursor?: string;
    /**
     * @description The network of query. Defaults to mainnet.
     */
    readonly network?: AptosNetworkInput | AptosNetwork;
}
interface GetNFTsByCollectionOperationRequestJSON {
    readonly collection_data_id_hash: string;
    readonly limit: number;
    readonly offset?: number;
    readonly cursor?: string;
    readonly network?: AptosNetworkJSON;
}
declare const GetNFTsByCollectionOperation: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosNFTTokensByCollectionResponseJSON): AptosNFTTokensByCollectionResponse;
    serializeRequest(request: GetNFTsByCollectionOperationRequest): GetNFTsByCollectionOperationRequestJSON;
};

interface AptosNFTTokensByCreatorsResponseJSON {
    readonly cursor: string;
    readonly hasNextPage: boolean;
    readonly result: AptosNFTTokenResponseJSON[];
}
interface AptosNFTTokensByCreatorsResponseInput {
    readonly cursor: string;
    readonly hasNextPage: boolean;
    readonly result: AptosNFTTokenResponseInput[] | AptosNFTTokenResponse[];
}
declare class AptosNFTTokensByCreatorsResponse {
    static create(input: AptosNFTTokensByCreatorsResponseInput | AptosNFTTokensByCreatorsResponse): AptosNFTTokensByCreatorsResponse;
    static fromJSON(json: AptosNFTTokensByCreatorsResponseJSON): AptosNFTTokensByCreatorsResponse;
    /**
     * @description The cursor to use for the next page of results. (Cursor is null on last page)
     */
    readonly cursor: string;
    /**
     * @description Indicates if there is a next page of results
     */
    readonly hasNextPage: boolean;
    /**
     * @description The collections for the given creators
     */
    readonly result: AptosNFTTokenResponse[];
    private constructor();
    toJSON(): AptosNFTTokensByCreatorsResponseJSON;
}

interface GetNFTsByCreatorsOperationRequest {
    /**
     * @description The number of tokens to return
     */
    readonly limit: number;
    /**
     * @description The number of results to skip
     */
    readonly offset?: number;
    /**
     * @description The cursor to use for getting the next page
     */
    readonly cursor?: string;
    /**
     * @description The addresses of the creators
     */
    readonly creatorAddresses: AptosAddressInput[] | AptosAddress[];
    /**
     * @description The network of query. Defaults to mainnet.
     */
    readonly network?: AptosNetworkInput | AptosNetwork;
}
interface GetNFTsByCreatorsOperationRequestJSON {
    readonly limit: number;
    readonly offset?: number;
    readonly cursor?: string;
    readonly creator_addresses: AptosAddressJSON[];
    readonly network?: AptosNetworkJSON;
}
declare const GetNFTsByCreatorsOperation: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosNFTTokensByCreatorsResponseJSON): AptosNFTTokensByCreatorsResponse;
    serializeRequest(request: GetNFTsByCreatorsOperationRequest): GetNFTsByCreatorsOperationRequestJSON;
};

interface AptosNFTCollectionItemResponseJSON {
    readonly collection_data_id_hash: string;
    readonly collection_name: string;
    readonly creator_address: AptosAddressJSON;
    readonly description: string;
    readonly description_mutable: boolean;
    readonly last_transaction_timestamp: string;
    readonly last_transaction_version: string;
    readonly maximum: string;
    readonly maximum_mutable: boolean;
    readonly metadata_uri: string;
    readonly supply: string;
    readonly table_handle: string;
    readonly uri_mutable: boolean;
}
interface AptosNFTCollectionItemResponseInput {
    readonly collectionDataIdHash: string;
    readonly collectionName: string;
    readonly creatorAddress: AptosAddressInput | AptosAddress;
    readonly description: string;
    readonly descriptionMutable: boolean;
    readonly lastTransactionTimestamp: string;
    readonly lastTransactionVersion: string;
    readonly maximum: string;
    readonly maximumMutable: boolean;
    readonly metadataUri: string;
    readonly supply: string;
    readonly tableHandle: string;
    readonly uriMutable: boolean;
}
declare class AptosNFTCollectionItemResponse {
    static create(input: AptosNFTCollectionItemResponseInput | AptosNFTCollectionItemResponse): AptosNFTCollectionItemResponse;
    static fromJSON(json: AptosNFTCollectionItemResponseJSON): AptosNFTCollectionItemResponse;
    /**
     * @description The identifier of the collection
     */
    readonly collectionDataIdHash: string;
    /**
     * @description The name of the collection
     */
    readonly collectionName: string;
    /**
     * @description The address of the creator of the collection
     */
    readonly creatorAddress: AptosAddress;
    /**
     * @description The description of the collection
     */
    readonly description: string;
    /**
     * @description Whether the description can be changed
     */
    readonly descriptionMutable: boolean;
    /**
     * @description The timestamp of the last transaction
     */
    readonly lastTransactionTimestamp: string;
    /**
     * @description The version of the last transaction
     */
    readonly lastTransactionVersion: string;
    /**
     * @description The maximum number of tokens that can be minted
     */
    readonly maximum: string;
    /**
     * @description Whether the maximum number of tokens can be changed
     */
    readonly maximumMutable: boolean;
    /**
     * @description The URI of the image of the collection
     */
    readonly metadataUri: string;
    /**
     * @description The number of tokens minted
     */
    readonly supply: string;
    /**
     * @description The address of the table that stores the tokens
     */
    readonly tableHandle: string;
    /**
     * @description Whether the URI of the image can be changed
     */
    readonly uriMutable: boolean;
    private constructor();
    toJSON(): AptosNFTCollectionItemResponseJSON;
}

interface AptosNFTCollectionsByNameRangeResponseJSON {
    readonly cursor: string;
    readonly hasNextPage: boolean;
    readonly result: AptosNFTCollectionItemResponseJSON[];
}
interface AptosNFTCollectionsByNameRangeResponseInput {
    readonly cursor: string;
    readonly hasNextPage: boolean;
    readonly result: AptosNFTCollectionItemResponseInput[] | AptosNFTCollectionItemResponse[];
}
declare class AptosNFTCollectionsByNameRangeResponse {
    static create(input: AptosNFTCollectionsByNameRangeResponseInput | AptosNFTCollectionsByNameRangeResponse): AptosNFTCollectionsByNameRangeResponse;
    static fromJSON(json: AptosNFTCollectionsByNameRangeResponseJSON): AptosNFTCollectionsByNameRangeResponse;
    /**
     * @description The cursor to use for the next page of results. (Cursor is null on last page)
     */
    readonly cursor: string;
    /**
     * @description Indicates if there is a next page of results
     */
    readonly hasNextPage: boolean;
    /**
     * @description The collections for the given creator
     */
    readonly result: AptosNFTCollectionItemResponse[];
    private constructor();
    toJSON(): AptosNFTCollectionsByNameRangeResponseJSON;
}

interface GetNFTCollectionsOperationRequest {
    /**
     * @description The number of results to return
     */
    readonly limit: number;
    /**
     * @description The number of results to skip
     */
    readonly offset?: number;
    /**
     * @description The cursor to use for getting the next page
     */
    readonly cursor?: string;
    /**
     * @description The name of the collection to start from (inclusive and case sensitive)
     */
    readonly fromName?: string;
    /**
     * @description The name of the collection to end at (inclusive and case sensitive)
     */
    readonly toName?: string;
    /**
     * @description The network of query. Defaults to mainnet.
     */
    readonly network?: AptosNetworkInput | AptosNetwork;
}
interface GetNFTCollectionsOperationRequestJSON {
    readonly limit: number;
    readonly offset?: number;
    readonly cursor?: string;
    readonly fromName?: string;
    readonly toName?: string;
    readonly network?: AptosNetworkJSON;
}
declare const GetNFTCollectionsOperation: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosNFTCollectionsByNameRangeResponseJSON): AptosNFTCollectionsByNameRangeResponse;
    serializeRequest(request: GetNFTCollectionsOperationRequest): GetNFTCollectionsOperationRequestJSON;
};

interface GetNFTCollectionsByIdsOperationRequest {
    /**
     * @description The identifiers of the collections to get
     */
    readonly ids: string[];
    /**
     * @description The network of query. Defaults to mainnet.
     */
    readonly network?: AptosNetworkInput | AptosNetwork;
}
interface GetNFTCollectionsByIdsOperationRequestJSON {
    readonly ids: string[];
    readonly network?: AptosNetworkJSON;
}
declare const GetNFTCollectionsByIdsOperation: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosNFTCollectionItemResponseJSON[]): AptosNFTCollectionItemResponse[];
    serializeRequest(request: GetNFTCollectionsByIdsOperationRequest): GetNFTCollectionsByIdsOperationRequestJSON;
};

interface AptosNFTCollectionsByCreatorResponseJSON {
    readonly cursor: string;
    readonly hasNextPage: boolean;
    readonly result: AptosNFTCollectionItemResponseJSON[];
}
interface AptosNFTCollectionsByCreatorResponseInput {
    readonly cursor: string;
    readonly hasNextPage: boolean;
    readonly result: AptosNFTCollectionItemResponseInput[] | AptosNFTCollectionItemResponse[];
}
declare class AptosNFTCollectionsByCreatorResponse {
    static create(input: AptosNFTCollectionsByCreatorResponseInput | AptosNFTCollectionsByCreatorResponse): AptosNFTCollectionsByCreatorResponse;
    static fromJSON(json: AptosNFTCollectionsByCreatorResponseJSON): AptosNFTCollectionsByCreatorResponse;
    /**
     * @description The cursor to use for the next page of results. (Cursor is null on last page)
     */
    readonly cursor: string;
    /**
     * @description Indicates if there is a next page of results
     */
    readonly hasNextPage: boolean;
    /**
     * @description The collections for the given creator
     */
    readonly result: AptosNFTCollectionItemResponse[];
    private constructor();
    toJSON(): AptosNFTCollectionsByCreatorResponseJSON;
}

interface GetNFTCollectionsByCreatorOperationRequest {
    /**
     * @description The number of results to return
     */
    readonly limit: number;
    /**
     * @description The number of results to skip
     */
    readonly offset?: number;
    /**
     * @description The cursor to use for getting the next page
     */
    readonly cursor?: string;
    /**
     * @description The address of the creator
     */
    readonly creatorAddress: AptosAddressInput | AptosAddress;
    /**
     * @description The network of query. Defaults to mainnet.
     */
    readonly network?: AptosNetworkInput | AptosNetwork;
}
interface GetNFTCollectionsByCreatorOperationRequestJSON {
    readonly limit: number;
    readonly offset?: number;
    readonly cursor?: string;
    readonly creator_address: AptosAddressJSON;
    readonly network?: AptosNetworkJSON;
}
declare const GetNFTCollectionsByCreatorOperation: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosNFTCollectionsByCreatorResponseJSON): AptosNFTCollectionsByCreatorResponse;
    serializeRequest(request: GetNFTCollectionsByCreatorOperationRequest): GetNFTCollectionsByCreatorOperationRequestJSON;
};

type AptosNFTOwnerResponseTokenPropertiesJSON = object;
type AptosNFTOwnerResponseTokenPropertiesInput = object;
type AptosNFTOwnerResponseTokenPropertiesValue = object;
declare abstract class AptosNFTOwnerResponseTokenProperties {
    static create(input: AptosNFTOwnerResponseTokenPropertiesInput | AptosNFTOwnerResponseTokenPropertiesValue): AptosNFTOwnerResponseTokenPropertiesValue;
    static fromJSON(json: AptosNFTOwnerResponseTokenPropertiesJSON): AptosNFTOwnerResponseTokenPropertiesValue;
}

interface AptosNFTOwnerResponseJSON {
    readonly amount: AptosNativeJSON;
    readonly collection_data_id_hash: string;
    readonly collection_name: string;
    readonly creator_address: AptosAddressJSON;
    readonly last_transaction_timestamp: string;
    readonly last_transaction_version: string;
    readonly name: string;
    readonly owner_address: AptosAddressJSON;
    readonly property_version: string;
    readonly table_type: string;
    readonly token_data_id_hash: string;
    readonly token_properties: AptosNFTOwnerResponseTokenPropertiesJSON;
}
interface AptosNFTOwnerResponseInput {
    readonly amount: AptosNativeInput | AptosNative;
    readonly collectionDataIdHash: string;
    readonly collectionName: string;
    readonly creatorAddress: AptosAddressInput | AptosAddress;
    readonly lastTransactionTimestamp: string;
    readonly lastTransactionVersion: string;
    readonly name: string;
    readonly ownerAddress: AptosAddressInput | AptosAddress;
    readonly propertyVersion: string;
    readonly tableType: string;
    readonly tokenDataIdHash: string;
    readonly tokenProperties: AptosNFTOwnerResponseTokenPropertiesInput | AptosNFTOwnerResponseTokenPropertiesValue;
}
declare class AptosNFTOwnerResponse {
    static create(input: AptosNFTOwnerResponseInput | AptosNFTOwnerResponse): AptosNFTOwnerResponse;
    static fromJSON(json: AptosNFTOwnerResponseJSON): AptosNFTOwnerResponse;
    /**
     * @description The number of tokens that belonging to the owner
     */
    readonly amount: AptosNative;
    /**
     * @description The identifier of the collection
     */
    readonly collectionDataIdHash: string;
    /**
     * @description The name of the collection
     */
    readonly collectionName: string;
    /**
     * @description The address of the creator of the collection
     */
    readonly creatorAddress: AptosAddress;
    /**
     * @description The timestamp of the last transaction
     */
    readonly lastTransactionTimestamp: string;
    /**
     * @description The version of the last transaction
     */
    readonly lastTransactionVersion: string;
    /**
     * @description The name of the token
     */
    readonly name: string;
    /**
     * @description The address of the owner of the token
     */
    readonly ownerAddress: AptosAddress;
    /**
     * @description The property version of the token
     */
    readonly propertyVersion: string;
    /**
     * @description The data structure of the token
     */
    readonly tableType: string;
    /**
     * @description The identifier of the token
     */
    readonly tokenDataIdHash: string;
    /**
     * @description The properties of the token
     */
    readonly tokenProperties: AptosNFTOwnerResponseTokenPropertiesValue;
    private constructor();
    toJSON(): AptosNFTOwnerResponseJSON;
}

interface AptosNFTOwnersByTokensResponseJSON {
    readonly cursor: string;
    readonly hasNextPage: boolean;
    readonly result: AptosNFTOwnerResponseJSON[];
}
interface AptosNFTOwnersByTokensResponseInput {
    readonly cursor: string;
    readonly hasNextPage: boolean;
    readonly result: AptosNFTOwnerResponseInput[] | AptosNFTOwnerResponse[];
}
declare class AptosNFTOwnersByTokensResponse {
    static create(input: AptosNFTOwnersByTokensResponseInput | AptosNFTOwnersByTokensResponse): AptosNFTOwnersByTokensResponse;
    static fromJSON(json: AptosNFTOwnersByTokensResponseJSON): AptosNFTOwnersByTokensResponse;
    /**
     * @description The cursor to use for the next page of results. (Cursor is null on last page)
     */
    readonly cursor: string;
    /**
     * @description Indicates if there is a next page of results
     */
    readonly hasNextPage: boolean;
    /**
     * @description The owners for the given tokens
     */
    readonly result: AptosNFTOwnerResponse[];
    private constructor();
    toJSON(): AptosNFTOwnersByTokensResponseJSON;
}

interface GetNFTOwnersByTokensOperationRequest {
    /**
     * @description The number of results to return
     */
    readonly limit: number;
    /**
     * @description The number of results to skip
     */
    readonly offset?: number;
    /**
     * @description The cursor to use for getting the next page
     */
    readonly cursor?: string;
    /**
     * @description The identifiers of the tokens to get owners for
     */
    readonly tokenIds: string[];
    /**
     * @description The network of query. Defaults to mainnet.
     */
    readonly network?: AptosNetworkInput | AptosNetwork;
}
interface GetNFTOwnersByTokensOperationRequestJSON {
    readonly limit: number;
    readonly offset?: number;
    readonly cursor?: string;
    readonly token_ids: string[];
    readonly network?: AptosNetworkJSON;
}
declare const GetNFTOwnersByTokensOperation: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosNFTOwnersByTokensResponseJSON): AptosNFTOwnersByTokensResponse;
    serializeRequest(request: GetNFTOwnersByTokensOperationRequest): GetNFTOwnersByTokensOperationRequestJSON;
};

interface AptosNFTOwnersByCollectionResponseJSON {
    readonly cursor: string;
    readonly hasNextPage: boolean;
    readonly result: AptosNFTOwnerResponseJSON[];
}
interface AptosNFTOwnersByCollectionResponseInput {
    readonly cursor: string;
    readonly hasNextPage: boolean;
    readonly result: AptosNFTOwnerResponseInput[] | AptosNFTOwnerResponse[];
}
declare class AptosNFTOwnersByCollectionResponse {
    static create(input: AptosNFTOwnersByCollectionResponseInput | AptosNFTOwnersByCollectionResponse): AptosNFTOwnersByCollectionResponse;
    static fromJSON(json: AptosNFTOwnersByCollectionResponseJSON): AptosNFTOwnersByCollectionResponse;
    /**
     * @description The cursor to use for the next page of results. (Cursor is null on last page)
     */
    readonly cursor: string;
    /**
     * @description Indicates if there is a next page of results
     */
    readonly hasNextPage: boolean;
    /**
     * @description The owners for the given collection
     */
    readonly result: AptosNFTOwnerResponse[];
    private constructor();
    toJSON(): AptosNFTOwnersByCollectionResponseJSON;
}

interface GetNFTOwnersByCollectionOperationRequest {
    /**
     * @description The id of the token
     */
    readonly collectionDataIdHash: string;
    /**
     * @description The number of results to return
     */
    readonly limit: number;
    /**
     * @description The number of results to skip
     */
    readonly offset?: number;
    /**
     * @description The cursor to use for getting the next page
     */
    readonly cursor?: string;
    /**
     * @description The addresses of the wallets to blacklist
     */
    readonly walletBlacklist?: string[];
    /**
     * @description The addresses of the wallets to whitelist
     */
    readonly walletWhitelist?: string[];
    /**
     * @description The network of query. Defaults to mainnet.
     */
    readonly network?: AptosNetworkInput | AptosNetwork;
}
interface GetNFTOwnersByCollectionOperationRequestJSON {
    readonly collection_data_id_hash: string;
    readonly limit: number;
    readonly offset?: number;
    readonly cursor?: string;
    readonly wallet_blacklist?: string[];
    readonly wallet_whitelist?: string[];
    readonly network?: AptosNetworkJSON;
}
declare const GetNFTOwnersByCollectionOperation: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosNFTOwnersByCollectionResponseJSON): AptosNFTOwnersByCollectionResponse;
    serializeRequest(request: GetNFTOwnersByCollectionOperationRequest): GetNFTOwnersByCollectionOperationRequestJSON;
};

interface AptosNFTOwnersOfCollectionResponseJSON {
    readonly cursor: string;
    readonly hasNextPage: boolean;
    readonly result: string[];
}
interface AptosNFTOwnersOfCollectionResponseInput {
    readonly cursor: string;
    readonly hasNextPage: boolean;
    readonly result: string[];
}
declare class AptosNFTOwnersOfCollectionResponse {
    static create(input: AptosNFTOwnersOfCollectionResponseInput | AptosNFTOwnersOfCollectionResponse): AptosNFTOwnersOfCollectionResponse;
    static fromJSON(json: AptosNFTOwnersOfCollectionResponseJSON): AptosNFTOwnersOfCollectionResponse;
    /**
     * @description The cursor to use for the next page of results. (Cursor is null on last page)
     */
    readonly cursor: string;
    /**
     * @description Indicates if there is a next page of results
     */
    readonly hasNextPage: boolean;
    /**
     * @description The owner addresses for the given collection
     */
    readonly result: string[];
    private constructor();
    toJSON(): AptosNFTOwnersOfCollectionResponseJSON;
}

interface GetNFTOwnersOfCollectionOperationRequest {
    /**
     * @description The id of the token
     */
    readonly collectionDataIdHash: string;
    /**
     * @description The number of results to return
     */
    readonly limit: number;
    /**
     * @description The number of results to skip
     */
    readonly offset?: number;
    /**
     * @description The cursor to use for getting the next page
     */
    readonly cursor?: string;
    /**
     * @description The network of query. Defaults to mainnet.
     */
    readonly network?: AptosNetworkInput | AptosNetwork;
}
interface GetNFTOwnersOfCollectionOperationRequestJSON {
    readonly collection_data_id_hash: string;
    readonly limit: number;
    readonly offset?: number;
    readonly cursor?: string;
    readonly network?: AptosNetworkJSON;
}
declare const GetNFTOwnersOfCollectionOperation: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosNFTOwnersOfCollectionResponseJSON): AptosNFTOwnersOfCollectionResponse;
    serializeRequest(request: GetNFTOwnersOfCollectionOperationRequest): GetNFTOwnersOfCollectionOperationRequestJSON;
};

interface AptosNFTTransferResponseJSON {
    readonly coin_amount?: AptosNativeJSON;
    readonly coin_type?: string;
    readonly collection_data_id_hash: string;
    readonly collection_name: string;
    readonly creator_address: AptosAddressJSON;
    readonly event_account_address: string;
    readonly event_creation_number: string;
    readonly event_sequence_number: string;
    readonly from_address?: AptosAddressJSON;
    readonly name: string;
    readonly property_version: string;
    readonly to_address?: AptosAddressJSON;
    readonly token_amount: AptosNativeJSON;
    readonly token_data_id_hash: string;
    readonly transaction_timestamp: string;
    readonly transaction_version: string;
    readonly transfer_type: string;
}
interface AptosNFTTransferResponseInput {
    readonly coinAmount?: AptosNativeInput | AptosNative;
    readonly coinType?: string;
    readonly collectionDataIdHash: string;
    readonly collectionName: string;
    readonly creatorAddress: AptosAddressInput | AptosAddress;
    readonly eventAccountAddress: string;
    readonly eventCreationNumber: string;
    readonly eventSequenceNumber: string;
    readonly fromAddress?: AptosAddressInput | AptosAddress;
    readonly name: string;
    readonly propertyVersion: string;
    readonly toAddress?: AptosAddressInput | AptosAddress;
    readonly tokenAmount: AptosNativeInput | AptosNative;
    readonly tokenDataIdHash: string;
    readonly transactionTimestamp: string;
    readonly transactionVersion: string;
    readonly transferType: string;
}
declare class AptosNFTTransferResponse {
    static create(input: AptosNFTTransferResponseInput | AptosNFTTransferResponse): AptosNFTTransferResponse;
    static fromJSON(json: AptosNFTTransferResponseJSON): AptosNFTTransferResponse;
    /**
     * @description The number of tokens transferred
     */
    readonly coinAmount?: AptosNative;
    /**
     * @description The type of tokens transferred
     */
    readonly coinType?: string;
    /**
     * @description The identifier of the collection
     */
    readonly collectionDataIdHash: string;
    /**
     * @description The name of the collection
     */
    readonly collectionName: string;
    /**
     * @description The address of the creator of the collection
     */
    readonly creatorAddress: AptosAddress;
    /**
     * @description The account address of the transfer
     */
    readonly eventAccountAddress: string;
    /**
     * @description The creation number of the event
     */
    readonly eventCreationNumber: string;
    /**
     * @description The sequence number of the event
     */
    readonly eventSequenceNumber: string;
    /**
     * @description The address sending the transfer
     */
    readonly fromAddress?: AptosAddress;
    /**
     * @description The name of the token
     */
    readonly name: string;
    /**
     * @description The property version of the token
     */
    readonly propertyVersion: string;
    /**
     * @description The address recieving the transfer
     */
    readonly toAddress?: AptosAddress;
    /**
     * @description The number of tokens transferred
     */
    readonly tokenAmount: AptosNative;
    /**
     * @description The identifier of the token
     */
    readonly tokenDataIdHash: string;
    /**
     * @description The timestamp of the transfer
     */
    readonly transactionTimestamp: string;
    /**
     * @description The version of the transaction that the transfer is a part of
     */
    readonly transactionVersion: string;
    /**
     * @description The type of transfer
     */
    readonly transferType: string;
    private constructor();
    toJSON(): AptosNFTTransferResponseJSON;
}

interface AptosNFTTransfersByTokensResponseJSON {
    readonly cursor: string;
    readonly hasNextPage: boolean;
    readonly result: AptosNFTTransferResponseJSON[];
}
interface AptosNFTTransfersByTokensResponseInput {
    readonly cursor: string;
    readonly hasNextPage: boolean;
    readonly result: AptosNFTTransferResponseInput[] | AptosNFTTransferResponse[];
}
declare class AptosNFTTransfersByTokensResponse {
    static create(input: AptosNFTTransfersByTokensResponseInput | AptosNFTTransfersByTokensResponse): AptosNFTTransfersByTokensResponse;
    static fromJSON(json: AptosNFTTransfersByTokensResponseJSON): AptosNFTTransfersByTokensResponse;
    /**
     * @description The cursor to use for the next page of results. (Cursor is null on last page)
     */
    readonly cursor: string;
    /**
     * @description Indicates if there is a next page of results
     */
    readonly hasNextPage: boolean;
    /**
     * @description The collections for the given creators
     */
    readonly result: AptosNFTTransferResponse[];
    private constructor();
    toJSON(): AptosNFTTransfersByTokensResponseJSON;
}

interface GetNFTTransfersByIdsOperationRequest {
    /**
     * @description The number of tokens to return
     */
    readonly limit: number;
    /**
     * @description The number of results to skip
     */
    readonly offset?: number;
    /**
     * @description The cursor to use for getting the next page
     */
    readonly cursor?: string;
    /**
     * @description The addresses of the wallets to blacklist
     */
    readonly walletBlacklist?: string[];
    /**
     * @description The addresses of the wallets to whitelist
     */
    readonly walletWhitelist?: string[];
    /**
     * @description The identifiers of the tokens to get
     */
    readonly tokenIds: string[];
    /**
     * @description The network of query. Defaults to mainnet.
     */
    readonly network?: AptosNetworkInput | AptosNetwork;
}
interface GetNFTTransfersByIdsOperationRequestJSON {
    readonly limit: number;
    readonly offset?: number;
    readonly cursor?: string;
    readonly wallet_blacklist?: string[];
    readonly wallet_whitelist?: string[];
    readonly token_ids: string[];
    readonly network?: AptosNetworkJSON;
}
declare const GetNFTTransfersByIdsOperation: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosNFTTransfersByTokensResponseJSON): AptosNFTTransfersByTokensResponse;
    serializeRequest(request: GetNFTTransfersByIdsOperationRequest): GetNFTTransfersByIdsOperationRequestJSON;
};

interface AptosGetNFTTransfersByCollectionResponseJSON {
    readonly cursor: string;
    readonly hasNextPage: boolean;
    readonly result: AptosNFTTransferResponseJSON[];
}
interface AptosGetNFTTransfersByCollectionResponseInput {
    readonly cursor: string;
    readonly hasNextPage: boolean;
    readonly result: AptosNFTTransferResponseInput[] | AptosNFTTransferResponse[];
}
declare class AptosGetNFTTransfersByCollectionResponse {
    static create(input: AptosGetNFTTransfersByCollectionResponseInput | AptosGetNFTTransfersByCollectionResponse): AptosGetNFTTransfersByCollectionResponse;
    static fromJSON(json: AptosGetNFTTransfersByCollectionResponseJSON): AptosGetNFTTransfersByCollectionResponse;
    /**
     * @description The cursor to use for the next page of results. (Cursor is null on last page)
     */
    readonly cursor: string;
    /**
     * @description Indicates if there is a next page of results
     */
    readonly hasNextPage: boolean;
    /**
     * @description The collections for the given creators
     */
    readonly result: AptosNFTTransferResponse[];
    private constructor();
    toJSON(): AptosGetNFTTransfersByCollectionResponseJSON;
}

interface GetNFTTransfersByCollectionOperationRequest {
    /**
     * @description The collection data id hash of the token
     */
    readonly collectionDataIdHash: string;
    /**
     * @description The number of results to return
     */
    readonly limit: number;
    /**
     * @description The number of results to skip
     */
    readonly offset?: number;
    /**
     * @description The cursor to use for getting the next page
     */
    readonly cursor?: string;
    /**
     * @description The addresses of the wallets to whitelist
     */
    readonly walletWhitelist?: string[];
    /**
     * @description The addresses of the wallets to blacklist
     */
    readonly walletBlacklist?: string[];
    /**
     * @description The network of query. Defaults to mainnet.
     */
    readonly network?: AptosNetworkInput | AptosNetwork;
}
interface GetNFTTransfersByCollectionOperationRequestJSON {
    readonly collection_data_id_hash: string;
    readonly limit: number;
    readonly offset?: number;
    readonly cursor?: string;
    readonly wallet_whitelist?: string[];
    readonly wallet_blacklist?: string[];
    readonly network?: AptosNetworkJSON;
}
declare const GetNFTTransfersByCollectionOperation: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosGetNFTTransfersByCollectionResponseJSON): AptosGetNFTTransfersByCollectionResponse;
    serializeRequest(request: GetNFTTransfersByCollectionOperationRequest): GetNFTTransfersByCollectionOperationRequestJSON;
};

interface AptosGetNFTTransfersByCreatorsResponseJSON {
    readonly cursor: string;
    readonly hasNextPage: boolean;
    readonly result: AptosNFTTransferResponseJSON[];
}
interface AptosGetNFTTransfersByCreatorsResponseInput {
    readonly cursor: string;
    readonly hasNextPage: boolean;
    readonly result: AptosNFTTransferResponseInput[] | AptosNFTTransferResponse[];
}
declare class AptosGetNFTTransfersByCreatorsResponse {
    static create(input: AptosGetNFTTransfersByCreatorsResponseInput | AptosGetNFTTransfersByCreatorsResponse): AptosGetNFTTransfersByCreatorsResponse;
    static fromJSON(json: AptosGetNFTTransfersByCreatorsResponseJSON): AptosGetNFTTransfersByCreatorsResponse;
    /**
     * @description The cursor to use for the next page of results. (Cursor is null on last page)
     */
    readonly cursor: string;
    /**
     * @description Indicates if there is a next page of results
     */
    readonly hasNextPage: boolean;
    /**
     * @description The collections for the given creators
     */
    readonly result: AptosNFTTransferResponse[];
    private constructor();
    toJSON(): AptosGetNFTTransfersByCreatorsResponseJSON;
}

interface GetNFTTransfersByCreatorsOperationRequest {
    /**
     * @description The number of results to return
     */
    readonly limit: number;
    /**
     * @description The number of results to skip
     */
    readonly offset?: number;
    /**
     * @description The cursor to use for getting the next page
     */
    readonly cursor?: string;
    /**
     * @description The addresses of the creators
     */
    readonly creatorAddresses: AptosAddressInput[] | AptosAddress[];
    /**
     * @description The ids of the collections to whitelist
     */
    readonly collectionBlacklist?: string[];
    /**
     * @description The ids of the collections to whitelist
     */
    readonly collectionWhitelist?: string[];
    /**
     * @description The network of query. Defaults to mainnet.
     */
    readonly network?: AptosNetworkInput | AptosNetwork;
}
interface GetNFTTransfersByCreatorsOperationRequestJSON {
    readonly limit: number;
    readonly offset?: number;
    readonly cursor?: string;
    readonly creator_addresses: AptosAddressJSON[];
    readonly collection_blacklist?: string[];
    readonly collection_whitelist?: string[];
    readonly network?: AptosNetworkJSON;
}
declare const GetNFTTransfersByCreatorsOperation: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosGetNFTTransfersByCreatorsResponseJSON): AptosGetNFTTransfersByCreatorsResponse;
    serializeRequest(request: GetNFTTransfersByCreatorsOperationRequest): GetNFTTransfersByCreatorsOperationRequestJSON;
};

interface AptosNFTTransfersByWalletsResponseJSON {
    readonly cursor: string;
    readonly hasNextPage: boolean;
    readonly result: AptosNFTTransferResponseJSON[];
}
interface AptosNFTTransfersByWalletsResponseInput {
    readonly cursor: string;
    readonly hasNextPage: boolean;
    readonly result: AptosNFTTransferResponseInput[] | AptosNFTTransferResponse[];
}
declare class AptosNFTTransfersByWalletsResponse {
    static create(input: AptosNFTTransfersByWalletsResponseInput | AptosNFTTransfersByWalletsResponse): AptosNFTTransfersByWalletsResponse;
    static fromJSON(json: AptosNFTTransfersByWalletsResponseJSON): AptosNFTTransfersByWalletsResponse;
    /**
     * @description The cursor to use for the next page of results. (Cursor is null on last page)
     */
    readonly cursor: string;
    /**
     * @description Indicates if there is a next page of results
     */
    readonly hasNextPage: boolean;
    /**
     * @description The collections for the given creators
     */
    readonly result: AptosNFTTransferResponse[];
    private constructor();
    toJSON(): AptosNFTTransfersByWalletsResponseJSON;
}

interface GetNFTTransfersByWalletsOperationRequest {
    /**
     * @description The number of tokens to return
     */
    readonly limit: number;
    /**
     * @description The number of results to skip
     */
    readonly offset?: number;
    /**
     * @description The cursor to use for getting the next page
     */
    readonly cursor?: string;
    /**
     * @description The addresses of the wallets to get transfers for
     */
    readonly walletAddresses: AptosAddressInput[] | AptosAddress[];
    /**
     * @description The ids of the collections to whitelist
     */
    readonly collectionBlacklist?: string[];
    /**
     * @description The ids of the collections to whitelist
     */
    readonly collectionWhitelist?: string[];
    /**
     * @description The network of query. Defaults to mainnet.
     */
    readonly network?: AptosNetworkInput | AptosNetwork;
}
interface GetNFTTransfersByWalletsOperationRequestJSON {
    readonly limit: number;
    readonly offset?: number;
    readonly cursor?: string;
    readonly wallet_addresses: AptosAddressJSON[];
    readonly collection_blacklist?: string[];
    readonly collection_whitelist?: string[];
    readonly network?: AptosNetworkJSON;
}
declare const GetNFTTransfersByWalletsOperation: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosNFTTransfersByWalletsResponseJSON): AptosNFTTransfersByWalletsResponse;
    serializeRequest(request: GetNFTTransfersByWalletsOperationRequest): GetNFTTransfersByWalletsOperationRequestJSON;
};

interface AptosCoinInfoDtoJSON {
    readonly coin_type: string;
    readonly coin_type_hash: string;
    readonly creator_address: AptosAddressJSON;
    readonly decimals: number;
    readonly name: string;
    readonly supply_aggregator_table_handle: string;
    readonly supply_aggregator_table_key: string;
    readonly symbol: string;
    readonly transaction_created_timestamp: string;
    readonly transaction_version_created: string;
}
interface AptosCoinInfoDtoInput {
    readonly coinType: string;
    readonly coinTypeHash: string;
    readonly creatorAddress: AptosAddressInput | AptosAddress;
    readonly decimals: number;
    readonly name: string;
    readonly supplyAggregatorTableHandle: string;
    readonly supplyAggregatorTableKey: string;
    readonly symbol: string;
    readonly transactionCreatedTimestamp: string;
    readonly transactionVersionCreated: string;
}
declare class AptosCoinInfoDto {
    static create(input: AptosCoinInfoDtoInput | AptosCoinInfoDto): AptosCoinInfoDto;
    static fromJSON(json: AptosCoinInfoDtoJSON): AptosCoinInfoDto;
    /**
     * @description The definition of the coin structure (identifier)
     */
    readonly coinType: string;
    /**
     * @description The hash of the coin_type (identifier) and a known fixed length
     */
    readonly coinTypeHash: string;
    /**
     * @description The address of the creator of the coin
     */
    readonly creatorAddress: AptosAddress;
    /**
     * @description The number of decimals of the coin
     */
    readonly decimals: number;
    /**
     * @description The name of the Coin
     */
    readonly name: string;
    /**
     * @description The data structure of the token
     */
    readonly supplyAggregatorTableHandle: string;
    /**
     * @description The data structure of the token
     */
    readonly supplyAggregatorTableKey: string;
    /**
     * @description The symbol of the coin
     */
    readonly symbol: string;
    /**
     * @description The timestamp of the transaction of when the coin was created
     */
    readonly transactionCreatedTimestamp: string;
    /**
     * @description The version of the transaction where the coin was created
     */
    readonly transactionVersionCreated: string;
    private constructor();
    toJSON(): AptosCoinInfoDtoJSON;
}

interface GetCoinInfoByCoinTypeHashesOperationRequest {
    /**
     * @description The coin type hashes to fetch info about
     */
    readonly coinTypeHashes: string[];
    /**
     * @description The network of query. Defaults to mainnet.
     */
    readonly network?: AptosNetworkInput | AptosNetwork;
}
interface GetCoinInfoByCoinTypeHashesOperationRequestJSON {
    readonly coin_type_hashes: string[];
    readonly network?: AptosNetworkJSON;
}
declare const GetCoinInfoByCoinTypeHashesOperation: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosCoinInfoDtoJSON[]): AptosCoinInfoDto[];
    serializeRequest(request: GetCoinInfoByCoinTypeHashesOperationRequest): GetCoinInfoByCoinTypeHashesOperationRequestJSON;
};

interface AptosGetLatestCoinsResponseJSON {
    readonly cursor: string;
    readonly hasNextPage: boolean;
    readonly result: AptosCoinInfoDtoJSON[];
}
interface AptosGetLatestCoinsResponseInput {
    readonly cursor: string;
    readonly hasNextPage: boolean;
    readonly result: AptosCoinInfoDtoInput[] | AptosCoinInfoDto[];
}
declare class AptosGetLatestCoinsResponse {
    static create(input: AptosGetLatestCoinsResponseInput | AptosGetLatestCoinsResponse): AptosGetLatestCoinsResponse;
    static fromJSON(json: AptosGetLatestCoinsResponseJSON): AptosGetLatestCoinsResponse;
    /**
     * @description The cursor to use for the next page of results. (Cursor is null on last page)
     */
    readonly cursor: string;
    /**
     * @description Indicates if there is a next page of results
     */
    readonly hasNextPage: boolean;
    /**
     * @description The coins matching the query
     */
    readonly result: AptosCoinInfoDto[];
    private constructor();
    toJSON(): AptosGetLatestCoinsResponseJSON;
}

interface GetLatestCoinsOperationRequest {
    /**
     * @description The number of results to return
     */
    readonly limit: number;
    /**
     * @description The number of results to skip
     */
    readonly offset?: number;
    /**
     * @description The cursor to use for getting the next page
     */
    readonly cursor?: string;
    /**
     * @description The network of query. Defaults to mainnet.
     */
    readonly network?: AptosNetworkInput | AptosNetwork;
}
interface GetLatestCoinsOperationRequestJSON {
    readonly limit: number;
    readonly offset?: number;
    readonly cursor?: string;
    readonly network?: AptosNetworkJSON;
}
declare const GetLatestCoinsOperation: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosGetLatestCoinsResponseJSON): AptosGetLatestCoinsResponse;
    serializeRequest(request: GetLatestCoinsOperationRequest): GetLatestCoinsOperationRequestJSON;
};

interface AptosGetCoinsByNameRangeResponseJSON {
    readonly cursor: string;
    readonly hasNextPage: boolean;
    readonly result: AptosCoinInfoDtoJSON[];
}
interface AptosGetCoinsByNameRangeResponseInput {
    readonly cursor: string;
    readonly hasNextPage: boolean;
    readonly result: AptosCoinInfoDtoInput[] | AptosCoinInfoDto[];
}
declare class AptosGetCoinsByNameRangeResponse {
    static create(input: AptosGetCoinsByNameRangeResponseInput | AptosGetCoinsByNameRangeResponse): AptosGetCoinsByNameRangeResponse;
    static fromJSON(json: AptosGetCoinsByNameRangeResponseJSON): AptosGetCoinsByNameRangeResponse;
    /**
     * @description The cursor to use for the next page of results. (Cursor is null on last page)
     */
    readonly cursor: string;
    /**
     * @description Indicates if there is a next page of results
     */
    readonly hasNextPage: boolean;
    /**
     * @description The coins matching the query
     */
    readonly result: AptosCoinInfoDto[];
    private constructor();
    toJSON(): AptosGetCoinsByNameRangeResponseJSON;
}

interface GetCoinsByNameRangeOperationRequest {
    /**
     * @description The number of results to return
     */
    readonly limit: number;
    /**
     * @description The number of results to skip
     */
    readonly offset?: number;
    /**
     * @description The cursor to use for getting the next page
     */
    readonly cursor?: string;
    /**
     * @description The name of the coin to start from (inclusive and case sensitive)
     */
    readonly fromName?: string;
    /**
     * @description The name of the coin to end at (inclusive and case sensitive)
     */
    readonly toName?: string;
    /**
     * @description The network of query. Defaults to mainnet.
     */
    readonly network?: AptosNetworkInput | AptosNetwork;
}
interface GetCoinsByNameRangeOperationRequestJSON {
    readonly limit: number;
    readonly offset?: number;
    readonly cursor?: string;
    readonly from_name?: string;
    readonly to_name?: string;
    readonly network?: AptosNetworkJSON;
}
declare const GetCoinsByNameRangeOperation: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosGetCoinsByNameRangeResponseJSON): AptosGetCoinsByNameRangeResponse;
    serializeRequest(request: GetCoinsByNameRangeOperationRequest): GetCoinsByNameRangeOperationRequestJSON;
};

interface AptosGetCoinsBySymbolRangeResponseJSON {
    readonly cursor: string;
    readonly hasNextPage: boolean;
    readonly result: AptosCoinInfoDtoJSON[];
}
interface AptosGetCoinsBySymbolRangeResponseInput {
    readonly cursor: string;
    readonly hasNextPage: boolean;
    readonly result: AptosCoinInfoDtoInput[] | AptosCoinInfoDto[];
}
declare class AptosGetCoinsBySymbolRangeResponse {
    static create(input: AptosGetCoinsBySymbolRangeResponseInput | AptosGetCoinsBySymbolRangeResponse): AptosGetCoinsBySymbolRangeResponse;
    static fromJSON(json: AptosGetCoinsBySymbolRangeResponseJSON): AptosGetCoinsBySymbolRangeResponse;
    /**
     * @description The cursor to use for the next page of results. (Cursor is null on last page)
     */
    readonly cursor: string;
    /**
     * @description Indicates if there is a next page of results
     */
    readonly hasNextPage: boolean;
    /**
     * @description The coins matching the query
     */
    readonly result: AptosCoinInfoDto[];
    private constructor();
    toJSON(): AptosGetCoinsBySymbolRangeResponseJSON;
}

interface GetCoinsBySymbolRangeOperationRequest {
    /**
     * @description The number of results to return
     */
    readonly limit: number;
    /**
     * @description The number of results to skip
     */
    readonly offset?: number;
    /**
     * @description The cursor to use for getting the next page
     */
    readonly cursor?: string;
    /**
     * @description The name of the coin to start from (inclusive and case sensitive)
     */
    readonly fromSymbol?: string;
    /**
     * @description The name of the coin to end at (inclusive and case sensitive)
     */
    readonly toSymbol?: string;
    /**
     * @description The network of query. Defaults to mainnet.
     */
    readonly network?: AptosNetworkInput | AptosNetwork;
}
interface GetCoinsBySymbolRangeOperationRequestJSON {
    readonly limit: number;
    readonly offset?: number;
    readonly cursor?: string;
    readonly from_symbol?: string;
    readonly to_symbol?: string;
    readonly network?: AptosNetworkJSON;
}
declare const GetCoinsBySymbolRangeOperation: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosGetCoinsBySymbolRangeResponseJSON): AptosGetCoinsBySymbolRangeResponse;
    serializeRequest(request: GetCoinsBySymbolRangeOperationRequest): GetCoinsBySymbolRangeOperationRequestJSON;
};

interface AptosGetCoinsByCreatorsResponseJSON {
    readonly cursor: string;
    readonly hasNextPage: boolean;
    readonly result: AptosCoinInfoDtoJSON[];
}
interface AptosGetCoinsByCreatorsResponseInput {
    readonly cursor: string;
    readonly hasNextPage: boolean;
    readonly result: AptosCoinInfoDtoInput[] | AptosCoinInfoDto[];
}
declare class AptosGetCoinsByCreatorsResponse {
    static create(input: AptosGetCoinsByCreatorsResponseInput | AptosGetCoinsByCreatorsResponse): AptosGetCoinsByCreatorsResponse;
    static fromJSON(json: AptosGetCoinsByCreatorsResponseJSON): AptosGetCoinsByCreatorsResponse;
    /**
     * @description The cursor to use for the next page of results. (Cursor is null on last page)
     */
    readonly cursor: string;
    /**
     * @description Indicates if there is a next page of results
     */
    readonly hasNextPage: boolean;
    /**
     * @description The coins created by the given creators
     */
    readonly result: AptosCoinInfoDto[];
    private constructor();
    toJSON(): AptosGetCoinsByCreatorsResponseJSON;
}

interface GetCoinsByCreatorsOperationRequest {
    /**
     * @description The number of results to return
     */
    readonly limit: number;
    /**
     * @description The number of results to skip
     */
    readonly offset?: number;
    /**
     * @description The cursor to use for getting the next page
     */
    readonly cursor?: string;
    /**
     * @description The addresses of the creators
     */
    readonly creatorAddresses: AptosAddressInput[] | AptosAddress[];
    /**
     * @description The network of query. Defaults to mainnet.
     */
    readonly network?: AptosNetworkInput | AptosNetwork;
}
interface GetCoinsByCreatorsOperationRequestJSON {
    readonly limit: number;
    readonly offset?: number;
    readonly cursor?: string;
    readonly creator_addresses: AptosAddressJSON[];
    readonly network?: AptosNetworkJSON;
}
declare const GetCoinsByCreatorsOperation: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosGetCoinsByCreatorsResponseJSON): AptosGetCoinsByCreatorsResponse;
    serializeRequest(request: GetCoinsByCreatorsOperationRequest): GetCoinsByCreatorsOperationRequestJSON;
};

interface AptosCoinTransferDtoJSON {
    readonly activity_type: string;
    readonly amount: AptosNativeJSON;
    readonly block_height: string;
    readonly coin_type: string;
    readonly entry_function_id_str: string;
    readonly event_account_address: string;
    readonly event_creation_number: string;
    readonly event_sequence_number: string;
    readonly is_gas_fee: boolean;
    readonly is_transaction_success: boolean;
    readonly owner_address: AptosAddressJSON;
    readonly transaction_timestamp: string;
    readonly transaction_version: string;
}
interface AptosCoinTransferDtoInput {
    readonly activityType: string;
    readonly amount: AptosNativeInput | AptosNative;
    readonly blockHeight: string;
    readonly coinType: string;
    readonly entryFunctionIdStr: string;
    readonly eventAccountAddress: string;
    readonly eventCreationNumber: string;
    readonly eventSequenceNumber: string;
    readonly isGasFee: boolean;
    readonly isTransactionSuccess: boolean;
    readonly ownerAddress: AptosAddressInput | AptosAddress;
    readonly transactionTimestamp: string;
    readonly transactionVersion: string;
}
declare class AptosCoinTransferDto {
    static create(input: AptosCoinTransferDtoInput | AptosCoinTransferDto): AptosCoinTransferDto;
    static fromJSON(json: AptosCoinTransferDtoJSON): AptosCoinTransferDto;
    /**
     * @description The definition of the coin activity
     */
    readonly activityType: string;
    /**
     * @description The amount being transfered
     */
    readonly amount: AptosNative;
    /**
     * @description The blockheight that the transfer was included in
     */
    readonly blockHeight: string;
    /**
     * @description The definition of the coin structure (identifier)
     */
    readonly coinType: string;
    /**
     * @description The function that was called to transfer the coin
     */
    readonly entryFunctionIdStr: string;
    /**
     * @description The address of the event account
     */
    readonly eventAccountAddress: string;
    /**
     * @description The event creation number
     */
    readonly eventCreationNumber: string;
    /**
     * @description The sequence number of the event
     */
    readonly eventSequenceNumber: string;
    /**
     * @description If the transfer was a gas fee or not
     */
    readonly isGasFee: boolean;
    /**
     * @description If the transfer was successful or not
     */
    readonly isTransactionSuccess: boolean;
    /**
     * @description The address of the owner of the coin
     */
    readonly ownerAddress: AptosAddress;
    /**
     * @description The timestamp of the transaction of when the coin was transfered
     */
    readonly transactionTimestamp: string;
    /**
     * @description The version of the transaction where the coin was transfered
     */
    readonly transactionVersion: string;
    private constructor();
    toJSON(): AptosCoinTransferDtoJSON;
}

interface AptosGetCoinTransfersByOwnerAddressesResponseJSON {
    readonly cursor: string;
    readonly hasNextPage: boolean;
    readonly result: AptosCoinTransferDtoJSON[];
}
interface AptosGetCoinTransfersByOwnerAddressesResponseInput {
    readonly cursor: string;
    readonly hasNextPage: boolean;
    readonly result: AptosCoinTransferDtoInput[] | AptosCoinTransferDto[];
}
declare class AptosGetCoinTransfersByOwnerAddressesResponse {
    static create(input: AptosGetCoinTransfersByOwnerAddressesResponseInput | AptosGetCoinTransfersByOwnerAddressesResponse): AptosGetCoinTransfersByOwnerAddressesResponse;
    static fromJSON(json: AptosGetCoinTransfersByOwnerAddressesResponseJSON): AptosGetCoinTransfersByOwnerAddressesResponse;
    /**
     * @description The cursor to use for the next page of results. (Cursor is null on last page)
     */
    readonly cursor: string;
    /**
     * @description Indicates if there is a next page of results
     */
    readonly hasNextPage: boolean;
    /**
     * @description The coins transfers for the provided owner addresses
     */
    readonly result: AptosCoinTransferDto[];
    private constructor();
    toJSON(): AptosGetCoinTransfersByOwnerAddressesResponseJSON;
}

interface GetCoinTransfersByOwnerAddressesOperationRequest {
    /**
     * @description The number of results to return
     */
    readonly limit: number;
    /**
     * @description The number of results to skip
     */
    readonly offset?: number;
    /**
     * @description The cursor to use for getting the next page
     */
    readonly cursor?: string;
    /**
     * @description The addresses of the owners to get tokens for
     */
    readonly ownerAddresses: AptosAddressInput[] | AptosAddress[];
    /**
     * @description The date from which to fetch coin transfers
     */
    readonly fromDate?: string;
    /**
     * @description The date to which to fetch coin transfers
     */
    readonly toDate?: string;
    /**
     * @description The coin types of the coins to whitelist
     */
    readonly coinTypeBlacklist?: string[];
    /**
     * @description The coin types of the coins to whitelist
     */
    readonly coinTypeWhitelist?: string[];
    /**
     * @description The network of query. Defaults to mainnet.
     */
    readonly network?: AptosNetworkInput | AptosNetwork;
}
interface GetCoinTransfersByOwnerAddressesOperationRequestJSON {
    readonly limit: number;
    readonly offset?: number;
    readonly cursor?: string;
    readonly owner_addresses: AptosAddressJSON[];
    readonly from_date?: string;
    readonly to_date?: string;
    readonly coin_type_blacklist?: string[];
    readonly coin_type_whitelist?: string[];
    readonly network?: AptosNetworkJSON;
}
declare const GetCoinTransfersByOwnerAddressesOperation: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosGetCoinTransfersByOwnerAddressesResponseJSON): AptosGetCoinTransfersByOwnerAddressesResponse;
    serializeRequest(request: GetCoinTransfersByOwnerAddressesOperationRequest): GetCoinTransfersByOwnerAddressesOperationRequestJSON;
};

interface AptosGetCoinTransfersByBlockHeightsResponseJSON {
    readonly cursor: string;
    readonly hasNextPage: boolean;
    readonly result: AptosCoinTransferDtoJSON[];
}
interface AptosGetCoinTransfersByBlockHeightsResponseInput {
    readonly cursor: string;
    readonly hasNextPage: boolean;
    readonly result: AptosCoinTransferDtoInput[] | AptosCoinTransferDto[];
}
declare class AptosGetCoinTransfersByBlockHeightsResponse {
    static create(input: AptosGetCoinTransfersByBlockHeightsResponseInput | AptosGetCoinTransfersByBlockHeightsResponse): AptosGetCoinTransfersByBlockHeightsResponse;
    static fromJSON(json: AptosGetCoinTransfersByBlockHeightsResponseJSON): AptosGetCoinTransfersByBlockHeightsResponse;
    /**
     * @description The cursor to use for the next page of results. (Cursor is null on last page)
     */
    readonly cursor: string;
    /**
     * @description Indicates if there is a next page of results
     */
    readonly hasNextPage: boolean;
    /**
     * @description The coins transfers for the provided block heights
     */
    readonly result: AptosCoinTransferDto[];
    private constructor();
    toJSON(): AptosGetCoinTransfersByBlockHeightsResponseJSON;
}

interface GetCoinTransfersByBlockHeightsOperationRequest {
    /**
     * @description The number of results to return
     */
    readonly limit: number;
    /**
     * @description The number of results to skip
     */
    readonly offset?: number;
    /**
     * @description The cursor to use for getting the next page
     */
    readonly cursor?: string;
    /**
     * @description The coin types to fetch info about
     */
    readonly blockHeights: string[];
    /**
     * @description The network of query. Defaults to mainnet.
     */
    readonly network?: AptosNetworkInput | AptosNetwork;
}
interface GetCoinTransfersByBlockHeightsOperationRequestJSON {
    readonly limit: number;
    readonly offset?: number;
    readonly cursor?: string;
    readonly block_heights: string[];
    readonly network?: AptosNetworkJSON;
}
declare const GetCoinTransfersByBlockHeightsOperation: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosGetCoinTransfersByBlockHeightsResponseJSON): AptosGetCoinTransfersByBlockHeightsResponse;
    serializeRequest(request: GetCoinTransfersByBlockHeightsOperationRequest): GetCoinTransfersByBlockHeightsOperationRequestJSON;
};

interface AptosGetCoinTransfersByCoinTypeResponseJSON {
    readonly cursor: string;
    readonly hasNextPage: boolean;
    readonly result: AptosCoinTransferDtoJSON[];
}
interface AptosGetCoinTransfersByCoinTypeResponseInput {
    readonly cursor: string;
    readonly hasNextPage: boolean;
    readonly result: AptosCoinTransferDtoInput[] | AptosCoinTransferDto[];
}
declare class AptosGetCoinTransfersByCoinTypeResponse {
    static create(input: AptosGetCoinTransfersByCoinTypeResponseInput | AptosGetCoinTransfersByCoinTypeResponse): AptosGetCoinTransfersByCoinTypeResponse;
    static fromJSON(json: AptosGetCoinTransfersByCoinTypeResponseJSON): AptosGetCoinTransfersByCoinTypeResponse;
    /**
     * @description The cursor to use for the next page of results. (Cursor is null on last page)
     */
    readonly cursor: string;
    /**
     * @description Indicates if there is a next page of results
     */
    readonly hasNextPage: boolean;
    /**
     * @description The coins transfers for the provided coin type
     */
    readonly result: AptosCoinTransferDto[];
    private constructor();
    toJSON(): AptosGetCoinTransfersByCoinTypeResponseJSON;
}

interface GetCoinTransfersByCoinTypeOperationRequest {
    /**
     * @description The coin type to fetch info about
     */
    readonly coinType: string;
    /**
     * @description The number of results to return
     */
    readonly limit: number;
    /**
     * @description The number of results to skip
     */
    readonly offset?: number;
    /**
     * @description The cursor to use for getting the next page
     */
    readonly cursor?: string;
    /**
     * @description The date from which to fetch coin transfers
     */
    readonly fromDate?: string;
    /**
     * @description The date to which to fetch coin transfers
     */
    readonly toDate?: string;
    /**
     * @description The network of query. Defaults to mainnet.
     */
    readonly network?: AptosNetworkInput | AptosNetwork;
}
interface GetCoinTransfersByCoinTypeOperationRequestJSON {
    readonly coin_type: string;
    readonly limit: number;
    readonly offset?: number;
    readonly cursor?: string;
    readonly from_date?: string;
    readonly to_date?: string;
    readonly network?: AptosNetworkJSON;
}
declare const GetCoinTransfersByCoinTypeOperation: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosGetCoinTransfersByCoinTypeResponseJSON): AptosGetCoinTransfersByCoinTypeResponse;
    serializeRequest(request: GetCoinTransfersByCoinTypeOperationRequest): GetCoinTransfersByCoinTypeOperationRequestJSON;
};

interface AptosCurrentCoinBalanceDtoJSON {
    readonly amount: AptosNativeJSON;
    readonly coin_type: string;
    readonly coin_type_hash: string;
    readonly last_transaction_timestamp: string;
    readonly last_transaction_version: string;
    readonly owner_address: AptosAddressJSON;
}
interface AptosCurrentCoinBalanceDtoInput {
    readonly amount: AptosNativeInput | AptosNative;
    readonly coinType: string;
    readonly coinTypeHash: string;
    readonly lastTransactionTimestamp: string;
    readonly lastTransactionVersion: string;
    readonly ownerAddress: AptosAddressInput | AptosAddress;
}
declare class AptosCurrentCoinBalanceDto {
    static create(input: AptosCurrentCoinBalanceDtoInput | AptosCurrentCoinBalanceDto): AptosCurrentCoinBalanceDto;
    static fromJSON(json: AptosCurrentCoinBalanceDtoJSON): AptosCurrentCoinBalanceDto;
    /**
     * @description The amount being transfered
     */
    readonly amount: AptosNative;
    /**
     * @description The definition of the coin structure (identifier)
     */
    readonly coinType: string;
    /**
     * @description The hash of the coin_type (identifier) and a known fixed length
     */
    readonly coinTypeHash: string;
    /**
     * @description The timestamp of the last update to the balance
     */
    readonly lastTransactionTimestamp: string;
    /**
     * @description The version of the transaction where the balance was last s
     */
    readonly lastTransactionVersion: string;
    /**
     * @description The address of the owner of the coin
     */
    readonly ownerAddress: AptosAddress;
    private constructor();
    toJSON(): AptosCurrentCoinBalanceDtoJSON;
}

interface AptosGetTopHoldersByCoinResponseJSON {
    readonly cursor: string;
    readonly hasNextPage: boolean;
    readonly result: AptosCurrentCoinBalanceDtoJSON[];
}
interface AptosGetTopHoldersByCoinResponseInput {
    readonly cursor: string;
    readonly hasNextPage: boolean;
    readonly result: AptosCurrentCoinBalanceDtoInput[] | AptosCurrentCoinBalanceDto[];
}
declare class AptosGetTopHoldersByCoinResponse {
    static create(input: AptosGetTopHoldersByCoinResponseInput | AptosGetTopHoldersByCoinResponse): AptosGetTopHoldersByCoinResponse;
    static fromJSON(json: AptosGetTopHoldersByCoinResponseJSON): AptosGetTopHoldersByCoinResponse;
    /**
     * @description The cursor to use for the next page of results. (Cursor is null on last page)
     */
    readonly cursor: string;
    /**
     * @description Indicates if there is a next page of results
     */
    readonly hasNextPage: boolean;
    /**
     * @description The top holders of the given coin
     */
    readonly result: AptosCurrentCoinBalanceDto[];
    private constructor();
    toJSON(): AptosGetTopHoldersByCoinResponseJSON;
}

interface GetTopHoldersByCoinOperationRequest {
    /**
     * @description The coin type hash to fetch info about
     */
    readonly coinTypeHash: string;
    /**
     * @description The number of results to return
     */
    readonly limit: number;
    /**
     * @description The number of results to skip
     */
    readonly offset?: number;
    /**
     * @description The cursor to use for getting the next page
     */
    readonly cursor?: string;
    /**
     * @description The minimum amount of coins required for a wallet to be included in the results
     */
    readonly minAmount?: AptosNativeInput | AptosNative;
    /**
     * @description The minimum version on when the balance was last updated
     */
    readonly minVersion?: number;
    /**
     * @description The addresses of the wallets to blacklist
     */
    readonly walletBlacklist?: string[];
    /**
     * @description The addresses of the wallets to whitelist
     */
    readonly walletWhitelist?: string[];
    /**
     * @description The network of query. Defaults to mainnet.
     */
    readonly network?: AptosNetworkInput | AptosNetwork;
}
interface GetTopHoldersByCoinOperationRequestJSON {
    readonly coin_type_hash: string;
    readonly limit: number;
    readonly offset?: number;
    readonly cursor?: string;
    readonly min_amount?: AptosNativeJSON;
    readonly min_version?: number;
    readonly wallet_blacklist?: string[];
    readonly wallet_whitelist?: string[];
    readonly network?: AptosNetworkJSON;
}
declare const GetTopHoldersByCoinOperation: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosGetTopHoldersByCoinResponseJSON): AptosGetTopHoldersByCoinResponse;
    serializeRequest(request: GetTopHoldersByCoinOperationRequest): GetTopHoldersByCoinOperationRequestJSON;
};

interface AptosGetCoinBalancesByWalletsResponseJSON {
    readonly cursor: string;
    readonly hasNextPage: boolean;
    readonly result: AptosCurrentCoinBalanceDtoJSON[];
}
interface AptosGetCoinBalancesByWalletsResponseInput {
    readonly cursor: string;
    readonly hasNextPage: boolean;
    readonly result: AptosCurrentCoinBalanceDtoInput[] | AptosCurrentCoinBalanceDto[];
}
declare class AptosGetCoinBalancesByWalletsResponse {
    static create(input: AptosGetCoinBalancesByWalletsResponseInput | AptosGetCoinBalancesByWalletsResponse): AptosGetCoinBalancesByWalletsResponse;
    static fromJSON(json: AptosGetCoinBalancesByWalletsResponseJSON): AptosGetCoinBalancesByWalletsResponse;
    /**
     * @description The cursor to use for the next page of results. (Cursor is null on last page)
     */
    readonly cursor: string;
    /**
     * @description Indicates if there is a next page of results
     */
    readonly hasNextPage: boolean;
    /**
     * @description The coins balances for the provided wallets
     */
    readonly result: AptosCurrentCoinBalanceDto[];
    private constructor();
    toJSON(): AptosGetCoinBalancesByWalletsResponseJSON;
}

interface GetCoinBalancesByWalletsOperationRequest {
    /**
     * @description The number of results to return
     */
    readonly limit: number;
    /**
     * @description The number of results to skip
     */
    readonly offset?: number;
    /**
     * @description The cursor to use for getting the next page
     */
    readonly cursor?: string;
    /**
     * @description The addresses of the owners to get coin balances for
     */
    readonly ownerAddresses: AptosAddressInput[] | AptosAddress[];
    /**
     * @description The coin type hashes of the coins to whitelist
     */
    readonly coinTypeHashBlacklist?: string[];
    /**
     * @description The coin type hashes of the coins to whitelist
     */
    readonly coinTypeHashWhitelist?: string[];
    /**
     * @description The network of query. Defaults to mainnet.
     */
    readonly network?: AptosNetworkInput | AptosNetwork;
}
interface GetCoinBalancesByWalletsOperationRequestJSON {
    readonly limit: number;
    readonly offset?: number;
    readonly cursor?: string;
    readonly owner_addresses: AptosAddressJSON[];
    readonly coin_type_hash_blacklist?: string[];
    readonly coin_type_hash_whitelist?: string[];
    readonly network?: AptosNetworkJSON;
}
declare const GetCoinBalancesByWalletsOperation: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosGetCoinBalancesByWalletsResponseJSON): AptosGetCoinBalancesByWalletsResponse;
    serializeRequest(request: GetCoinBalancesByWalletsOperationRequest): GetCoinBalancesByWalletsOperationRequestJSON;
};

interface AptosHistoricalCoinBalanceDtoJSON {
    readonly amount: AptosNativeJSON;
    readonly coin_type: string;
    readonly coin_type_hash: string;
    readonly transaction_timestamp: string;
    readonly transaction_version: string;
    readonly owner_address: AptosAddressJSON;
}
interface AptosHistoricalCoinBalanceDtoInput {
    readonly amount: AptosNativeInput | AptosNative;
    readonly coinType: string;
    readonly coinTypeHash: string;
    readonly transactionTimestamp: string;
    readonly transactionVersion: string;
    readonly ownerAddress: AptosAddressInput | AptosAddress;
}
declare class AptosHistoricalCoinBalanceDto {
    static create(input: AptosHistoricalCoinBalanceDtoInput | AptosHistoricalCoinBalanceDto): AptosHistoricalCoinBalanceDto;
    static fromJSON(json: AptosHistoricalCoinBalanceDtoJSON): AptosHistoricalCoinBalanceDto;
    /**
     * @description The amount being transfered
     */
    readonly amount: AptosNative;
    /**
     * @description The definition of the coin structure (identifier)
     */
    readonly coinType: string;
    /**
     * @description The hash of the coin_type (identifier) and a known fixed length
     */
    readonly coinTypeHash: string;
    /**
     * @description The timestamp of the updated balance
     */
    readonly transactionTimestamp: string;
    /**
     * @description The version of the transaction where the balacne was updated
     */
    readonly transactionVersion: string;
    /**
     * @description The address of the owner of the coin
     */
    readonly ownerAddress: AptosAddress;
    private constructor();
    toJSON(): AptosHistoricalCoinBalanceDtoJSON;
}

interface AptosGetHistoricalCoinBalancesByWalletsResponseJSON {
    readonly cursor: string;
    readonly hasNextPage: boolean;
    readonly result: AptosHistoricalCoinBalanceDtoJSON[];
}
interface AptosGetHistoricalCoinBalancesByWalletsResponseInput {
    readonly cursor: string;
    readonly hasNextPage: boolean;
    readonly result: AptosHistoricalCoinBalanceDtoInput[] | AptosHistoricalCoinBalanceDto[];
}
declare class AptosGetHistoricalCoinBalancesByWalletsResponse {
    static create(input: AptosGetHistoricalCoinBalancesByWalletsResponseInput | AptosGetHistoricalCoinBalancesByWalletsResponse): AptosGetHistoricalCoinBalancesByWalletsResponse;
    static fromJSON(json: AptosGetHistoricalCoinBalancesByWalletsResponseJSON): AptosGetHistoricalCoinBalancesByWalletsResponse;
    /**
     * @description The cursor to use for the next page of results. (Cursor is null on last page)
     */
    readonly cursor: string;
    /**
     * @description Indicates if there is a next page of results
     */
    readonly hasNextPage: boolean;
    /**
     * @description The coins balances for the provided wallets
     */
    readonly result: AptosHistoricalCoinBalanceDto[];
    private constructor();
    toJSON(): AptosGetHistoricalCoinBalancesByWalletsResponseJSON;
}

interface GetHistoricalCoinBalancesByWalletsOperationRequest {
    /**
     * @description The number of results to return
     */
    readonly limit: number;
    /**
     * @description The number of results to skip
     */
    readonly offset?: number;
    /**
     * @description The cursor to use for getting the next page
     */
    readonly cursor?: string;
    /**
     * @description The addresses of the owner addresses to get historical balances for
     */
    readonly ownerAddresses: AptosAddressInput[] | AptosAddress[];
    /**
     * @description The coin type hash of the coins to whitelist
     */
    readonly coinTypeHashBlacklist?: string[];
    /**
     * @description The coin type hash of the coins to whitelist
     */
    readonly coinTypeHashWhitelist?: string[];
    /**
     * @description The network of query. Defaults to mainnet.
     */
    readonly network?: AptosNetworkInput | AptosNetwork;
}
interface GetHistoricalCoinBalancesByWalletsOperationRequestJSON {
    readonly limit: number;
    readonly offset?: number;
    readonly cursor?: string;
    readonly owner_addresses: AptosAddressJSON[];
    readonly coin_type_hash_blacklist?: string[];
    readonly coin_type_hash_whitelist?: string[];
    readonly network?: AptosNetworkJSON;
}
declare const GetHistoricalCoinBalancesByWalletsOperation: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosGetHistoricalCoinBalancesByWalletsResponseJSON): AptosGetHistoricalCoinBalancesByWalletsResponse;
    serializeRequest(request: GetHistoricalCoinBalancesByWalletsOperationRequest): GetHistoricalCoinBalancesByWalletsOperationRequestJSON;
};

interface GetCoinTransfersByWalletAddressesOperationRequest {
    /**
     * @description The number of results to return
     */
    readonly limit: number;
    /**
     * @description The number of results to skip
     */
    readonly offset?: number;
    /**
     * @description The cursor to use for getting the next page
     */
    readonly cursor?: string;
    /**
     * @description The addresses of the owners to get tokens for
     */
    readonly ownerAddresses: AptosAddressInput[] | AptosAddress[];
    /**
     * @description The date from which to fetch coin transfers
     */
    readonly fromDate?: string;
    /**
     * @description The date to which to fetch coin transfers
     */
    readonly toDate?: string;
    /**
     * @description The coin types of the coins to whitelist
     */
    readonly coinTypeBlacklist?: string[];
    /**
     * @description The coin types of the coins to whitelist
     */
    readonly coinTypeWhitelist?: string[];
    /**
     * @description The network of query. Defaults to mainnet.
     */
    readonly network?: AptosNetworkInput | AptosNetwork;
}
interface GetCoinTransfersByWalletAddressesOperationRequestJSON {
    readonly limit: number;
    readonly offset?: number;
    readonly cursor?: string;
    readonly owner_addresses: AptosAddressJSON[];
    readonly from_date?: string;
    readonly to_date?: string;
    readonly coin_type_blacklist?: string[];
    readonly coin_type_whitelist?: string[];
    readonly network?: AptosNetworkJSON;
}
declare const GetCoinTransfersByWalletAddressesOperation: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosGetCoinTransfersByOwnerAddressesResponseJSON): AptosGetCoinTransfersByOwnerAddressesResponse;
    serializeRequest(request: GetCoinTransfersByWalletAddressesOperationRequest): GetCoinTransfersByWalletAddressesOperationRequestJSON;
};

interface AptosNFTsByOwnersResponseJSON {
    readonly cursor: string;
    readonly hasNextPage: boolean;
    readonly result: AptosNFTOwnerResponseJSON[];
}
interface AptosNFTsByOwnersResponseInput {
    readonly cursor: string;
    readonly hasNextPage: boolean;
    readonly result: AptosNFTOwnerResponseInput[] | AptosNFTOwnerResponse[];
}
declare class AptosNFTsByOwnersResponse {
    static create(input: AptosNFTsByOwnersResponseInput | AptosNFTsByOwnersResponse): AptosNFTsByOwnersResponse;
    static fromJSON(json: AptosNFTsByOwnersResponseJSON): AptosNFTsByOwnersResponse;
    /**
     * @description The cursor to use for the next page of results. (Cursor is null on last page)
     */
    readonly cursor: string;
    /**
     * @description Indicates if there is a next page of results
     */
    readonly hasNextPage: boolean;
    /**
     * @description The tokens for the given owners
     */
    readonly result: AptosNFTOwnerResponse[];
    private constructor();
    toJSON(): AptosNFTsByOwnersResponseJSON;
}

interface GetNFTByOwnersOperationRequest {
    /**
     * @description The number of results to return
     */
    readonly limit: number;
    /**
     * @description The number of results to skip
     */
    readonly offset?: number;
    /**
     * @description The cursor to use for getting the next page
     */
    readonly cursor?: string;
    /**
     * @description The addresses of the owners to get tokens for
     */
    readonly ownerAddresses: AptosAddressInput[] | AptosAddress[];
    /**
     * @description The collection data id hashes of the collections to whitelist
     */
    readonly collectionBlacklist?: string[];
    /**
     * @description The collection data id hashes of the collections to whitelist
     */
    readonly collectionWhitelist?: string[];
    /**
     * @description The network of query. Defaults to mainnet.
     */
    readonly network?: AptosNetworkInput | AptosNetwork;
}
interface GetNFTByOwnersOperationRequestJSON {
    readonly limit: number;
    readonly offset?: number;
    readonly cursor?: string;
    readonly owner_addresses: AptosAddressJSON[];
    readonly collection_blacklist?: string[];
    readonly collection_whitelist?: string[];
    readonly network?: AptosNetworkJSON;
}
declare const GetNFTByOwnersOperation: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosNFTsByOwnersResponseJSON): AptosNFTsByOwnersResponse;
    serializeRequest(request: GetNFTByOwnersOperationRequest): GetNFTByOwnersOperationRequestJSON;
};

interface GetWalletsNFTTransfersOperationRequest {
    /**
     * @description The number of tokens to return
     */
    readonly limit: number;
    /**
     * @description The number of results to skip
     */
    readonly offset?: number;
    /**
     * @description The cursor to use for getting the next page
     */
    readonly cursor?: string;
    /**
     * @description The addresses of the wallets to get transfers for
     */
    readonly walletAddresses: AptosAddressInput[] | AptosAddress[];
    /**
     * @description The ids of the collections to whitelist
     */
    readonly collectionBlacklist?: string[];
    /**
     * @description The ids of the collections to whitelist
     */
    readonly collectionWhitelist?: string[];
    /**
     * @description The network of query. Defaults to mainnet.
     */
    readonly network?: AptosNetworkInput | AptosNetwork;
}
interface GetWalletsNFTTransfersOperationRequestJSON {
    readonly limit: number;
    readonly offset?: number;
    readonly cursor?: string;
    readonly wallet_addresses: AptosAddressJSON[];
    readonly collection_blacklist?: string[];
    readonly collection_whitelist?: string[];
    readonly network?: AptosNetworkJSON;
}
declare const GetWalletsNFTTransfersOperation: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosNFTTransfersByWalletsResponseJSON): AptosNFTTransfersByWalletsResponse;
    serializeRequest(request: GetWalletsNFTTransfersOperationRequest): GetWalletsNFTTransfersOperationRequestJSON;
};

interface AptosGetAccountResponseJSON {
    readonly sequence_number: string;
    readonly authentication_key: string;
}
interface AptosGetAccountResponseInput {
    readonly sequenceNumber: string;
    readonly authenticationKey: string;
}
declare class AptosGetAccountResponse {
    static create(input: AptosGetAccountResponseInput | AptosGetAccountResponse): AptosGetAccountResponse;
    static fromJSON(json: AptosGetAccountResponseJSON): AptosGetAccountResponse;
    /**
     * @description A string containing a 64-bit unsigned integer.
     * We represent u64 values as a string to ensure compatibility with languages such as JavaScript that do not parse u64s in JSON natively.
     */
    readonly sequenceNumber: string;
    /**
     * @description All bytes (Vec) data is represented as hex-encoded string prefixed with 0x and fulfilled with two hex digits per byte.
     * Unlike the Address type, HexEncodedBytes will not trim any zeros.
     */
    readonly authenticationKey: string;
    private constructor();
    toJSON(): AptosGetAccountResponseJSON;
}

interface GetAccountOperationRequest {
    /**
     * @description Address of account with or without a 0x prefix
     */
    readonly address: string;
    /**
     * @description Ledger version to get state of account.
     * If not provided, it will be the latest version
     */
    readonly ledgerVersion?: string;
    /**
     * @description The network of query. Defaults to mainnet.
     */
    readonly network?: AptosNetworkInput | AptosNetwork;
}
interface GetAccountOperationRequestJSON {
    readonly address: string;
    readonly ledger_version?: string;
    readonly network?: AptosNetworkJSON;
}
declare const GetAccountOperation: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosGetAccountResponseJSON): AptosGetAccountResponse;
    serializeRequest(request: GetAccountOperationRequest): GetAccountOperationRequestJSON;
};

type AptosGetAccountResourceResponseDataJSON = object;
type AptosGetAccountResourceResponseDataInput = object;
type AptosGetAccountResourceResponseDataValue = object;
declare abstract class AptosGetAccountResourceResponseData {
    static create(input: AptosGetAccountResourceResponseDataInput | AptosGetAccountResourceResponseDataValue): AptosGetAccountResourceResponseDataValue;
    static fromJSON(json: AptosGetAccountResourceResponseDataJSON): AptosGetAccountResourceResponseDataValue;
}

interface AptosGetAccountResourceResponseJSON {
    readonly type: string;
    readonly data: AptosGetAccountResourceResponseDataJSON;
}
interface AptosGetAccountResourceResponseInput {
    readonly type: string;
    readonly data: AptosGetAccountResourceResponseDataInput | AptosGetAccountResourceResponseDataValue;
}
declare class AptosGetAccountResourceResponse {
    static create(input: AptosGetAccountResourceResponseInput | AptosGetAccountResourceResponse): AptosGetAccountResourceResponse;
    static fromJSON(json: AptosGetAccountResourceResponseJSON): AptosGetAccountResourceResponse;
    /**
     * @description String representation of a MoveStructTag (on-chain Move struct type). This exists so you can specify MoveStructTags as path / query parameters
     */
    readonly type: string;
    /**
     * @description This is a JSON representation of some data within an account resource. More specifically, it is a map of strings to arbitrary JSON values / objects, where the keys are top level fields within the given resource.
     */
    readonly data: AptosGetAccountResourceResponseDataValue;
    private constructor();
    toJSON(): AptosGetAccountResourceResponseJSON;
}

interface GetAccountResourcesOperationRequest {
    /**
     * @description Address of account with or without a 0x prefix
     */
    readonly address: string;
    /**
     * @description Ledger version to get state of account.
     * If not provided, it will be the latest version
     */
    readonly ledgerVersion?: string;
    /**
     * @description Max number of account resources to retrieve.
     * If not provided, defaults to default page size.
     */
    readonly limit?: number;
    /**
     * @description Cursor specifying where to start for pagination
     * This cursor cannot be derived manually client-side. Instead, you must call this endpoint once without this query parameter specified, and then use the cursor returned in the X-Aptos-Cursor header in the response.
     */
    readonly start?: string;
    /**
     * @description The network of query. Defaults to mainnet.
     */
    readonly network?: AptosNetworkInput | AptosNetwork;
}
interface GetAccountResourcesOperationRequestJSON {
    readonly address: string;
    readonly ledger_version?: string;
    readonly limit?: number;
    readonly start?: string;
    readonly network?: AptosNetworkJSON;
}
declare const GetAccountResourcesOperation: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosGetAccountResourceResponseJSON[]): AptosGetAccountResourceResponse[];
    serializeRequest(request: GetAccountResourcesOperationRequest): GetAccountResourcesOperationRequestJSON;
};

interface AptosGenericTypeParamJSON {
    readonly constraints: string[];
}
interface AptosGenericTypeParamInput {
    readonly constraints: string[];
}
declare class AptosGenericTypeParam {
    static create(input: AptosGenericTypeParamInput | AptosGenericTypeParam): AptosGenericTypeParam;
    static fromJSON(json: AptosGenericTypeParamJSON): AptosGenericTypeParam;
    /**
     * @description Move abilities tied to the generic type param and associated with the function that uses it
     */
    readonly constraints: string[];
    private constructor();
    toJSON(): AptosGenericTypeParamJSON;
}

interface AptosModuleExposedFunctionJSON {
    readonly name: string;
    readonly visibility: string;
    readonly is_entry: boolean;
    readonly generic_type_params: AptosGenericTypeParamJSON[];
    readonly params: string[];
    readonly return: string[];
}
interface AptosModuleExposedFunctionInput {
    readonly name: string;
    readonly visibility: string;
    readonly isEntry: boolean;
    readonly genericTypeParams: AptosGenericTypeParamInput[] | AptosGenericTypeParam[];
    readonly params: string[];
    readonly return: string[];
}
declare class AptosModuleExposedFunction {
    static create(input: AptosModuleExposedFunctionInput | AptosModuleExposedFunction): AptosModuleExposedFunction;
    static fromJSON(json: AptosModuleExposedFunctionJSON): AptosModuleExposedFunction;
    /**
     * @description Name of the function
     */
    readonly name: string;
    /**
     * @description Move function visibility
     */
    readonly visibility: string;
    /**
     * @description Whether the function can be called as an entry function directly in a transaction
     */
    readonly isEntry: boolean;
    /**
     * @description Generic type params associated with the Move function
     */
    readonly genericTypeParams: AptosGenericTypeParam[];
    /**
     * @description Parameters associated with the move function
     */
    readonly params: string[];
    /**
     * @description Return type of the function
     */
    readonly return: string[];
    private constructor();
    toJSON(): AptosModuleExposedFunctionJSON;
}

interface AptosModuleStructFieldJSON {
    readonly name: string;
    readonly type: string;
}
interface AptosModuleStructFieldInput {
    readonly name: string;
    readonly type: string;
}
declare class AptosModuleStructField {
    static create(input: AptosModuleStructFieldInput | AptosModuleStructField): AptosModuleStructField;
    static fromJSON(json: AptosModuleStructFieldJSON): AptosModuleStructField;
    /**
     * @description Name of the field
     */
    readonly name: string;
    /**
     * @description String representation of an on-chain Move type tag that is exposed in transaction payload.
     */
    readonly type: string;
    private constructor();
    toJSON(): AptosModuleStructFieldJSON;
}

interface AptosModuleStructJSON {
    readonly name: string;
    readonly is_native: boolean;
    readonly abilities: string[];
    readonly generic_type_params: AptosGenericTypeParamJSON[];
    readonly fields: AptosModuleStructFieldJSON[];
}
interface AptosModuleStructInput {
    readonly name: string;
    readonly isNative: boolean;
    readonly abilities: string[];
    readonly genericTypeParams: AptosGenericTypeParamInput[] | AptosGenericTypeParam[];
    readonly fields: AptosModuleStructFieldInput[] | AptosModuleStructField[];
}
declare class AptosModuleStruct {
    static create(input: AptosModuleStructInput | AptosModuleStruct): AptosModuleStruct;
    static fromJSON(json: AptosModuleStructJSON): AptosModuleStruct;
    /**
     * @description Name of the struct
     */
    readonly name: string;
    /**
     * @description Whether the struct is a native struct of Move
     */
    readonly isNative: boolean;
    /**
     * @description Abilities associated with the struct
     */
    readonly abilities: string[];
    /**
     * @description Generic types associated with the struct
     */
    readonly genericTypeParams: AptosGenericTypeParam[];
    /**
     * @description Fields associated with the struct
     */
    readonly fields: AptosModuleStructField[];
    private constructor();
    toJSON(): AptosModuleStructJSON;
}

interface AptosMoveModuleAbiJSON {
    readonly address: AptosAddressJSON;
    readonly name: string;
    readonly friends: string[];
    readonly exposed_functions: AptosModuleExposedFunctionJSON[];
    readonly structs: AptosModuleStructJSON[];
}
interface AptosMoveModuleAbiInput {
    readonly address: AptosAddressInput | AptosAddress;
    readonly name: string;
    readonly friends: string[];
    readonly exposedFunctions: AptosModuleExposedFunctionInput[] | AptosModuleExposedFunction[];
    readonly structs: AptosModuleStructInput[] | AptosModuleStruct[];
}
declare class AptosMoveModuleAbi {
    static create(input: AptosMoveModuleAbiInput | AptosMoveModuleAbi): AptosMoveModuleAbi;
    static fromJSON(json: AptosMoveModuleAbiJSON): AptosMoveModuleAbi;
    /**
     * @description A hex encoded 32 byte Aptos account address.
     */
    readonly address: AptosAddress;
    readonly name: string;
    /**
     * @description Friends of the module
     */
    readonly friends: string[];
    /**
     * @description Public functions of the module
     */
    readonly exposedFunctions: AptosModuleExposedFunction[];
    /**
     * @description Structs of the module
     */
    readonly structs: AptosModuleStruct[];
    private constructor();
    toJSON(): AptosMoveModuleAbiJSON;
}

interface AptosGetAccountModuleResponseJSON {
    readonly bytecode: string;
    readonly abi: AptosMoveModuleAbiJSON;
}
interface AptosGetAccountModuleResponseInput {
    readonly bytecode: string;
    readonly abi: AptosMoveModuleAbiInput | AptosMoveModuleAbi;
}
declare class AptosGetAccountModuleResponse {
    static create(input: AptosGetAccountModuleResponseInput | AptosGetAccountModuleResponse): AptosGetAccountModuleResponse;
    static fromJSON(json: AptosGetAccountModuleResponseJSON): AptosGetAccountModuleResponse;
    /**
     * @description 0x88fbd33f54e1126269769780feb24480428179f552e2313fbe571b72e62a1ca1
     */
    readonly bytecode: string;
    /**
     * @description A Move module
     */
    readonly abi: AptosMoveModuleAbi;
    private constructor();
    toJSON(): AptosGetAccountModuleResponseJSON;
}

interface GetAccountModulesOperationRequest {
    /**
     * @description Address of account with or without a 0x prefix
     */
    readonly address: string;
    /**
     * @description Ledger version to get state of account.
     * If not provided, it will be the latest version
     */
    readonly ledgerVersion?: string;
    /**
     * @description Max number of account resources to retrieve.
     * If not provided, defaults to default page size.
     */
    readonly limit?: number;
    /**
     * @description Cursor specifying where to start for pagination
     * This cursor cannot be derived manually client-side. Instead, you must call this endpoint once without this query parameter specified, and then use the cursor returned in the X-Aptos-Cursor header in the response.
     */
    readonly start?: string;
    /**
     * @description The network of query. Defaults to mainnet.
     */
    readonly network?: AptosNetworkInput | AptosNetwork;
}
interface GetAccountModulesOperationRequestJSON {
    readonly address: string;
    readonly ledger_version?: string;
    readonly limit?: number;
    readonly start?: string;
    readonly network?: AptosNetworkJSON;
}
declare const GetAccountModulesOperation: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosGetAccountModuleResponseJSON[]): AptosGetAccountModuleResponse[];
    serializeRequest(request: GetAccountModulesOperationRequest): GetAccountModulesOperationRequestJSON;
};

interface GetAccountResourceOperationRequest {
    /**
     * @description Address of account with or without a 0x prefix
     */
    readonly address: string;
    /**
     * @description Name of struct to retrieve e.g. 0x1::account::Account
     */
    readonly resourceType: string;
    /**
     * @description Ledger version to get state of account.
     * If not provided, it will be the latest version
     */
    readonly ledgerVersion?: string;
    /**
     * @description The network of query. Defaults to mainnet.
     */
    readonly network?: AptosNetworkInput | AptosNetwork;
}
interface GetAccountResourceOperationRequestJSON {
    readonly address: string;
    readonly resource_type: string;
    readonly ledger_version?: string;
    readonly network?: AptosNetworkJSON;
}
declare const GetAccountResourceOperation: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosGetAccountResourceResponseJSON): AptosGetAccountResourceResponse;
    serializeRequest(request: GetAccountResourceOperationRequest): GetAccountResourceOperationRequestJSON;
};

interface GetAccountModuleOperationRequest {
    /**
     * @description Address of account with or without a 0x prefix
     */
    readonly address: string;
    /**
     * @description Name of module to retrieve
     */
    readonly moduleName: string;
    /**
     * @description Ledger version to get state of account.
     * If not provided, it will be the latest version
     */
    readonly ledgerVersion?: string;
    /**
     * @description The network of query. Defaults to mainnet.
     */
    readonly network?: AptosNetworkInput | AptosNetwork;
}
interface GetAccountModuleOperationRequestJSON {
    readonly address: string;
    readonly module_name: string;
    readonly ledger_version?: string;
    readonly network?: AptosNetworkJSON;
}
declare const GetAccountModuleOperation: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosGetAccountModuleResponseJSON): AptosGetAccountModuleResponse;
    serializeRequest(request: GetAccountModuleOperationRequest): GetAccountModuleOperationRequestJSON;
};

interface AptosTransactionEventGuidJSON {
    readonly creation_number: string;
    readonly account_address: AptosAddressJSON;
}
interface AptosTransactionEventGuidInput {
    readonly creationNumber: string;
    readonly accountAddress: AptosAddressInput | AptosAddress;
}
declare class AptosTransactionEventGuid {
    static create(input: AptosTransactionEventGuidInput | AptosTransactionEventGuid): AptosTransactionEventGuid;
    static fromJSON(json: AptosTransactionEventGuidJSON): AptosTransactionEventGuid;
    /**
     * @description A string containing a 64-bit unsigned integer.
     * We represent u64 values as a string to ensure compatibility with languages such as JavaScript that do not parse u64s in JSON natively.
     */
    readonly creationNumber: string;
    /**
     * @description A hex encoded 32 byte Aptos account address.
     * This is represented in a string as a 64 character hex string, sometimes shortened by stripping leading 0s, and adding a 0x.
     */
    readonly accountAddress: AptosAddress;
    private constructor();
    toJSON(): AptosTransactionEventGuidJSON;
}

type AptosGetEventsByCreationNumberResponseDataJSON = object;
type AptosGetEventsByCreationNumberResponseDataInput = object;
type AptosGetEventsByCreationNumberResponseDataValue = object;
declare abstract class AptosGetEventsByCreationNumberResponseData {
    static create(input: AptosGetEventsByCreationNumberResponseDataInput | AptosGetEventsByCreationNumberResponseDataValue): AptosGetEventsByCreationNumberResponseDataValue;
    static fromJSON(json: AptosGetEventsByCreationNumberResponseDataJSON): AptosGetEventsByCreationNumberResponseDataValue;
}

interface AptosGetEventsByCreationNumberResponseJSON {
    readonly version: string;
    readonly guid: AptosTransactionEventGuidJSON;
    readonly sequence_number: string;
    readonly type: string;
    readonly data: AptosGetEventsByCreationNumberResponseDataJSON;
}
interface AptosGetEventsByCreationNumberResponseInput {
    readonly version: string;
    readonly guid: AptosTransactionEventGuidInput | AptosTransactionEventGuid;
    readonly sequenceNumber: string;
    readonly type: string;
    readonly data: AptosGetEventsByCreationNumberResponseDataInput | AptosGetEventsByCreationNumberResponseDataValue;
}
declare class AptosGetEventsByCreationNumberResponse {
    static create(input: AptosGetEventsByCreationNumberResponseInput | AptosGetEventsByCreationNumberResponse): AptosGetEventsByCreationNumberResponse;
    static fromJSON(json: AptosGetEventsByCreationNumberResponseJSON): AptosGetEventsByCreationNumberResponse;
    /**
     * @description A string containing a 64-bit unsigned integer.
     * We represent u64 values as a string to ensure compatibility with languages such as JavaScript that do not parse u64s in JSON natively.
     */
    readonly version: string;
    readonly guid: AptosTransactionEventGuid;
    /**
     * @description A string containing a 64-bit unsigned integer.
     * We represent u64 values as a string to ensure compatibility with languages such as JavaScript that do not parse u64s in JSON natively.
     */
    readonly sequenceNumber: string;
    /**
     * @description String representation of an on-chain Move type tag that is exposed in transaction payload.
     */
    readonly type: string;
    /**
     * @description The JSON representation of the event
     */
    readonly data: AptosGetEventsByCreationNumberResponseDataValue;
    private constructor();
    toJSON(): AptosGetEventsByCreationNumberResponseJSON;
}

interface GetEventsByCreationNumberOperationRequest {
    /**
     * @description Address of account with or without a 0x prefix
     */
    readonly address: string;
    /**
     * @description Creation number corresponding to the event stream originating from the given account.
     */
    readonly creationNumber: string;
    /**
     * @description Max number of account resources to retrieve.
     * If not provided, defaults to default page size.
     */
    readonly limit?: number;
    /**
     * @description Starting sequence number of events.
     * If unspecified, by default will retrieve the most recent events
     */
    readonly start?: string;
    /**
     * @description The network of query. Defaults to mainnet.
     */
    readonly network?: AptosNetworkInput | AptosNetwork;
}
interface GetEventsByCreationNumberOperationRequestJSON {
    readonly address: string;
    readonly creation_number: string;
    readonly limit?: number;
    readonly start?: string;
    readonly network?: AptosNetworkJSON;
}
declare const GetEventsByCreationNumberOperation: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosGetEventsByCreationNumberResponseJSON[]): AptosGetEventsByCreationNumberResponse[];
    serializeRequest(request: GetEventsByCreationNumberOperationRequest): GetEventsByCreationNumberOperationRequestJSON;
};

type AptosGetEventsByEventHandleResponseDataJSON = object;
type AptosGetEventsByEventHandleResponseDataInput = object;
type AptosGetEventsByEventHandleResponseDataValue = object;
declare abstract class AptosGetEventsByEventHandleResponseData {
    static create(input: AptosGetEventsByEventHandleResponseDataInput | AptosGetEventsByEventHandleResponseDataValue): AptosGetEventsByEventHandleResponseDataValue;
    static fromJSON(json: AptosGetEventsByEventHandleResponseDataJSON): AptosGetEventsByEventHandleResponseDataValue;
}

interface AptosGetEventsByEventHandleResponseJSON {
    readonly version: string;
    readonly guid: AptosTransactionEventGuidJSON;
    readonly sequence_number: string;
    readonly type: string;
    readonly data: AptosGetEventsByEventHandleResponseDataJSON;
}
interface AptosGetEventsByEventHandleResponseInput {
    readonly version: string;
    readonly guid: AptosTransactionEventGuidInput | AptosTransactionEventGuid;
    readonly sequenceNumber: string;
    readonly type: string;
    readonly data: AptosGetEventsByEventHandleResponseDataInput | AptosGetEventsByEventHandleResponseDataValue;
}
declare class AptosGetEventsByEventHandleResponse {
    static create(input: AptosGetEventsByEventHandleResponseInput | AptosGetEventsByEventHandleResponse): AptosGetEventsByEventHandleResponse;
    static fromJSON(json: AptosGetEventsByEventHandleResponseJSON): AptosGetEventsByEventHandleResponse;
    /**
     * @description A string containing a 64-bit unsigned integer.
     * We represent u64 values as a string to ensure compatibility with languages such as JavaScript that do not parse u64s in JSON natively.
     */
    readonly version: string;
    readonly guid: AptosTransactionEventGuid;
    /**
     * @description A string containing a 64-bit unsigned integer.
     * We represent u64 values as a string to ensure compatibility with languages such as JavaScript that do not parse u64s in JSON natively.
     */
    readonly sequenceNumber: string;
    /**
     * @description String representation of an on-chain Move type tag that is exposed in transaction payload.
     */
    readonly type: string;
    /**
     * @description The JSON representation of the event
     */
    readonly data: AptosGetEventsByEventHandleResponseDataValue;
    private constructor();
    toJSON(): AptosGetEventsByEventHandleResponseJSON;
}

interface GetEventsByEventHandleOperationRequest {
    /**
     * @description Hex-encoded 32 byte Aptos account, with or without a 0x prefix, for which events are queried. This refers to the account that events were emitted to, not the account hosting the move module that emits that event type.
     */
    readonly address: string;
    /**
     * @description Name of struct to lookup event handle.
     */
    readonly eventHandle: string;
    /**
     * @description Name of field to lookup event handle.
     */
    readonly fieldName: string;
    /**
     * @description Max number of account resources to retrieve.
     * If not provided, defaults to default page size.
     */
    readonly limit?: number;
    /**
     * @description Starting sequence number of events.
     * If unspecified, by default will retrieve the most recent events
     */
    readonly start?: string;
    /**
     * @description The network of query. Defaults to mainnet.
     */
    readonly network?: AptosNetworkInput | AptosNetwork;
}
interface GetEventsByEventHandleOperationRequestJSON {
    readonly address: string;
    readonly event_handle: string;
    readonly field_name: string;
    readonly limit?: number;
    readonly start?: string;
    readonly network?: AptosNetworkJSON;
}
declare const GetEventsByEventHandleOperation: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosGetEventsByEventHandleResponseJSON[]): AptosGetEventsByEventHandleResponse[];
    serializeRequest(request: GetEventsByEventHandleOperationRequest): GetEventsByEventHandleOperationRequestJSON;
};

interface AptosEntryFunctionPayloadRequestJSON {
    readonly type: string;
    readonly function: string;
    readonly type_arguments: string[];
    readonly arguments: string[];
}
interface AptosEntryFunctionPayloadRequestInput {
    readonly type: string;
    readonly function: string;
    readonly typeArguments: string[];
    readonly arguments: string[];
}
declare class AptosEntryFunctionPayloadRequest {
    static create(input: AptosEntryFunctionPayloadRequestInput | AptosEntryFunctionPayloadRequest): AptosEntryFunctionPayloadRequest;
    static fromJSON(json: AptosEntryFunctionPayloadRequestJSON): AptosEntryFunctionPayloadRequest;
    static isInput(input: any): input is AptosEntryFunctionPayloadRequestInput;
    static isJSON(json: any): json is AptosEntryFunctionPayloadRequestJSON;
    readonly type: string;
    /**
     * @description Entry function id is string representation of a entry function defined on-chain.
     */
    readonly function: string;
    /**
     * @description Type arguments of the function
     */
    readonly typeArguments: string[];
    /**
     * @description Arguments of the function
     */
    readonly arguments: string[];
    private constructor();
    toJSON(): AptosEntryFunctionPayloadRequestJSON;
}

type AptosScriptPayloadRequestCodeJSON = object;
type AptosScriptPayloadRequestCodeInput = object;
type AptosScriptPayloadRequestCodeValue = object;
declare abstract class AptosScriptPayloadRequestCode {
    static create(input: AptosScriptPayloadRequestCodeInput | AptosScriptPayloadRequestCodeValue): AptosScriptPayloadRequestCodeValue;
    static fromJSON(json: AptosScriptPayloadRequestCodeJSON): AptosScriptPayloadRequestCodeValue;
}

interface AptosScriptPayloadRequestJSON {
    readonly type: string;
    readonly code: AptosScriptPayloadRequestCodeJSON;
    readonly type_arguments: string[];
    readonly arguments: string[];
}
interface AptosScriptPayloadRequestInput {
    readonly type: string;
    readonly code: AptosScriptPayloadRequestCodeInput | AptosScriptPayloadRequestCodeValue;
    readonly typeArguments: string[];
    readonly arguments: string[];
}
declare class AptosScriptPayloadRequest {
    static create(input: AptosScriptPayloadRequestInput | AptosScriptPayloadRequest): AptosScriptPayloadRequest;
    static fromJSON(json: AptosScriptPayloadRequestJSON): AptosScriptPayloadRequest;
    static isInput(input: any): input is AptosScriptPayloadRequestInput;
    static isJSON(json: any): json is AptosScriptPayloadRequestJSON;
    /**
     * @description Type of payload
     */
    readonly type: string;
    /**
     * @description Move script bytecode
     */
    readonly code: AptosScriptPayloadRequestCodeValue;
    /**
     * @description Type arguments of the function
     */
    readonly typeArguments: string[];
    /**
     * @description Arguments of the function
     */
    readonly arguments: string[];
    private constructor();
    toJSON(): AptosScriptPayloadRequestJSON;
}

interface AptosModuleBundlePayloadRequestJSON {
    readonly type: string;
    readonly modules: string[];
}
interface AptosModuleBundlePayloadRequestInput {
    readonly type: string;
    readonly modules: string[];
}
declare class AptosModuleBundlePayloadRequest {
    static create(input: AptosModuleBundlePayloadRequestInput | AptosModuleBundlePayloadRequest): AptosModuleBundlePayloadRequest;
    static fromJSON(json: AptosModuleBundlePayloadRequestJSON): AptosModuleBundlePayloadRequest;
    static isInput(input: any): input is AptosModuleBundlePayloadRequestInput;
    static isJSON(json: any): json is AptosModuleBundlePayloadRequestJSON;
    readonly type: string;
    readonly modules: string[];
    private constructor();
    toJSON(): AptosModuleBundlePayloadRequestJSON;
}

type AptosPendingTransactionPayloadJSON = AptosEntryFunctionPayloadRequestJSON | AptosScriptPayloadRequestJSON | AptosModuleBundlePayloadRequestJSON;
type AptosPendingTransactionPayloadInput = AptosEntryFunctionPayloadRequestInput | AptosScriptPayloadRequestInput | AptosModuleBundlePayloadRequestInput;
type AptosPendingTransactionPayloadValue = AptosEntryFunctionPayloadRequest | AptosScriptPayloadRequest | AptosModuleBundlePayloadRequest;
declare abstract class AptosPendingTransactionPayload {
    static create(input: AptosPendingTransactionPayloadInput): AptosPendingTransactionPayloadValue;
    static fromJSON(json: AptosPendingTransactionPayloadJSON): AptosPendingTransactionPayloadValue;
    static toJSON(value: AptosPendingTransactionPayloadValue): AptosPendingTransactionPayloadJSON;
}

interface AptosEd25519SignatureRequestJSON {
    readonly type: string;
    readonly signature: string;
    readonly public_key: string;
}
interface AptosEd25519SignatureRequestInput {
    readonly type: string;
    readonly signature: string;
    readonly publicKey: string;
}
declare class AptosEd25519SignatureRequest {
    static create(input: AptosEd25519SignatureRequestInput | AptosEd25519SignatureRequest): AptosEd25519SignatureRequest;
    static fromJSON(json: AptosEd25519SignatureRequestJSON): AptosEd25519SignatureRequest;
    static isInput(input: any): input is AptosEd25519SignatureRequestInput;
    static isJSON(json: any): json is AptosEd25519SignatureRequestJSON;
    readonly type: string;
    /**
     * @description All bytes (Vec) data is represented as hex-encoded string prefixed with 0x and fulfilled with two hex digits per byte
     */
    readonly signature: string;
    /**
     * @description All bytes (Vec) data is represented as hex-encoded string prefixed with 0x and fulfilled with two hex digits per byte.
     */
    readonly publicKey: string;
    private constructor();
    toJSON(): AptosEd25519SignatureRequestJSON;
}

interface AptosMultiEd25519SignatureRequestJSON {
    readonly type: string;
    readonly public_keys: string[];
    readonly signatures: string[];
    readonly threshold: number;
    readonly bitmap: string;
}
interface AptosMultiEd25519SignatureRequestInput {
    readonly type: string;
    readonly publicKeys: string[];
    readonly signatures: string[];
    readonly threshold: number;
    readonly bitmap: string;
}
declare class AptosMultiEd25519SignatureRequest {
    static create(input: AptosMultiEd25519SignatureRequestInput | AptosMultiEd25519SignatureRequest): AptosMultiEd25519SignatureRequest;
    static fromJSON(json: AptosMultiEd25519SignatureRequestJSON): AptosMultiEd25519SignatureRequest;
    static isInput(input: any): input is AptosMultiEd25519SignatureRequestInput;
    static isJSON(json: any): json is AptosMultiEd25519SignatureRequestJSON;
    readonly type: string;
    /**
     * @description The public keys for the Ed25519 signature
     */
    readonly publicKeys: string[];
    /**
     * @description Signature associated with the public keys in the same order
     */
    readonly signatures: string[];
    /**
     * @description The number of signatures required for a successful transaction
     */
    readonly threshold: number;
    /**
     * @description All bytes (Vec) data is represented as hex-encoded string prefixed with 0x and fulfilled with two hex digits per byte.
     */
    readonly bitmap: string;
    private constructor();
    toJSON(): AptosMultiEd25519SignatureRequestJSON;
}

type AptosMultiAgentSignatureRequestSecondarySignersJSON = AptosEd25519SignatureRequestJSON | AptosMultiEd25519SignatureRequestJSON;
type AptosMultiAgentSignatureRequestSecondarySignersInput = AptosEd25519SignatureRequestInput | AptosMultiEd25519SignatureRequestInput;
type AptosMultiAgentSignatureRequestSecondarySignersValue = AptosEd25519SignatureRequest | AptosMultiEd25519SignatureRequest;
declare abstract class AptosMultiAgentSignatureRequestSecondarySigners {
    static create(input: AptosMultiAgentSignatureRequestSecondarySignersInput): AptosMultiAgentSignatureRequestSecondarySignersValue;
    static fromJSON(json: AptosMultiAgentSignatureRequestSecondarySignersJSON): AptosMultiAgentSignatureRequestSecondarySignersValue;
    static toJSON(value: AptosMultiAgentSignatureRequestSecondarySignersValue): AptosMultiAgentSignatureRequestSecondarySignersJSON;
}

interface AptosMultiAgentSignatureRequestJSON {
    readonly type: string;
    readonly sender: AptosAddressJSON;
    readonly secondary_signer_addresses: string[];
    readonly secondary_signers: AptosMultiAgentSignatureRequestSecondarySignersJSON;
}
interface AptosMultiAgentSignatureRequestInput {
    readonly type: string;
    readonly sender: AptosAddressInput | AptosAddress;
    readonly secondarySignerAddresses: string[];
    readonly secondarySigners: AptosMultiAgentSignatureRequestSecondarySignersInput | AptosMultiAgentSignatureRequestSecondarySignersValue;
}
declare class AptosMultiAgentSignatureRequest {
    static create(input: AptosMultiAgentSignatureRequestInput | AptosMultiAgentSignatureRequest): AptosMultiAgentSignatureRequest;
    static fromJSON(json: AptosMultiAgentSignatureRequestJSON): AptosMultiAgentSignatureRequest;
    static isInput(input: any): input is AptosMultiAgentSignatureRequestInput;
    static isJSON(json: any): json is AptosMultiAgentSignatureRequestJSON;
    readonly type: string;
    readonly sender: AptosAddress;
    /**
     * @description The other involved parties addresses
     */
    readonly secondarySignerAddresses: string[];
    readonly secondarySigners: AptosMultiAgentSignatureRequestSecondarySignersValue;
    private constructor();
    toJSON(): AptosMultiAgentSignatureRequestJSON;
}

type AptosPendingTransactionSignatureJSON = AptosEd25519SignatureRequestJSON | AptosMultiEd25519SignatureRequestJSON | AptosMultiAgentSignatureRequestJSON;
type AptosPendingTransactionSignatureInput = AptosEd25519SignatureRequestInput | AptosMultiEd25519SignatureRequestInput | AptosMultiAgentSignatureRequestInput;
type AptosPendingTransactionSignatureValue = AptosEd25519SignatureRequest | AptosMultiEd25519SignatureRequest | AptosMultiAgentSignatureRequest;
declare abstract class AptosPendingTransactionSignature {
    static create(input: AptosPendingTransactionSignatureInput): AptosPendingTransactionSignatureValue;
    static fromJSON(json: AptosPendingTransactionSignatureJSON): AptosPendingTransactionSignatureValue;
    static toJSON(value: AptosPendingTransactionSignatureValue): AptosPendingTransactionSignatureJSON;
}

interface AptosPendingTransactionJSON {
    readonly hash: string;
    readonly sender: AptosAddressJSON;
    readonly sequence_number: string;
    readonly max_gas_amount: string;
    readonly gas_unit_price: string;
    readonly expiration_timestamp_secs: string;
    readonly payload: AptosPendingTransactionPayloadJSON;
    readonly signature: AptosPendingTransactionSignatureJSON;
}
interface AptosPendingTransactionInput {
    readonly hash: string;
    readonly sender: AptosAddressInput | AptosAddress;
    readonly sequenceNumber: string;
    readonly maxGasAmount: string;
    readonly gasUnitPrice: string;
    readonly expirationTimestampSecs: string;
    readonly payload: AptosPendingTransactionPayloadInput | AptosPendingTransactionPayloadValue;
    readonly signature: AptosPendingTransactionSignatureInput | AptosPendingTransactionSignatureValue;
}
declare class AptosPendingTransaction {
    static create(input: AptosPendingTransactionInput | AptosPendingTransaction): AptosPendingTransaction;
    static fromJSON(json: AptosPendingTransactionJSON): AptosPendingTransaction;
    static isInput(input: any): input is AptosPendingTransactionInput;
    static isJSON(json: any): json is AptosPendingTransactionJSON;
    readonly hash: string;
    /**
     * @description A hex encoded 32 byte Aptos account address.
     */
    readonly sender: AptosAddress;
    /**
     * @description A string containing a 64-bit unsigned integer.
     */
    readonly sequenceNumber: string;
    /**
     * @description A string containing a 64-bit unsigned integer.
     */
    readonly maxGasAmount: string;
    /**
     * @description A string containing a 64-bit unsigned integer.
     */
    readonly gasUnitPrice: string;
    /**
     * @description A string containing a 64-bit unsigned integer.
     */
    readonly expirationTimestampSecs: string;
    readonly payload: AptosPendingTransactionPayloadValue;
    readonly signature: AptosPendingTransactionSignatureValue;
    private constructor();
    toJSON(): AptosPendingTransactionJSON;
}

type AptosDeleteModuleChangeModuleJSON = object;
type AptosDeleteModuleChangeModuleInput = object;
type AptosDeleteModuleChangeModuleValue = object;
declare abstract class AptosDeleteModuleChangeModule {
    static create(input: AptosDeleteModuleChangeModuleInput | AptosDeleteModuleChangeModuleValue): AptosDeleteModuleChangeModuleValue;
    static fromJSON(json: AptosDeleteModuleChangeModuleJSON): AptosDeleteModuleChangeModuleValue;
}

interface AptosDeleteModuleChangeJSON {
    readonly type: string;
    readonly address: AptosAddressJSON;
    readonly state_key_hash: string;
    readonly module: AptosDeleteModuleChangeModuleJSON;
}
interface AptosDeleteModuleChangeInput {
    readonly type: string;
    readonly address: AptosAddressInput | AptosAddress;
    readonly stateKeyHash: string;
    readonly module: AptosDeleteModuleChangeModuleInput | AptosDeleteModuleChangeModuleValue;
}
declare class AptosDeleteModuleChange {
    static create(input: AptosDeleteModuleChangeInput | AptosDeleteModuleChange): AptosDeleteModuleChange;
    static fromJSON(json: AptosDeleteModuleChangeJSON): AptosDeleteModuleChange;
    static isInput(input: any): input is AptosDeleteModuleChangeInput;
    static isJSON(json: any): json is AptosDeleteModuleChangeJSON;
    readonly type: string;
    /**
     * @description A hex encoded 32 byte Aptos account address.
     */
    readonly address: AptosAddress;
    /**
     * @description State key hash
     */
    readonly stateKeyHash: string;
    /**
     * @description Move module id is a string representation of Move module
     */
    readonly module: AptosDeleteModuleChangeModuleValue;
    private constructor();
    toJSON(): AptosDeleteModuleChangeJSON;
}

type AptosDeleteResourceChangeResourceJSON = object;
type AptosDeleteResourceChangeResourceInput = object;
type AptosDeleteResourceChangeResourceValue = object;
declare abstract class AptosDeleteResourceChangeResource {
    static create(input: AptosDeleteResourceChangeResourceInput | AptosDeleteResourceChangeResourceValue): AptosDeleteResourceChangeResourceValue;
    static fromJSON(json: AptosDeleteResourceChangeResourceJSON): AptosDeleteResourceChangeResourceValue;
}

interface AptosDeleteResourceChangeJSON {
    readonly type: string;
    readonly address: AptosAddressJSON;
    readonly state_key_hash: string;
    readonly resource: AptosDeleteResourceChangeResourceJSON;
}
interface AptosDeleteResourceChangeInput {
    readonly type: string;
    readonly address: AptosAddressInput | AptosAddress;
    readonly stateKeyHash: string;
    readonly resource: AptosDeleteResourceChangeResourceInput | AptosDeleteResourceChangeResourceValue;
}
declare class AptosDeleteResourceChange {
    static create(input: AptosDeleteResourceChangeInput | AptosDeleteResourceChange): AptosDeleteResourceChange;
    static fromJSON(json: AptosDeleteResourceChangeJSON): AptosDeleteResourceChange;
    static isInput(input: any): input is AptosDeleteResourceChangeInput;
    static isJSON(json: any): json is AptosDeleteResourceChangeJSON;
    readonly type: string;
    /**
     * @description A hex encoded 32 byte Aptos account address.
     */
    readonly address: AptosAddress;
    /**
     * @description State key hash
     */
    readonly stateKeyHash: string;
    /**
     * @description String representation of a MoveStructTag (on-chain Move struct type).
     */
    readonly resource: AptosDeleteResourceChangeResourceValue;
    private constructor();
    toJSON(): AptosDeleteResourceChangeJSON;
}

type AptosDeleteTableItemChangeHandleJSON = object;
type AptosDeleteTableItemChangeHandleInput = object;
type AptosDeleteTableItemChangeHandleValue = object;
declare abstract class AptosDeleteTableItemChangeHandle {
    static create(input: AptosDeleteTableItemChangeHandleInput | AptosDeleteTableItemChangeHandleValue): AptosDeleteTableItemChangeHandleValue;
    static fromJSON(json: AptosDeleteTableItemChangeHandleJSON): AptosDeleteTableItemChangeHandleValue;
}

type AptosDeleteTableItemChangeKeyJSON = object;
type AptosDeleteTableItemChangeKeyInput = object;
type AptosDeleteTableItemChangeKeyValue = object;
declare abstract class AptosDeleteTableItemChangeKey {
    static create(input: AptosDeleteTableItemChangeKeyInput | AptosDeleteTableItemChangeKeyValue): AptosDeleteTableItemChangeKeyValue;
    static fromJSON(json: AptosDeleteTableItemChangeKeyJSON): AptosDeleteTableItemChangeKeyValue;
}

interface AptosDeletedTableDataJSON {
    readonly key: string;
    readonly key_type: string;
}
interface AptosDeletedTableDataInput {
    readonly key: string;
    readonly keyType: string;
}
declare class AptosDeletedTableData {
    static create(input: AptosDeletedTableDataInput | AptosDeletedTableData): AptosDeletedTableData;
    static fromJSON(json: AptosDeletedTableDataJSON): AptosDeletedTableData;
    /**
     * @description Deleted key
     */
    readonly key: string;
    /**
     * @description Deleted key type
     */
    readonly keyType: string;
    private constructor();
    toJSON(): AptosDeletedTableDataJSON;
}

interface AptosDeleteTableItemChangeJSON {
    readonly type: string;
    readonly state_key_hash: string;
    readonly handle: AptosDeleteTableItemChangeHandleJSON;
    readonly key: AptosDeleteTableItemChangeKeyJSON;
    readonly data: AptosDeletedTableDataJSON;
}
interface AptosDeleteTableItemChangeInput {
    readonly type: string;
    readonly stateKeyHash: string;
    readonly handle: AptosDeleteTableItemChangeHandleInput | AptosDeleteTableItemChangeHandleValue;
    readonly key: AptosDeleteTableItemChangeKeyInput | AptosDeleteTableItemChangeKeyValue;
    readonly data: AptosDeletedTableDataInput | AptosDeletedTableData;
}
declare class AptosDeleteTableItemChange {
    static create(input: AptosDeleteTableItemChangeInput | AptosDeleteTableItemChange): AptosDeleteTableItemChange;
    static fromJSON(json: AptosDeleteTableItemChangeJSON): AptosDeleteTableItemChange;
    static isInput(input: any): input is AptosDeleteTableItemChangeInput;
    static isJSON(json: any): json is AptosDeleteTableItemChangeJSON;
    readonly type: string;
    /**
     * @description State key hash
     */
    readonly stateKeyHash: string;
    /**
     * @description All bytes (Vec) data is represented as hex-encoded string prefixed with 0x and fulfilled with two hex digits per byte.
     */
    readonly handle: AptosDeleteTableItemChangeHandleValue;
    /**
     * @description All bytes (Vec) data is represented as hex-encoded string prefixed with 0x and fulfilled with two hex digits per byte.
     */
    readonly key: AptosDeleteTableItemChangeKeyValue;
    /**
     * @description Deleted table data
     */
    readonly data: AptosDeletedTableData;
    private constructor();
    toJSON(): AptosDeleteTableItemChangeJSON;
}

interface AptosWriteModuleDataJSON {
    readonly bytecode: string;
    readonly abi: AptosMoveModuleAbiJSON;
}
interface AptosWriteModuleDataInput {
    readonly bytecode: string;
    readonly abi: AptosMoveModuleAbiInput | AptosMoveModuleAbi;
}
declare class AptosWriteModuleData {
    static create(input: AptosWriteModuleDataInput | AptosWriteModuleData): AptosWriteModuleData;
    static fromJSON(json: AptosWriteModuleDataJSON): AptosWriteModuleData;
    /**
     * @description All bytes (Vec) data is represented as hex-encoded string prefixed with 0x and fulfilled with two hex digits per byte.
     */
    readonly bytecode: string;
    readonly abi: AptosMoveModuleAbi;
    private constructor();
    toJSON(): AptosWriteModuleDataJSON;
}

interface AptosWriteOrUpdateModuleChangeJSON {
    readonly type: string;
    readonly address: AptosAddressJSON;
    readonly state_key_hash: string;
    readonly data: AptosWriteModuleDataJSON;
}
interface AptosWriteOrUpdateModuleChangeInput {
    readonly type: string;
    readonly address: AptosAddressInput | AptosAddress;
    readonly stateKeyHash: string;
    readonly data: AptosWriteModuleDataInput | AptosWriteModuleData;
}
declare class AptosWriteOrUpdateModuleChange {
    static create(input: AptosWriteOrUpdateModuleChangeInput | AptosWriteOrUpdateModuleChange): AptosWriteOrUpdateModuleChange;
    static fromJSON(json: AptosWriteOrUpdateModuleChangeJSON): AptosWriteOrUpdateModuleChange;
    static isInput(input: any): input is AptosWriteOrUpdateModuleChangeInput;
    static isJSON(json: any): json is AptosWriteOrUpdateModuleChangeJSON;
    readonly type: string;
    /**
     * @description A hex encoded 32 byte Aptos account address.
     */
    readonly address: AptosAddress;
    /**
     * @description State key hash
     */
    readonly stateKeyHash: string;
    readonly data: AptosWriteModuleData;
    private constructor();
    toJSON(): AptosWriteOrUpdateModuleChangeJSON;
}

type AptosWriteResourceDataDataJSON = object;
type AptosWriteResourceDataDataInput = object;
type AptosWriteResourceDataDataValue = object;
declare abstract class AptosWriteResourceDataData {
    static create(input: AptosWriteResourceDataDataInput | AptosWriteResourceDataDataValue): AptosWriteResourceDataDataValue;
    static fromJSON(json: AptosWriteResourceDataDataJSON): AptosWriteResourceDataDataValue;
}

interface AptosWriteResourceDataJSON {
    readonly type: string;
    readonly data: AptosWriteResourceDataDataJSON;
}
interface AptosWriteResourceDataInput {
    readonly type: string;
    readonly data: AptosWriteResourceDataDataInput | AptosWriteResourceDataDataValue;
}
declare class AptosWriteResourceData {
    static create(input: AptosWriteResourceDataInput | AptosWriteResourceData): AptosWriteResourceData;
    static fromJSON(json: AptosWriteResourceDataJSON): AptosWriteResourceData;
    /**
     * @description String representation of a MoveStructTag (on-chain Move struct type).
     */
    readonly type: string;
    /**
     * @description This is a JSON representation of some data within an account resource. More specifically, it is a map of strings to arbitrary JSON values / objects, where the keys are top level fields within the given resource.
     */
    readonly data: AptosWriteResourceDataDataValue;
    private constructor();
    toJSON(): AptosWriteResourceDataJSON;
}

interface AptosWriteResourceChangeJSON {
    readonly type: string;
    readonly address: AptosAddressJSON;
    readonly state_key_hash: string;
    readonly data: AptosWriteResourceDataJSON;
}
interface AptosWriteResourceChangeInput {
    readonly type: string;
    readonly address: AptosAddressInput | AptosAddress;
    readonly stateKeyHash: string;
    readonly data: AptosWriteResourceDataInput | AptosWriteResourceData;
}
declare class AptosWriteResourceChange {
    static create(input: AptosWriteResourceChangeInput | AptosWriteResourceChange): AptosWriteResourceChange;
    static fromJSON(json: AptosWriteResourceChangeJSON): AptosWriteResourceChange;
    static isInput(input: any): input is AptosWriteResourceChangeInput;
    static isJSON(json: any): json is AptosWriteResourceChangeJSON;
    readonly type: string;
    /**
     * @description A hex encoded 32 byte Aptos account address.
     */
    readonly address: AptosAddress;
    /**
     * @description State key hash
     */
    readonly stateKeyHash: string;
    readonly data: AptosWriteResourceData;
    private constructor();
    toJSON(): AptosWriteResourceChangeJSON;
}

interface AptosDecodedTableDataJSON {
    readonly key: string;
    readonly key_type: string;
    readonly value: string;
    readonly value_type: string;
}
interface AptosDecodedTableDataInput {
    readonly key: string;
    readonly keyType: string;
    readonly value: string;
    readonly valueType: string;
}
declare class AptosDecodedTableData {
    static create(input: AptosDecodedTableDataInput | AptosDecodedTableData): AptosDecodedTableData;
    static fromJSON(json: AptosDecodedTableDataJSON): AptosDecodedTableData;
    /**
     * @description Key of table in JSON
     */
    readonly key: string;
    /**
     * @description Type of key
     */
    readonly keyType: string;
    /**
     * @description Value of table in JSON
     */
    readonly value: string;
    /**
     * @description Type of value
     */
    readonly valueType: string;
    private constructor();
    toJSON(): AptosDecodedTableDataJSON;
}

interface AptosWriteTableChangeSetChangeJSON {
    readonly type: string;
    readonly state_key_hash: string;
    readonly handle: string;
    readonly key: string;
    readonly value: string;
    readonly data: AptosDecodedTableDataJSON;
}
interface AptosWriteTableChangeSetChangeInput {
    readonly type: string;
    readonly stateKeyHash: string;
    readonly handle: string;
    readonly key: string;
    readonly value: string;
    readonly data: AptosDecodedTableDataInput | AptosDecodedTableData;
}
declare class AptosWriteTableChangeSetChange {
    static create(input: AptosWriteTableChangeSetChangeInput | AptosWriteTableChangeSetChange): AptosWriteTableChangeSetChange;
    static fromJSON(json: AptosWriteTableChangeSetChangeJSON): AptosWriteTableChangeSetChange;
    static isInput(input: any): input is AptosWriteTableChangeSetChangeInput;
    static isJSON(json: any): json is AptosWriteTableChangeSetChangeJSON;
    readonly type: string;
    /**
     * @description State key hash
     */
    readonly stateKeyHash: string;
    /**
     * @description All bytes (Vec) data is represented as hex-encoded string prefixed with 0x and fulfilled with two hex digits per byte.
     */
    readonly handle: string;
    /**
     * @description All bytes (Vec) data is represented as hex-encoded string prefixed with 0x and fulfilled with two hex digits per byte.
     */
    readonly key: string;
    /**
     * @description All bytes (Vec) data is represented as hex-encoded string prefixed with 0x and fulfilled with two hex digits per byte.
     */
    readonly value: string;
    readonly data: AptosDecodedTableData;
    private constructor();
    toJSON(): AptosWriteTableChangeSetChangeJSON;
}

type AptosUserTransactionChangesItemJSON = AptosDeleteModuleChangeJSON | AptosDeleteResourceChangeJSON | AptosDeleteTableItemChangeJSON | AptosWriteOrUpdateModuleChangeJSON | AptosWriteResourceChangeJSON | AptosWriteTableChangeSetChangeJSON;
type AptosUserTransactionChangesItemInput = AptosDeleteModuleChangeInput | AptosDeleteResourceChangeInput | AptosDeleteTableItemChangeInput | AptosWriteOrUpdateModuleChangeInput | AptosWriteResourceChangeInput | AptosWriteTableChangeSetChangeInput;
type AptosUserTransactionChangesItemValue = AptosDeleteModuleChange | AptosDeleteResourceChange | AptosDeleteTableItemChange | AptosWriteOrUpdateModuleChange | AptosWriteResourceChange | AptosWriteTableChangeSetChange;
declare abstract class AptosUserTransactionChangesItem {
    static create(input: AptosUserTransactionChangesItemInput): AptosUserTransactionChangesItemValue;
    static fromJSON(json: AptosUserTransactionChangesItemJSON): AptosUserTransactionChangesItemValue;
    static toJSON(value: AptosUserTransactionChangesItemValue): AptosUserTransactionChangesItemJSON;
}

type AptosUserTransactionPayloadJSON = AptosEntryFunctionPayloadRequestJSON | AptosScriptPayloadRequestJSON | AptosModuleBundlePayloadRequestJSON;
type AptosUserTransactionPayloadInput = AptosEntryFunctionPayloadRequestInput | AptosScriptPayloadRequestInput | AptosModuleBundlePayloadRequestInput;
type AptosUserTransactionPayloadValue = AptosEntryFunctionPayloadRequest | AptosScriptPayloadRequest | AptosModuleBundlePayloadRequest;
declare abstract class AptosUserTransactionPayload {
    static create(input: AptosUserTransactionPayloadInput): AptosUserTransactionPayloadValue;
    static fromJSON(json: AptosUserTransactionPayloadJSON): AptosUserTransactionPayloadValue;
    static toJSON(value: AptosUserTransactionPayloadValue): AptosUserTransactionPayloadJSON;
}

type AptosUserTransactionSignatureJSON = AptosEd25519SignatureRequestJSON | AptosMultiEd25519SignatureRequestJSON | AptosMultiAgentSignatureRequestJSON;
type AptosUserTransactionSignatureInput = AptosEd25519SignatureRequestInput | AptosMultiEd25519SignatureRequestInput | AptosMultiAgentSignatureRequestInput;
type AptosUserTransactionSignatureValue = AptosEd25519SignatureRequest | AptosMultiEd25519SignatureRequest | AptosMultiAgentSignatureRequest;
declare abstract class AptosUserTransactionSignature {
    static create(input: AptosUserTransactionSignatureInput): AptosUserTransactionSignatureValue;
    static fromJSON(json: AptosUserTransactionSignatureJSON): AptosUserTransactionSignatureValue;
    static toJSON(value: AptosUserTransactionSignatureValue): AptosUserTransactionSignatureJSON;
}

type AptosTransactionEventDataJSON = object;
type AptosTransactionEventDataInput = object;
type AptosTransactionEventDataValue = object;
declare abstract class AptosTransactionEventData {
    static create(input: AptosTransactionEventDataInput | AptosTransactionEventDataValue): AptosTransactionEventDataValue;
    static fromJSON(json: AptosTransactionEventDataJSON): AptosTransactionEventDataValue;
}

interface AptosTransactionEventJSON {
    readonly guid: AptosTransactionEventGuidJSON;
    readonly sequence_number: string;
    readonly type: string;
    readonly data: AptosTransactionEventDataJSON;
}
interface AptosTransactionEventInput {
    readonly guid: AptosTransactionEventGuidInput | AptosTransactionEventGuid;
    readonly sequenceNumber: string;
    readonly type: string;
    readonly data: AptosTransactionEventDataInput | AptosTransactionEventDataValue;
}
declare class AptosTransactionEvent {
    static create(input: AptosTransactionEventInput | AptosTransactionEvent): AptosTransactionEvent;
    static fromJSON(json: AptosTransactionEventJSON): AptosTransactionEvent;
    readonly guid: AptosTransactionEventGuid;
    /**
     * @description A string containing a 64-bit unsigned integer.
     */
    readonly sequenceNumber: string;
    /**
     * @description String representation of an on-chain Move type tag that is exposed in transaction payload.
     */
    readonly type: string;
    /**
     * @description The JSON representation of the event
     */
    readonly data: AptosTransactionEventDataValue;
    private constructor();
    toJSON(): AptosTransactionEventJSON;
}

interface AptosUserTransactionJSON {
    readonly type: string;
    readonly version: string;
    readonly hash: string;
    readonly state_change_hash: string;
    readonly event_root_hash: string;
    readonly state_checkpoint_hash: string;
    readonly gas_used: string;
    readonly success: boolean;
    readonly vm_status: string;
    readonly accumulator_root_hash: string;
    readonly changes: AptosUserTransactionChangesItemJSON[];
    readonly sender: AptosAddressJSON;
    readonly sequence_number: string;
    readonly max_gas_amount: string;
    readonly gas_unit_price: string;
    readonly expiration_timestamp_secs: string;
    readonly payload: AptosUserTransactionPayloadJSON;
    readonly signature: AptosUserTransactionSignatureJSON;
    readonly events: AptosTransactionEventJSON[];
    readonly timestamp: string;
}
interface AptosUserTransactionInput {
    readonly type: string;
    readonly version: string;
    readonly hash: string;
    readonly stateChangeHash: string;
    readonly eventRootHash: string;
    readonly stateCheckpointHash: string;
    readonly gasUsed: string;
    readonly success: boolean;
    readonly vmStatus: string;
    readonly accumulatorRootHash: string;
    readonly changes: AptosUserTransactionChangesItemInput[] | AptosUserTransactionChangesItemValue[];
    readonly sender: AptosAddressInput | AptosAddress;
    readonly sequenceNumber: string;
    readonly maxGasAmount: string;
    readonly gasUnitPrice: string;
    readonly expirationTimestampSecs: string;
    readonly payload: AptosUserTransactionPayloadInput | AptosUserTransactionPayloadValue;
    readonly signature: AptosUserTransactionSignatureInput | AptosUserTransactionSignatureValue;
    readonly events: AptosTransactionEventInput[] | AptosTransactionEvent[];
    readonly timestamp: string;
}
declare class AptosUserTransaction {
    static create(input: AptosUserTransactionInput | AptosUserTransaction): AptosUserTransaction;
    static fromJSON(json: AptosUserTransactionJSON): AptosUserTransaction;
    static isInput(input: any): input is AptosUserTransactionInput;
    static isJSON(json: any): json is AptosUserTransactionJSON;
    /**
     * @description user_transaction
     */
    readonly type: string;
    /**
     * @description A string containing a 64-bit unsigned integer.
     */
    readonly version: string;
    readonly hash: string;
    readonly stateChangeHash: string;
    readonly eventRootHash: string;
    readonly stateCheckpointHash: string;
    /**
     * @description A string containing a 64-bit unsigned integer.
     */
    readonly gasUsed: string;
    /**
     * @description Whether the transaction was successful
     */
    readonly success: boolean;
    /**
     * @description The VM status of the transaction, can tell useful information in a failure
     */
    readonly vmStatus: string;
    readonly accumulatorRootHash: string;
    readonly changes: AptosUserTransactionChangesItemValue[];
    /**
     * @description A hex encoded 32 byte Aptos account address.
     */
    readonly sender: AptosAddress;
    /**
     * @description A string containing a 64-bit unsigned integer.
     */
    readonly sequenceNumber: string;
    /**
     * @description A string containing a 64-bit unsigned integer.
     */
    readonly maxGasAmount: string;
    /**
     * @description A string containing a 64-bit unsigned integer.
     */
    readonly gasUnitPrice: string;
    /**
     * @description A string containing a 64-bit unsigned integer.
     */
    readonly expirationTimestampSecs: string;
    readonly payload: AptosUserTransactionPayloadValue;
    readonly signature: AptosUserTransactionSignatureValue;
    /**
     * @description Events generated by the transaction
     */
    readonly events: AptosTransactionEvent[];
    /**
     * @description A string containing a 64-bit unsigned integer.
     */
    readonly timestamp: string;
    private constructor();
    toJSON(): AptosUserTransactionJSON;
}

type AptosGenesisTransactionChangesItemJSON = AptosDeleteModuleChangeJSON | AptosDeleteResourceChangeJSON | AptosDeleteTableItemChangeJSON | AptosWriteOrUpdateModuleChangeJSON | AptosWriteResourceChangeJSON | AptosWriteTableChangeSetChangeJSON;
type AptosGenesisTransactionChangesItemInput = AptosDeleteModuleChangeInput | AptosDeleteResourceChangeInput | AptosDeleteTableItemChangeInput | AptosWriteOrUpdateModuleChangeInput | AptosWriteResourceChangeInput | AptosWriteTableChangeSetChangeInput;
type AptosGenesisTransactionChangesItemValue = AptosDeleteModuleChange | AptosDeleteResourceChange | AptosDeleteTableItemChange | AptosWriteOrUpdateModuleChange | AptosWriteResourceChange | AptosWriteTableChangeSetChange;
declare abstract class AptosGenesisTransactionChangesItem {
    static create(input: AptosGenesisTransactionChangesItemInput): AptosGenesisTransactionChangesItemValue;
    static fromJSON(json: AptosGenesisTransactionChangesItemJSON): AptosGenesisTransactionChangesItemValue;
    static toJSON(value: AptosGenesisTransactionChangesItemValue): AptosGenesisTransactionChangesItemJSON;
}

interface AptosScriptWriteSetJSON {
    readonly type: string;
    readonly execute_as: string;
    readonly script: AptosScriptPayloadRequestJSON;
}
interface AptosScriptWriteSetInput {
    readonly type: string;
    readonly executeAs: string;
    readonly script: AptosScriptPayloadRequestInput | AptosScriptPayloadRequest;
}
declare class AptosScriptWriteSet {
    static create(input: AptosScriptWriteSetInput | AptosScriptWriteSet): AptosScriptWriteSet;
    static fromJSON(json: AptosScriptWriteSetJSON): AptosScriptWriteSet;
    static isInput(input: any): input is AptosScriptWriteSetInput;
    static isJSON(json: any): json is AptosScriptWriteSetJSON;
    readonly type: string;
    /**
     * @description A hex encoded 32 byte Aptos account address.
     */
    readonly executeAs: string;
    /**
     * @description Payload which runs a script that can run multiple functions
     */
    readonly script: AptosScriptPayloadRequest;
    private constructor();
    toJSON(): AptosScriptWriteSetJSON;
}

interface AptosDirectWriteSetJSON {
    readonly type: string;
    readonly changes: string[];
    readonly events: AptosTransactionEventJSON[];
}
interface AptosDirectWriteSetInput {
    readonly type: string;
    readonly changes: string[];
    readonly events: AptosTransactionEventInput[] | AptosTransactionEvent[];
}
declare class AptosDirectWriteSet {
    static create(input: AptosDirectWriteSetInput | AptosDirectWriteSet): AptosDirectWriteSet;
    static fromJSON(json: AptosDirectWriteSetJSON): AptosDirectWriteSet;
    static isInput(input: any): input is AptosDirectWriteSetInput;
    static isJSON(json: any): json is AptosDirectWriteSetJSON;
    readonly type: string;
    readonly changes: string[];
    /**
     * @description Events emitted during genesis
     */
    readonly events: AptosTransactionEvent[];
    private constructor();
    toJSON(): AptosDirectWriteSetJSON;
}

type AptosWriteSetPayloadWriteSetJSON = AptosScriptWriteSetJSON | AptosDirectWriteSetJSON;
type AptosWriteSetPayloadWriteSetInput = AptosScriptWriteSetInput | AptosDirectWriteSetInput;
type AptosWriteSetPayloadWriteSetValue = AptosScriptWriteSet | AptosDirectWriteSet;
declare abstract class AptosWriteSetPayloadWriteSet {
    static create(input: AptosWriteSetPayloadWriteSetInput): AptosWriteSetPayloadWriteSetValue;
    static fromJSON(json: AptosWriteSetPayloadWriteSetJSON): AptosWriteSetPayloadWriteSetValue;
    static toJSON(value: AptosWriteSetPayloadWriteSetValue): AptosWriteSetPayloadWriteSetJSON;
}

interface AptosWriteSetPayloadJSON {
    readonly type: string;
    readonly write_set: AptosWriteSetPayloadWriteSetJSON;
}
interface AptosWriteSetPayloadInput {
    readonly type: string;
    readonly writeSet: AptosWriteSetPayloadWriteSetInput | AptosWriteSetPayloadWriteSetValue;
}
declare class AptosWriteSetPayload {
    static create(input: AptosWriteSetPayloadInput | AptosWriteSetPayload): AptosWriteSetPayload;
    static fromJSON(json: AptosWriteSetPayloadJSON): AptosWriteSetPayload;
    readonly type: string;
    /**
     * @description The associated writeset with a payload
     */
    readonly writeSet: AptosWriteSetPayloadWriteSetValue;
    private constructor();
    toJSON(): AptosWriteSetPayloadJSON;
}

interface AptosGenesisTransactionJSON {
    readonly type: string;
    readonly version: string;
    readonly hash: string;
    readonly state_change_hash: string;
    readonly event_root_hash: string;
    readonly state_checkpoint_hash: string;
    readonly gas_used: string;
    readonly success: boolean;
    readonly vm_status: string;
    readonly accumulator_root_hash: string;
    readonly changes: AptosGenesisTransactionChangesItemJSON[];
    readonly payload: AptosWriteSetPayloadJSON;
    readonly events: AptosTransactionEventJSON[];
}
interface AptosGenesisTransactionInput {
    readonly type: string;
    readonly version: string;
    readonly hash: string;
    readonly stateChangeHash: string;
    readonly eventRootHash: string;
    readonly stateCheckpointHash: string;
    readonly gasUsed: string;
    readonly success: boolean;
    readonly vmStatus: string;
    readonly accumulatorRootHash: string;
    readonly changes: AptosGenesisTransactionChangesItemInput[] | AptosGenesisTransactionChangesItemValue[];
    readonly payload: AptosWriteSetPayloadInput | AptosWriteSetPayload;
    readonly events: AptosTransactionEventInput[] | AptosTransactionEvent[];
}
declare class AptosGenesisTransaction {
    static create(input: AptosGenesisTransactionInput | AptosGenesisTransaction): AptosGenesisTransaction;
    static fromJSON(json: AptosGenesisTransactionJSON): AptosGenesisTransaction;
    static isInput(input: any): input is AptosGenesisTransactionInput;
    static isJSON(json: any): json is AptosGenesisTransactionJSON;
    readonly type: string;
    /**
     * @description A string containing a 64-bit unsigned integer.
     */
    readonly version: string;
    readonly hash: string;
    readonly stateChangeHash: string;
    readonly eventRootHash: string;
    readonly stateCheckpointHash: string;
    /**
     * @description A string containing a 64-bit unsigned integer.
     */
    readonly gasUsed: string;
    /**
     * @description Whether the transaction was successful
     */
    readonly success: boolean;
    /**
     * @description The VM status of the transaction, can tell useful information in a failure
     */
    readonly vmStatus: string;
    readonly accumulatorRootHash: string;
    readonly changes: AptosGenesisTransactionChangesItemValue[];
    /**
     * @description A writeset payload, used only for genesis
     */
    readonly payload: AptosWriteSetPayload;
    /**
     * @description Events generated by the transaction
     */
    readonly events: AptosTransactionEvent[];
    private constructor();
    toJSON(): AptosGenesisTransactionJSON;
}

type AptosBlockMetadataTransactionChangesItemJSON = AptosDeleteModuleChangeJSON | AptosDeleteResourceChangeJSON | AptosDeleteTableItemChangeJSON | AptosWriteOrUpdateModuleChangeJSON | AptosWriteResourceChangeJSON | AptosWriteTableChangeSetChangeJSON;
type AptosBlockMetadataTransactionChangesItemInput = AptosDeleteModuleChangeInput | AptosDeleteResourceChangeInput | AptosDeleteTableItemChangeInput | AptosWriteOrUpdateModuleChangeInput | AptosWriteResourceChangeInput | AptosWriteTableChangeSetChangeInput;
type AptosBlockMetadataTransactionChangesItemValue = AptosDeleteModuleChange | AptosDeleteResourceChange | AptosDeleteTableItemChange | AptosWriteOrUpdateModuleChange | AptosWriteResourceChange | AptosWriteTableChangeSetChange;
declare abstract class AptosBlockMetadataTransactionChangesItem {
    static create(input: AptosBlockMetadataTransactionChangesItemInput): AptosBlockMetadataTransactionChangesItemValue;
    static fromJSON(json: AptosBlockMetadataTransactionChangesItemJSON): AptosBlockMetadataTransactionChangesItemValue;
    static toJSON(value: AptosBlockMetadataTransactionChangesItemValue): AptosBlockMetadataTransactionChangesItemJSON;
}

interface AptosBlockMetadataTransactionJSON {
    readonly type: string;
    readonly version: string;
    readonly hash: string;
    readonly state_change_hash: string;
    readonly event_root_hash: string;
    readonly state_checkpoint_hash: string;
    readonly gas_used: string;
    readonly success: boolean;
    readonly vm_status: string;
    readonly accumulator_root_hash: string;
    readonly changes: AptosBlockMetadataTransactionChangesItemJSON[];
    readonly id: string;
    readonly epoch: string;
    readonly round: string;
    readonly events: AptosTransactionEventJSON[];
    readonly previous_block_votes_bitvec: string[];
    readonly proposer: AptosAddressJSON;
    readonly failed_proposer_indices: string[];
    readonly timestamp: string;
}
interface AptosBlockMetadataTransactionInput {
    readonly type: string;
    readonly version: string;
    readonly hash: string;
    readonly stateChangeHash: string;
    readonly eventRootHash: string;
    readonly stateCheckpointHash: string;
    readonly gasUsed: string;
    readonly success: boolean;
    readonly vmStatus: string;
    readonly accumulatorRootHash: string;
    readonly changes: AptosBlockMetadataTransactionChangesItemInput[] | AptosBlockMetadataTransactionChangesItemValue[];
    readonly id: string;
    readonly epoch: string;
    readonly round: string;
    readonly events: AptosTransactionEventInput[] | AptosTransactionEvent[];
    readonly previousBlockVotesBitvec: string[];
    readonly proposer: AptosAddressInput | AptosAddress;
    readonly failedProposerIndices: string[];
    readonly timestamp: string;
}
declare class AptosBlockMetadataTransaction {
    static create(input: AptosBlockMetadataTransactionInput | AptosBlockMetadataTransaction): AptosBlockMetadataTransaction;
    static fromJSON(json: AptosBlockMetadataTransactionJSON): AptosBlockMetadataTransaction;
    static isInput(input: any): input is AptosBlockMetadataTransactionInput;
    static isJSON(json: any): json is AptosBlockMetadataTransactionJSON;
    readonly type: string;
    /**
     * @description A string containing a 64-bit unsigned integer.
     */
    readonly version: string;
    readonly hash: string;
    readonly stateChangeHash: string;
    readonly eventRootHash: string;
    readonly stateCheckpointHash: string;
    /**
     * @description A string containing a 64-bit unsigned integer.
     */
    readonly gasUsed: string;
    /**
     * @description Whether the transaction was successful
     */
    readonly success: boolean;
    /**
     * @description The VM status of the transaction, can tell useful information in a failure
     */
    readonly vmStatus: string;
    readonly accumulatorRootHash: string;
    readonly changes: AptosBlockMetadataTransactionChangesItemValue[];
    readonly id: string;
    /**
     * @description A string containing a 64-bit unsigned integer.
     */
    readonly epoch: string;
    /**
     * @description A string containing a 64-bit unsigned integer.
     */
    readonly round: string;
    /**
     * @description he events emitted at the block creation
     */
    readonly events: AptosTransactionEvent[];
    /**
     * @description Previous block votes
     */
    readonly previousBlockVotesBitvec: string[];
    /**
     * @description A hex encoded 32 byte Aptos account address.S
     */
    readonly proposer: AptosAddress;
    /**
     * @description The indices of the proposers who failed to propose
     */
    readonly failedProposerIndices: string[];
    /**
     * @description A string containing a 64-bit unsigned integer
     */
    readonly timestamp: string;
    private constructor();
    toJSON(): AptosBlockMetadataTransactionJSON;
}

type AptosStateCheckpointTransactionChangesItemJSON = AptosDeleteModuleChangeJSON | AptosDeleteResourceChangeJSON | AptosDeleteTableItemChangeJSON | AptosWriteOrUpdateModuleChangeJSON | AptosWriteResourceChangeJSON | AptosWriteTableChangeSetChangeJSON;
type AptosStateCheckpointTransactionChangesItemInput = AptosDeleteModuleChangeInput | AptosDeleteResourceChangeInput | AptosDeleteTableItemChangeInput | AptosWriteOrUpdateModuleChangeInput | AptosWriteResourceChangeInput | AptosWriteTableChangeSetChangeInput;
type AptosStateCheckpointTransactionChangesItemValue = AptosDeleteModuleChange | AptosDeleteResourceChange | AptosDeleteTableItemChange | AptosWriteOrUpdateModuleChange | AptosWriteResourceChange | AptosWriteTableChangeSetChange;
declare abstract class AptosStateCheckpointTransactionChangesItem {
    static create(input: AptosStateCheckpointTransactionChangesItemInput): AptosStateCheckpointTransactionChangesItemValue;
    static fromJSON(json: AptosStateCheckpointTransactionChangesItemJSON): AptosStateCheckpointTransactionChangesItemValue;
    static toJSON(value: AptosStateCheckpointTransactionChangesItemValue): AptosStateCheckpointTransactionChangesItemJSON;
}

interface AptosStateCheckpointTransactionJSON {
    readonly type: string;
    readonly version: string;
    readonly hash: string;
    readonly state_change_hash: string;
    readonly event_root_hash: string;
    readonly state_checkpoint_hash: string;
    readonly gas_used: string;
    readonly success: boolean;
    readonly vm_status: string;
    readonly accumulator_root_hash: string;
    readonly changes: AptosStateCheckpointTransactionChangesItemJSON[];
    readonly timestamp: string;
}
interface AptosStateCheckpointTransactionInput {
    readonly type: string;
    readonly version: string;
    readonly hash: string;
    readonly stateChangeHash: string;
    readonly eventRootHash: string;
    readonly stateCheckpointHash: string;
    readonly gasUsed: string;
    readonly success: boolean;
    readonly vmStatus: string;
    readonly accumulatorRootHash: string;
    readonly changes: AptosStateCheckpointTransactionChangesItemInput[] | AptosStateCheckpointTransactionChangesItemValue[];
    readonly timestamp: string;
}
declare class AptosStateCheckpointTransaction {
    static create(input: AptosStateCheckpointTransactionInput | AptosStateCheckpointTransaction): AptosStateCheckpointTransaction;
    static fromJSON(json: AptosStateCheckpointTransactionJSON): AptosStateCheckpointTransaction;
    static isInput(input: any): input is AptosStateCheckpointTransactionInput;
    static isJSON(json: any): json is AptosStateCheckpointTransactionJSON;
    readonly type: string;
    /**
     * @description A string containing a 64-bit unsigned integer.
     */
    readonly version: string;
    readonly hash: string;
    readonly stateChangeHash: string;
    readonly eventRootHash: string;
    readonly stateCheckpointHash: string;
    /**
     * @description A string containing a 64-bit unsigned integer.
     */
    readonly gasUsed: string;
    /**
     * @description Whether the transaction was successful
     */
    readonly success: boolean;
    /**
     * @description The VM status of the transaction, can tell useful information in a failure
     */
    readonly vmStatus: string;
    readonly accumulatorRootHash: string;
    readonly changes: AptosStateCheckpointTransactionChangesItemValue[];
    /**
     * @description A string containing a 64-bit unsigned integer.
     */
    readonly timestamp: string;
    private constructor();
    toJSON(): AptosStateCheckpointTransactionJSON;
}

type AptosGetTransactionsItemJSON = AptosPendingTransactionJSON | AptosUserTransactionJSON | AptosGenesisTransactionJSON | AptosBlockMetadataTransactionJSON | AptosStateCheckpointTransactionJSON;
type AptosGetTransactionsItemInput = AptosPendingTransactionInput | AptosUserTransactionInput | AptosGenesisTransactionInput | AptosBlockMetadataTransactionInput | AptosStateCheckpointTransactionInput;
type AptosGetTransactionsItemValue = AptosPendingTransaction | AptosUserTransaction | AptosGenesisTransaction | AptosBlockMetadataTransaction | AptosStateCheckpointTransaction;
declare abstract class AptosGetTransactionsItem {
    static create(input: AptosGetTransactionsItemInput): AptosGetTransactionsItemValue;
    static fromJSON(json: AptosGetTransactionsItemJSON): AptosGetTransactionsItemValue;
    static toJSON(value: AptosGetTransactionsItemValue): AptosGetTransactionsItemJSON;
}

interface GetTransactionsOperationRequest {
    /**
     * @description Max number of transactions to retrieve.
     * If not provided, defaults to default page size
     */
    readonly limit?: number;
    /**
     * @description Account sequence number to start list of transactions.
     * If not provided, defaults to showing the latest transactions
     */
    readonly start?: string;
    /**
     * @description The network of query. Defaults to mainnet.
     */
    readonly network?: AptosNetworkInput | AptosNetwork;
}
interface GetTransactionsOperationRequestJSON {
    readonly limit?: number;
    readonly start?: string;
    readonly network?: AptosNetworkJSON;
}
declare const GetTransactionsOperation: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosGetTransactionsItemJSON[]): AptosGetTransactionsItemValue[];
    serializeRequest(request: GetTransactionsOperationRequest): GetTransactionsOperationRequestJSON;
};

type AptosSubmitTransactionRequestPayloadJSON = AptosEntryFunctionPayloadRequestJSON | AptosScriptPayloadRequestJSON | AptosModuleBundlePayloadRequestJSON;
type AptosSubmitTransactionRequestPayloadInput = AptosEntryFunctionPayloadRequestInput | AptosScriptPayloadRequestInput | AptosModuleBundlePayloadRequestInput;
type AptosSubmitTransactionRequestPayloadValue = AptosEntryFunctionPayloadRequest | AptosScriptPayloadRequest | AptosModuleBundlePayloadRequest;
declare abstract class AptosSubmitTransactionRequestPayload {
    static create(input: AptosSubmitTransactionRequestPayloadInput): AptosSubmitTransactionRequestPayloadValue;
    static fromJSON(json: AptosSubmitTransactionRequestPayloadJSON): AptosSubmitTransactionRequestPayloadValue;
    static toJSON(value: AptosSubmitTransactionRequestPayloadValue): AptosSubmitTransactionRequestPayloadJSON;
}

type AptosSubmitTransactionRequestSignatureJSON = AptosEd25519SignatureRequestJSON | AptosMultiEd25519SignatureRequestJSON | AptosMultiAgentSignatureRequestJSON;
type AptosSubmitTransactionRequestSignatureInput = AptosEd25519SignatureRequestInput | AptosMultiEd25519SignatureRequestInput | AptosMultiAgentSignatureRequestInput;
type AptosSubmitTransactionRequestSignatureValue = AptosEd25519SignatureRequest | AptosMultiEd25519SignatureRequest | AptosMultiAgentSignatureRequest;
declare abstract class AptosSubmitTransactionRequestSignature {
    static create(input: AptosSubmitTransactionRequestSignatureInput): AptosSubmitTransactionRequestSignatureValue;
    static fromJSON(json: AptosSubmitTransactionRequestSignatureJSON): AptosSubmitTransactionRequestSignatureValue;
    static toJSON(value: AptosSubmitTransactionRequestSignatureValue): AptosSubmitTransactionRequestSignatureJSON;
}

interface AptosSubmitTransactionRequestJSON {
    readonly sender: AptosAddressJSON;
    readonly sequence_number: string;
    readonly max_gas_amount: string;
    readonly gas_unit_price: string;
    readonly expiration_timestamp_secs: string;
    readonly payload: AptosSubmitTransactionRequestPayloadJSON;
    readonly signature: AptosSubmitTransactionRequestSignatureJSON;
}
interface AptosSubmitTransactionRequestInput {
    readonly sender: AptosAddressInput | AptosAddress;
    readonly sequenceNumber: string;
    readonly maxGasAmount: string;
    readonly gasUnitPrice: string;
    readonly expirationTimestampSecs: string;
    readonly payload: AptosSubmitTransactionRequestPayloadInput | AptosSubmitTransactionRequestPayloadValue;
    readonly signature: AptosSubmitTransactionRequestSignatureInput | AptosSubmitTransactionRequestSignatureValue;
}
declare class AptosSubmitTransactionRequest {
    static create(input: AptosSubmitTransactionRequestInput | AptosSubmitTransactionRequest): AptosSubmitTransactionRequest;
    static fromJSON(json: AptosSubmitTransactionRequestJSON): AptosSubmitTransactionRequest;
    /**
     * @description A hex encoded 32 byte Aptos account address.
     */
    readonly sender: AptosAddress;
    /**
     * @description A string containing a 64-bit unsigned integer.
     */
    readonly sequenceNumber: string;
    /**
     * @description A string containing a 64-bit unsigned integer.
     */
    readonly maxGasAmount: string;
    /**
     * @description A string containing a 64-bit unsigned integer.
     */
    readonly gasUnitPrice: string;
    /**
     * @description A string containing a 64-bit unsigned integer.
     */
    readonly expirationTimestampSecs: string;
    /**
     * @description An enum of the possible transaction payloads
     */
    readonly payload: AptosSubmitTransactionRequestPayloadValue;
    readonly signature: AptosSubmitTransactionRequestSignatureValue;
    private constructor();
    toJSON(): AptosSubmitTransactionRequestJSON;
}

interface SubmitTransactionOperationRequest {
    /**
     * @description The network of query. Defaults to mainnet.
     */
    readonly network?: AptosNetworkInput | AptosNetwork;
}
interface SubmitTransactionOperationRequestJSON {
    readonly network?: AptosNetworkJSON;
}
declare const SubmitTransactionOperation: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosPendingTransactionJSON): AptosPendingTransaction;
    serializeRequest(request: SubmitTransactionOperationRequest): SubmitTransactionOperationRequestJSON;
    serializeBody(body: AptosSubmitTransactionRequestInput | AptosSubmitTransactionRequest): AptosSubmitTransactionRequestJSON;
};

type AptosGetTransactionByHashJSON = AptosPendingTransactionJSON | AptosUserTransactionJSON | AptosGenesisTransactionJSON | AptosBlockMetadataTransactionJSON | AptosStateCheckpointTransactionJSON;
type AptosGetTransactionByHashInput = AptosPendingTransactionInput | AptosUserTransactionInput | AptosGenesisTransactionInput | AptosBlockMetadataTransactionInput | AptosStateCheckpointTransactionInput;
type AptosGetTransactionByHashValue = AptosPendingTransaction | AptosUserTransaction | AptosGenesisTransaction | AptosBlockMetadataTransaction | AptosStateCheckpointTransaction;
declare abstract class AptosGetTransactionByHash {
    static create(input: AptosGetTransactionByHashInput): AptosGetTransactionByHashValue;
    static fromJSON(json: AptosGetTransactionByHashJSON): AptosGetTransactionByHashValue;
    static toJSON(value: AptosGetTransactionByHashValue): AptosGetTransactionByHashJSON;
}

interface GetTransactionByHashOperationRequest {
    /**
     * @description Hash of transaction to retrieve
     */
    readonly txnHash: string;
    /**
     * @description The network of query. Defaults to mainnet.
     */
    readonly network?: AptosNetworkInput | AptosNetwork;
}
interface GetTransactionByHashOperationRequestJSON {
    readonly txn_hash: string;
    readonly network?: AptosNetworkJSON;
}
declare const GetTransactionByHashOperation: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosGetTransactionByHashJSON): AptosGetTransactionByHashValue;
    serializeRequest(request: GetTransactionByHashOperationRequest): GetTransactionByHashOperationRequestJSON;
};

type AptosGetTransactionByVersionJSON = AptosPendingTransactionJSON | AptosUserTransactionJSON | AptosGenesisTransactionJSON | AptosBlockMetadataTransactionJSON | AptosStateCheckpointTransactionJSON;
type AptosGetTransactionByVersionInput = AptosPendingTransactionInput | AptosUserTransactionInput | AptosGenesisTransactionInput | AptosBlockMetadataTransactionInput | AptosStateCheckpointTransactionInput;
type AptosGetTransactionByVersionValue = AptosPendingTransaction | AptosUserTransaction | AptosGenesisTransaction | AptosBlockMetadataTransaction | AptosStateCheckpointTransaction;
declare abstract class AptosGetTransactionByVersion {
    static create(input: AptosGetTransactionByVersionInput): AptosGetTransactionByVersionValue;
    static fromJSON(json: AptosGetTransactionByVersionJSON): AptosGetTransactionByVersionValue;
    static toJSON(value: AptosGetTransactionByVersionValue): AptosGetTransactionByVersionJSON;
}

interface GetTransactionByVersionOperationRequest {
    /**
     * @description Version of transaction to retrieve
     */
    readonly txnVersion: string;
    /**
     * @description The network of query. Defaults to mainnet.
     */
    readonly network?: AptosNetworkInput | AptosNetwork;
}
interface GetTransactionByVersionOperationRequestJSON {
    readonly txn_version: string;
    readonly network?: AptosNetworkJSON;
}
declare const GetTransactionByVersionOperation: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosGetTransactionByVersionJSON): AptosGetTransactionByVersionValue;
    serializeRequest(request: GetTransactionByVersionOperationRequest): GetTransactionByVersionOperationRequestJSON;
};

type AptosGetAccountTransactionsItemJSON = AptosPendingTransactionJSON | AptosUserTransactionJSON | AptosGenesisTransactionJSON | AptosBlockMetadataTransactionJSON | AptosStateCheckpointTransactionJSON;
type AptosGetAccountTransactionsItemInput = AptosPendingTransactionInput | AptosUserTransactionInput | AptosGenesisTransactionInput | AptosBlockMetadataTransactionInput | AptosStateCheckpointTransactionInput;
type AptosGetAccountTransactionsItemValue = AptosPendingTransaction | AptosUserTransaction | AptosGenesisTransaction | AptosBlockMetadataTransaction | AptosStateCheckpointTransaction;
declare abstract class AptosGetAccountTransactionsItem {
    static create(input: AptosGetAccountTransactionsItemInput): AptosGetAccountTransactionsItemValue;
    static fromJSON(json: AptosGetAccountTransactionsItemJSON): AptosGetAccountTransactionsItemValue;
    static toJSON(value: AptosGetAccountTransactionsItemValue): AptosGetAccountTransactionsItemJSON;
}

interface GetAccountTransactionsOperationRequest {
    /**
     * @description Address of account with or without a 0x prefix
     */
    readonly address: string;
    /**
     * @description Max number of transactions to retrieve.
     * If not provided, defaults to default page size
     */
    readonly limit?: number;
    /**
     * @description Account sequence number to start list of transactions.
     * If not provided, defaults to showing the latest transactions
     */
    readonly start?: string;
    /**
     * @description The network of query. Defaults to mainnet.
     */
    readonly network?: AptosNetworkInput | AptosNetwork;
}
interface GetAccountTransactionsOperationRequestJSON {
    readonly address: string;
    readonly limit?: number;
    readonly start?: string;
    readonly network?: AptosNetworkJSON;
}
declare const GetAccountTransactionsOperation: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosGetAccountTransactionsItemJSON[]): AptosGetAccountTransactionsItemValue[];
    serializeRequest(request: GetAccountTransactionsOperationRequest): GetAccountTransactionsOperationRequestJSON;
};

interface AptosSubmitBatchTransactionResultJSON {
    readonly transaction_failures: string[];
}
interface AptosSubmitBatchTransactionResultInput {
    readonly transactionFailures: string[];
}
declare class AptosSubmitBatchTransactionResult {
    static create(input: AptosSubmitBatchTransactionResultInput | AptosSubmitBatchTransactionResult): AptosSubmitBatchTransactionResult;
    static fromJSON(json: AptosSubmitBatchTransactionResultJSON): AptosSubmitBatchTransactionResult;
    /**
     * @description Summary of the failed transactions
     */
    readonly transactionFailures: string[];
    private constructor();
    toJSON(): AptosSubmitBatchTransactionResultJSON;
}

interface SubmitBatchTransactionsOperationRequest {
    /**
     * @description The network of query. Defaults to mainnet.
     */
    readonly network?: AptosNetworkInput | AptosNetwork;
}
interface SubmitBatchTransactionsOperationRequestJSON {
    readonly network?: AptosNetworkJSON;
}
declare const SubmitBatchTransactionsOperation: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosSubmitBatchTransactionResultJSON): AptosSubmitBatchTransactionResult;
    serializeRequest(request: SubmitBatchTransactionsOperationRequest): SubmitBatchTransactionsOperationRequestJSON;
    serializeBody(body: AptosSubmitTransactionRequestInput[] | AptosSubmitTransactionRequest[]): AptosSubmitTransactionRequestJSON[];
};

type AptosSimulateTransactionJSON = AptosPendingTransactionJSON | AptosUserTransactionJSON | AptosGenesisTransactionJSON | AptosBlockMetadataTransactionJSON | AptosStateCheckpointTransactionJSON;
type AptosSimulateTransactionInput = AptosPendingTransactionInput | AptosUserTransactionInput | AptosGenesisTransactionInput | AptosBlockMetadataTransactionInput | AptosStateCheckpointTransactionInput;
type AptosSimulateTransactionValue = AptosPendingTransaction | AptosUserTransaction | AptosGenesisTransaction | AptosBlockMetadataTransaction | AptosStateCheckpointTransaction;
declare abstract class AptosSimulateTransaction {
    static create(input: AptosSimulateTransactionInput): AptosSimulateTransactionValue;
    static fromJSON(json: AptosSimulateTransactionJSON): AptosSimulateTransactionValue;
    static toJSON(value: AptosSimulateTransactionValue): AptosSimulateTransactionJSON;
}

interface SimulateTransactionOperationRequest {
    /**
     * @description The network of query. Defaults to mainnet.
     */
    readonly network?: AptosNetworkInput | AptosNetwork;
}
interface SimulateTransactionOperationRequestJSON {
    readonly network?: AptosNetworkJSON;
}
declare const SimulateTransactionOperation: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosSimulateTransactionJSON): AptosSimulateTransactionValue;
    serializeRequest(request: SimulateTransactionOperationRequest): SimulateTransactionOperationRequestJSON;
    serializeBody(body: AptosSubmitTransactionRequestInput | AptosSubmitTransactionRequest): AptosSubmitTransactionRequestJSON;
};

type AptosEncodeSubmissionRequestPayloadJSON = AptosEntryFunctionPayloadRequestJSON | AptosScriptPayloadRequestJSON | AptosModuleBundlePayloadRequestJSON;
type AptosEncodeSubmissionRequestPayloadInput = AptosEntryFunctionPayloadRequestInput | AptosScriptPayloadRequestInput | AptosModuleBundlePayloadRequestInput;
type AptosEncodeSubmissionRequestPayloadValue = AptosEntryFunctionPayloadRequest | AptosScriptPayloadRequest | AptosModuleBundlePayloadRequest;
declare abstract class AptosEncodeSubmissionRequestPayload {
    static create(input: AptosEncodeSubmissionRequestPayloadInput): AptosEncodeSubmissionRequestPayloadValue;
    static fromJSON(json: AptosEncodeSubmissionRequestPayloadJSON): AptosEncodeSubmissionRequestPayloadValue;
    static toJSON(value: AptosEncodeSubmissionRequestPayloadValue): AptosEncodeSubmissionRequestPayloadJSON;
}

interface AptosEncodeSubmissionRequestJSON {
    readonly sender: AptosAddressJSON;
    readonly sequence_number: string;
    readonly max_gas_amount: string;
    readonly gas_unit_price: string;
    readonly expiration_timestamp_secs: string;
    readonly payload: AptosEncodeSubmissionRequestPayloadJSON;
    readonly secondary_signers: string[];
}
interface AptosEncodeSubmissionRequestInput {
    readonly sender: AptosAddressInput | AptosAddress;
    readonly sequenceNumber: string;
    readonly maxGasAmount: string;
    readonly gasUnitPrice: string;
    readonly expirationTimestampSecs: string;
    readonly payload: AptosEncodeSubmissionRequestPayloadInput | AptosEncodeSubmissionRequestPayloadValue;
    readonly secondarySigners: string[];
}
declare class AptosEncodeSubmissionRequest {
    static create(input: AptosEncodeSubmissionRequestInput | AptosEncodeSubmissionRequest): AptosEncodeSubmissionRequest;
    static fromJSON(json: AptosEncodeSubmissionRequestJSON): AptosEncodeSubmissionRequest;
    /**
     * @description A hex encoded 32 byte Aptos account address.
     */
    readonly sender: AptosAddress;
    /**
     * @description A string containing a 64-bit unsigned integer.
     */
    readonly sequenceNumber: string;
    /**
     * @description A string containing a 64-bit unsigned integer.
     */
    readonly maxGasAmount: string;
    /**
     * @description A string containing a 64-bit unsigned integer.
     */
    readonly gasUnitPrice: string;
    /**
     * @description A string containing a 64-bit unsigned integer.
     */
    readonly expirationTimestampSecs: string;
    /**
     * @description An enum of the possible transaction payloads
     */
    readonly payload: AptosEncodeSubmissionRequestPayloadValue;
    /**
     * @description Secondary signer accounts of the request for Multi-agent
     */
    readonly secondarySigners: string[];
    private constructor();
    toJSON(): AptosEncodeSubmissionRequestJSON;
}

interface EncodeSubmissionOperationRequest {
    /**
     * @description The network of query. Defaults to mainnet.
     */
    readonly network?: AptosNetworkInput | AptosNetwork;
}
interface EncodeSubmissionOperationRequestJSON {
    readonly network?: AptosNetworkJSON;
}
declare const EncodeSubmissionOperation: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: string): string;
    serializeRequest(request: EncodeSubmissionOperationRequest): EncodeSubmissionOperationRequestJSON;
    serializeBody(body: AptosEncodeSubmissionRequestInput | AptosEncodeSubmissionRequest): AptosEncodeSubmissionRequestJSON;
};

interface AptosEstimateGasPriceResultJSON {
    readonly deprioritized_gas_estimate: number;
    readonly gas_estimate: number;
    readonly prioritized_gas_estimate: number;
}
interface AptosEstimateGasPriceResultInput {
    readonly deprioritizedGasEstimate: number;
    readonly gasEstimate: number;
    readonly prioritizedGasEstimate: number;
}
declare class AptosEstimateGasPriceResult {
    static create(input: AptosEstimateGasPriceResultInput | AptosEstimateGasPriceResult): AptosEstimateGasPriceResult;
    static fromJSON(json: AptosEstimateGasPriceResultJSON): AptosEstimateGasPriceResult;
    /**
     * @description The deprioritized estimate for the gas unit price
     */
    readonly deprioritizedGasEstimate: number;
    /**
     * @description The current estimate for the gas unit price
     */
    readonly gasEstimate: number;
    /**
     * @description The prioritized estimate for the gas unit price
     */
    readonly prioritizedGasEstimate: number;
    private constructor();
    toJSON(): AptosEstimateGasPriceResultJSON;
}

interface EstimateGasPriceOperationRequest {
    /**
     * @description The network of query. Defaults to mainnet.
     */
    readonly network?: AptosNetworkInput | AptosNetwork;
}
interface EstimateGasPriceOperationRequestJSON {
    readonly network?: AptosNetworkJSON;
}
declare const EstimateGasPriceOperation: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosEstimateGasPriceResultJSON): AptosEstimateGasPriceResult;
    serializeRequest(request: EstimateGasPriceOperationRequest): EstimateGasPriceOperationRequestJSON;
};

type AptosBlockTransactionsItemJSON = AptosPendingTransactionJSON | AptosUserTransactionJSON | AptosGenesisTransactionJSON | AptosBlockMetadataTransactionJSON | AptosStateCheckpointTransactionJSON;
type AptosBlockTransactionsItemInput = AptosPendingTransactionInput | AptosUserTransactionInput | AptosGenesisTransactionInput | AptosBlockMetadataTransactionInput | AptosStateCheckpointTransactionInput;
type AptosBlockTransactionsItemValue = AptosPendingTransaction | AptosUserTransaction | AptosGenesisTransaction | AptosBlockMetadataTransaction | AptosStateCheckpointTransaction;
declare abstract class AptosBlockTransactionsItem {
    static create(input: AptosBlockTransactionsItemInput): AptosBlockTransactionsItemValue;
    static fromJSON(json: AptosBlockTransactionsItemJSON): AptosBlockTransactionsItemValue;
    static toJSON(value: AptosBlockTransactionsItemValue): AptosBlockTransactionsItemJSON;
}

interface AptosBlockJSON {
    readonly block_height: string;
    readonly block_hash: string;
    readonly block_timestamp: string;
    readonly first_version: string;
    readonly last_version: string;
    readonly transactions?: AptosBlockTransactionsItemJSON[];
}
interface AptosBlockInput {
    readonly blockHeight: string;
    readonly blockHash: string;
    readonly blockTimestamp: string;
    readonly firstVersion: string;
    readonly lastVersion: string;
    readonly transactions?: AptosBlockTransactionsItemInput[] | AptosBlockTransactionsItemValue[];
}
declare class AptosBlock {
    static create(input: AptosBlockInput | AptosBlock): AptosBlock;
    static fromJSON(json: AptosBlockJSON): AptosBlock;
    /**
     * @description A string containing a 64-bit unsigned integer.
     */
    readonly blockHeight: string;
    readonly blockHash: string;
    /**
     * @description A string containing a 64-bit unsigned integer.
     */
    readonly blockTimestamp: string;
    /**
     * @description A string containing a 64-bit unsigned integer.
     */
    readonly firstVersion: string;
    /**
     * @description A string containing a 64-bit unsigned integer.
     */
    readonly lastVersion: string;
    /**
     * @description List of transactions
     */
    readonly transactions?: AptosBlockTransactionsItemValue[];
    private constructor();
    toJSON(): AptosBlockJSON;
}

interface GetBlockByHeightOperationRequest {
    /**
     * @description Block height to lookup. Starts at 0
     */
    readonly blockHeight: number;
    /**
     * @description If set to true, include all transactions in the block
     */
    readonly withTransactions?: boolean;
    /**
     * @description The network of query. Defaults to mainnet.
     */
    readonly network?: AptosNetworkInput | AptosNetwork;
}
interface GetBlockByHeightOperationRequestJSON {
    readonly block_height: number;
    readonly with_transactions?: boolean;
    readonly network?: AptosNetworkJSON;
}
declare const GetBlockByHeightOperation: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosBlockJSON): AptosBlock;
    serializeRequest(request: GetBlockByHeightOperationRequest): GetBlockByHeightOperationRequestJSON;
};

interface GetBlockByVersionOperationRequest {
    /**
     * @description Ledger version to lookup block information for.
     */
    readonly version: number;
    /**
     * @description If set to true, include all transactions in the block
     */
    readonly withTransactions?: boolean;
    /**
     * @description The network of query. Defaults to mainnet.
     */
    readonly network?: AptosNetworkInput | AptosNetwork;
}
interface GetBlockByVersionOperationRequestJSON {
    readonly version: number;
    readonly with_transactions?: boolean;
    readonly network?: AptosNetworkJSON;
}
declare const GetBlockByVersionOperation: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosBlockJSON): AptosBlock;
    serializeRequest(request: GetBlockByVersionOperationRequest): GetBlockByVersionOperationRequestJSON;
};

interface OperationV3<Request, RequestJSON, Response, ResponseJSON, Body, BodyJSON> {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    serializeRequest?: (request: Request) => RequestJSON;
    parseResponse?: (json: ResponseJSON) => Response;
    serializeBody?: (body: Body) => BodyJSON;
}
declare abstract class AbstractClient {
    protected abstract createEndpoint<Request, RequestJSON, Response, ResponseJSON>(operation: OperationV3<Request, RequestJSON, Response, ResponseJSON, null, null>): (request: Request) => Promise<Response>;
    protected abstract createEndpointWithBody<Request, RequestJSON, Response, ResponseJSON, Body, BodyJSON>(operation: OperationV3<Request, RequestJSON, Response, ResponseJSON, Body, BodyJSON>): (request: Request, body: Body) => Promise<Response>;
    readonly accounts: {
        /**
         * @description Get account
         * @param request Request with parameters.
         * @param {String} request.address Address of account with or without a 0x prefix
         * @param {String} [request.ledgerVersion] Ledger version to get state of account.
         * If not provided, it will be the latest version (optional)
         * @param {Object} [request.network] The network of query. Defaults to mainnet. (optional)
         * @returns {Object} Response for the request.
         */
        getAccount: (request: GetAccountOperationRequest) => Promise<AptosGetAccountResponse>;
        /**
         * @description Get account resources
         * @param request Request with parameters.
         * @param {String} request.address Address of account with or without a 0x prefix
         * @param {String} [request.ledgerVersion] Ledger version to get state of account.
         * If not provided, it will be the latest version (optional)
         * @param {Number} [request.limit] Max number of account resources to retrieve.
         * If not provided, defaults to default page size. (optional)
         * @param {String} [request.start] Cursor specifying where to start for pagination
         * This cursor cannot be derived manually client-side. Instead, you must call this endpoint once without this query parameter specified, and then use the cursor returned in the X-Aptos-Cursor header in the response. (optional)
         * @param {Object} [request.network] The network of query. Defaults to mainnet. (optional)
         * @returns {Object[]} Response for the request.
         */
        getAccountResources: (request: GetAccountResourcesOperationRequest) => Promise<AptosGetAccountResourceResponse[]>;
        /**
         * @description Get account modules
         * @param request Request with parameters.
         * @param {String} request.address Address of account with or without a 0x prefix
         * @param {String} [request.ledgerVersion] Ledger version to get state of account.
         * If not provided, it will be the latest version (optional)
         * @param {Number} [request.limit] Max number of account resources to retrieve.
         * If not provided, defaults to default page size. (optional)
         * @param {String} [request.start] Cursor specifying where to start for pagination
         * This cursor cannot be derived manually client-side. Instead, you must call this endpoint once without this query parameter specified, and then use the cursor returned in the X-Aptos-Cursor header in the response. (optional)
         * @param {Object} [request.network] The network of query. Defaults to mainnet. (optional)
         * @returns {Object[]} Response for the request.
         */
        getAccountModules: (request: GetAccountModulesOperationRequest) => Promise<AptosGetAccountModuleResponse[]>;
        /**
         * @description Get account resource
         * @param request Request with parameters.
         * @param {String} request.address Address of account with or without a 0x prefix
         * @param {String} request.resourceType Name of struct to retrieve e.g. 0x1::account::Account
         * @param {String} [request.ledgerVersion] Ledger version to get state of account.
         * If not provided, it will be the latest version (optional)
         * @param {Object} [request.network] The network of query. Defaults to mainnet. (optional)
         * @returns {Object} Response for the request.
         */
        getAccountResource: (request: GetAccountResourceOperationRequest) => Promise<AptosGetAccountResourceResponse>;
        /**
         * @description Get account module
         * @param request Request with parameters.
         * @param {String} request.address Address of account with or without a 0x prefix
         * @param {String} request.moduleName Name of module to retrieve
         * @param {String} [request.ledgerVersion] Ledger version to get state of account.
         * If not provided, it will be the latest version (optional)
         * @param {Object} [request.network] The network of query. Defaults to mainnet. (optional)
         * @returns {Object} Response for the request.
         */
        getAccountModule: (request: GetAccountModuleOperationRequest) => Promise<AptosGetAccountModuleResponse>;
        /**
         * @description Get events by creation number
         * @param request Request with parameters.
         * @param {String} request.address Address of account with or without a 0x prefix
         * @param {String} request.creationNumber Creation number corresponding to the event stream originating from the given account.
         * @param {Number} [request.limit] Max number of account resources to retrieve.
         * If not provided, defaults to default page size. (optional)
         * @param {String} [request.start] Starting sequence number of events.
         * If unspecified, by default will retrieve the most recent events (optional)
         * @param {Object} [request.network] The network of query. Defaults to mainnet. (optional)
         * @returns {Object[]} Response for the request.
         */
        getEventsByCreationNumber: (request: GetEventsByCreationNumberOperationRequest) => Promise<AptosGetEventsByCreationNumberResponse[]>;
        /**
         * @description Get events by event handle
         * @param request Request with parameters.
         * @param {String} request.address Hex-encoded 32 byte Aptos account, with or without a 0x prefix, for which events are queried. This refers to the account that events were emitted to, not the account hosting the move module that emits that event type.
         * @param {String} request.eventHandle Name of struct to lookup event handle.
         * @param {String} request.fieldName Name of field to lookup event handle.
         * @param {Number} [request.limit] Max number of account resources to retrieve.
         * If not provided, defaults to default page size. (optional)
         * @param {String} [request.start] Starting sequence number of events.
         * If unspecified, by default will retrieve the most recent events (optional)
         * @param {Object} [request.network] The network of query. Defaults to mainnet. (optional)
         * @returns {Object[]} Response for the request.
         */
        getEventsByEventHandle: (request: GetEventsByEventHandleOperationRequest) => Promise<AptosGetEventsByEventHandleResponse[]>;
    };
    readonly blocks: {
        /**
         * @description Get block by height
         * @param request Request with parameters.
         * @param {Number} request.blockHeight Block height to lookup. Starts at 0
         * @param {Boolean} [request.withTransactions] If set to true, include all transactions in the block (optional)
         * @param {Object} [request.network] The network of query. Defaults to mainnet. (optional)
         * @returns {Object} Response for the request.
         */
        getBlockByHeight: (request: GetBlockByHeightOperationRequest) => Promise<AptosBlock>;
        /**
         * @description Get block by version
         * @param request Request with parameters.
         * @param {Number} request.version Ledger version to lookup block information for.
         * @param {Boolean} [request.withTransactions] If set to true, include all transactions in the block (optional)
         * @param {Object} [request.network] The network of query. Defaults to mainnet. (optional)
         * @returns {Object} Response for the request.
         */
        getBlockByVersion: (request: GetBlockByVersionOperationRequest) => Promise<AptosBlock>;
    };
    readonly coins: {
        /**
         * @description Get Coin Metadata by Coin Type Hashes
         * @param request Request with parameters.
         * @param {String[]} request.coinTypeHashes The coin type hashes to fetch info about
         * @param {Object} [request.network] The network of query. Defaults to mainnet. (optional)
         * @returns {Object[]} Response for the request.
         */
        getCoinInfoByCoinTypeHashes: (request: GetCoinInfoByCoinTypeHashesOperationRequest) => Promise<AptosCoinInfoDto[]>;
        /**
         * @description Get latest deployed coins
         * @param request Request with parameters.
         * @param {Number} request.limit The number of results to return
         * @param {Number} [request.offset] The number of results to skip (optional)
         * @param {String} [request.cursor] The cursor to use for getting the next page (optional)
         * @param {Object} [request.network] The network of query. Defaults to mainnet. (optional)
         * @returns {Object} Response for the request.
         */
        getLatestCoins: (request: GetLatestCoinsOperationRequest) => Promise<AptosGetLatestCoinsResponse>;
        /**
         * @description Get Coin Metadata by name range
         * @param request Request with parameters.
         * @param {Number} request.limit The number of results to return
         * @param {Number} [request.offset] The number of results to skip (optional)
         * @param {String} [request.cursor] The cursor to use for getting the next page (optional)
         * @param {String} [request.fromName] The name of the coin to start from (inclusive and case sensitive) (optional)
         * @param {String} [request.toName] The name of the coin to end at (inclusive and case sensitive) (optional)
         * @param {Object} [request.network] The network of query. Defaults to mainnet. (optional)
         * @returns {Object} Response for the request.
         */
        getCoinsByNameRange: (request: GetCoinsByNameRangeOperationRequest) => Promise<AptosGetCoinsByNameRangeResponse>;
        /**
         * @description Get Coin Metadata by symbol range
         * @param request Request with parameters.
         * @param {Number} request.limit The number of results to return
         * @param {Number} [request.offset] The number of results to skip (optional)
         * @param {String} [request.cursor] The cursor to use for getting the next page (optional)
         * @param {String} [request.fromSymbol] The name of the coin to start from (inclusive and case sensitive) (optional)
         * @param {String} [request.toSymbol] The name of the coin to end at (inclusive and case sensitive) (optional)
         * @param {Object} [request.network] The network of query. Defaults to mainnet. (optional)
         * @returns {Object} Response for the request.
         */
        getCoinsBySymbolRange: (request: GetCoinsBySymbolRangeOperationRequest) => Promise<AptosGetCoinsBySymbolRangeResponse>;
        /**
         * @description Get Coin Metadata by creator addresses
         * @param request Request with parameters.
         * @param {Number} request.limit The number of results to return
         * @param {Object[]} request.creatorAddresses The addresses of the creators
         * @param {Number} [request.offset] The number of results to skip (optional)
         * @param {String} [request.cursor] The cursor to use for getting the next page (optional)
         * @param {Object} [request.network] The network of query. Defaults to mainnet. (optional)
         * @returns {Object} Response for the request.
         */
        getCoinsByCreators: (request: GetCoinsByCreatorsOperationRequest) => Promise<AptosGetCoinsByCreatorsResponse>;
        /**
         * @description Get Coin Transfers by wallet addresses
         * @param request Request with parameters.
         * @param {Number} request.limit The number of results to return
         * @param {Object[]} request.ownerAddresses The addresses of the owners to get tokens for
         * @param {Number} [request.offset] The number of results to skip (optional)
         * @param {String} [request.cursor] The cursor to use for getting the next page (optional)
         * @param {String} [request.fromDate] The date from which to fetch coin transfers (optional)
         * @param {String} [request.toDate] The date to which to fetch coin transfers (optional)
         * @param {String[]} [request.coinTypeBlacklist] The coin types of the coins to whitelist (optional)
         * @param {String[]} [request.coinTypeWhitelist] The coin types of the coins to whitelist (optional)
         * @param {Object} [request.network] The network of query. Defaults to mainnet. (optional)
         * @returns {Object} Response for the request.
         */
        getCoinTransfersByOwnerAddresses: (request: GetCoinTransfersByOwnerAddressesOperationRequest) => Promise<AptosGetCoinTransfersByOwnerAddressesResponse>;
        /**
         * @description Get Coin Transfers by block heights
         * @param request Request with parameters.
         * @param {Number} request.limit The number of results to return
         * @param {String[]} request.blockHeights The coin types to fetch info about
         * @param {Number} [request.offset] The number of results to skip (optional)
         * @param {String} [request.cursor] The cursor to use for getting the next page (optional)
         * @param {Object} [request.network] The network of query. Defaults to mainnet. (optional)
         * @returns {Object} Response for the request.
         */
        getCoinTransfersByBlockHeights: (request: GetCoinTransfersByBlockHeightsOperationRequest) => Promise<AptosGetCoinTransfersByBlockHeightsResponse>;
        /**
         * @description Get Coin Transfers by Coin Type
         * @param request Request with parameters.
         * @param {String} request.coinType The coin type to fetch info about
         * @param {Number} request.limit The number of results to return
         * @param {Number} [request.offset] The number of results to skip (optional)
         * @param {String} [request.cursor] The cursor to use for getting the next page (optional)
         * @param {String} [request.fromDate] The date from which to fetch coin transfers (optional)
         * @param {String} [request.toDate] The date to which to fetch coin transfers (optional)
         * @param {Object} [request.network] The network of query. Defaults to mainnet. (optional)
         * @returns {Object} Response for the request.
         */
        getCoinTransfersByCoinType: (request: GetCoinTransfersByCoinTypeOperationRequest) => Promise<AptosGetCoinTransfersByCoinTypeResponse>;
        /**
         * @description Get top Holders of Coin
         * @param request Request with parameters.
         * @param {String} request.coinTypeHash The coin type hash to fetch info about
         * @param {Number} request.limit The number of results to return
         * @param {Number} [request.offset] The number of results to skip (optional)
         * @param {String} [request.cursor] The cursor to use for getting the next page (optional)
         * @param {Object} [request.minAmount] The minimum amount of coins required for a wallet to be included in the results (optional)
         * @param {Number} [request.minVersion] The minimum version on when the balance was last updated (optional)
         * @param {String[]} [request.walletBlacklist] The addresses of the wallets to blacklist (optional)
         * @param {String[]} [request.walletWhitelist] The addresses of the wallets to whitelist (optional)
         * @param {Object} [request.network] The network of query. Defaults to mainnet. (optional)
         * @returns {Object} Response for the request.
         */
        getTopHoldersByCoin: (request: GetTopHoldersByCoinOperationRequest) => Promise<AptosGetTopHoldersByCoinResponse>;
    };
    readonly collections: {
        /**
         * @description Get NFT Collections
         * @param request Request with parameters.
         * @param {Number} request.limit The number of results to return
         * @param {Number} [request.offset] The number of results to skip (optional)
         * @param {String} [request.cursor] The cursor to use for getting the next page (optional)
         * @param {String} [request.fromName] The name of the collection to start from (inclusive and case sensitive) (optional)
         * @param {String} [request.toName] The name of the collection to end at (inclusive and case sensitive) (optional)
         * @param {Object} [request.network] The network of query. Defaults to mainnet. (optional)
         * @returns {Object} Response for the request.
         */
        getNFTCollections: (request: GetNFTCollectionsOperationRequest) => Promise<AptosNFTCollectionsByNameRangeResponse>;
        /**
         * @description Get NFT Collections by ids
         * @param request Request with parameters.
         * @param {String[]} request.ids The identifiers of the collections to get
         * @param {Object} [request.network] The network of query. Defaults to mainnet. (optional)
         * @returns {Object[]} Response for the request.
         */
        getNFTCollectionsByIds: (request: GetNFTCollectionsByIdsOperationRequest) => Promise<AptosNFTCollectionItemResponse[]>;
        /**
         * @description Get NFT Collections by creator
         * @param request Request with parameters.
         * @param {Number} request.limit The number of results to return
         * @param {Object} request.creatorAddress The address of the creator
         * @param {Number} [request.offset] The number of results to skip (optional)
         * @param {String} [request.cursor] The cursor to use for getting the next page (optional)
         * @param {Object} [request.network] The network of query. Defaults to mainnet. (optional)
         * @returns {Object} Response for the request.
         */
        getNFTCollectionsByCreator: (request: GetNFTCollectionsByCreatorOperationRequest) => Promise<AptosNFTCollectionsByCreatorResponse>;
    };
    readonly nfts: {
        /**
         * @description Get NFTs by ids
         * @param request Request with parameters.
         * @param {String[]} request.tokenIds The identifiers of the tokens to get
         * @param {Object} [request.network] The network of query. Defaults to mainnet. (optional)
         * @returns {Object[]} Response for the request.
         */
        getNFTsByIds: (request: GetNFTsByIdsOperationRequest) => Promise<AptosNFTTokenResponse[]>;
        /**
         * @description Get NFTs by Collection
         * @param request Request with parameters.
         * @param {String} request.collectionDataIdHash The collection data id hash of the collection
         * @param {Number} request.limit The number of results to return
         * @param {Number} [request.offset] The number of results to skip (optional)
         * @param {String} [request.cursor] The cursor to use for getting the next page (optional)
         * @param {Object} [request.network] The network of query. Defaults to mainnet. (optional)
         * @returns {Object} Response for the request.
         */
        getNFTsByCollection: (request: GetNFTsByCollectionOperationRequest) => Promise<AptosNFTTokensByCollectionResponse>;
        /**
         * @description Get NFTs by creators
         * @param request Request with parameters.
         * @param {Number} request.limit The number of tokens to return
         * @param {Object[]} request.creatorAddresses The addresses of the creators
         * @param {Number} [request.offset] The number of results to skip (optional)
         * @param {String} [request.cursor] The cursor to use for getting the next page (optional)
         * @param {Object} [request.network] The network of query. Defaults to mainnet. (optional)
         * @returns {Object} Response for the request.
         */
        getNFTsByCreators: (request: GetNFTsByCreatorsOperationRequest) => Promise<AptosNFTTokensByCreatorsResponse>;
        /**
         * @description Get NFT Owners by tokens
         * @param request Request with parameters.
         * @param {Number} request.limit The number of results to return
         * @param {String[]} request.tokenIds The identifiers of the tokens to get owners for
         * @param {Number} [request.offset] The number of results to skip (optional)
         * @param {String} [request.cursor] The cursor to use for getting the next page (optional)
         * @param {Object} [request.network] The network of query. Defaults to mainnet. (optional)
         * @returns {Object} Response for the request.
         */
        getNFTOwnersByTokens: (request: GetNFTOwnersByTokensOperationRequest) => Promise<AptosNFTOwnersByTokensResponse>;
        /**
         * @description Get NFT Owners by Collection
         * @param request Request with parameters.
         * @param {String} request.collectionDataIdHash The id of the token
         * @param {Number} request.limit The number of results to return
         * @param {Number} [request.offset] The number of results to skip (optional)
         * @param {String} [request.cursor] The cursor to use for getting the next page (optional)
         * @param {String[]} [request.walletBlacklist] The addresses of the wallets to blacklist (optional)
         * @param {String[]} [request.walletWhitelist] The addresses of the wallets to whitelist (optional)
         * @param {Object} [request.network] The network of query. Defaults to mainnet. (optional)
         * @returns {Object} Response for the request.
         */
        getNFTOwnersByCollection: (request: GetNFTOwnersByCollectionOperationRequest) => Promise<AptosNFTOwnersByCollectionResponse>;
        /**
         * @description Get NFT Owners of Collection
         * @param request Request with parameters.
         * @param {String} request.collectionDataIdHash The id of the token
         * @param {Number} request.limit The number of results to return
         * @param {Number} [request.offset] The number of results to skip (optional)
         * @param {String} [request.cursor] The cursor to use for getting the next page (optional)
         * @param {Object} [request.network] The network of query. Defaults to mainnet. (optional)
         * @returns {Object} Response for the request.
         */
        getNFTOwnersOfCollection: (request: GetNFTOwnersOfCollectionOperationRequest) => Promise<AptosNFTOwnersOfCollectionResponse>;
        /**
         * @description Get NFT Transfers by Token ids
         * @param request Request with parameters.
         * @param {Number} request.limit The number of tokens to return
         * @param {String[]} request.tokenIds The identifiers of the tokens to get
         * @param {Number} [request.offset] The number of results to skip (optional)
         * @param {String} [request.cursor] The cursor to use for getting the next page (optional)
         * @param {String[]} [request.walletBlacklist] The addresses of the wallets to blacklist (optional)
         * @param {String[]} [request.walletWhitelist] The addresses of the wallets to whitelist (optional)
         * @param {Object} [request.network] The network of query. Defaults to mainnet. (optional)
         * @returns {Object} Response for the request.
         */
        getNFTTransfersByIds: (request: GetNFTTransfersByIdsOperationRequest) => Promise<AptosNFTTransfersByTokensResponse>;
        /**
         * @description Get NFT Transfers by Collection
         * @param request Request with parameters.
         * @param {String} request.collectionDataIdHash The collection data id hash of the token
         * @param {Number} request.limit The number of results to return
         * @param {Number} [request.offset] The number of results to skip (optional)
         * @param {String} [request.cursor] The cursor to use for getting the next page (optional)
         * @param {String[]} [request.walletWhitelist] The addresses of the wallets to whitelist (optional)
         * @param {String[]} [request.walletBlacklist] The addresses of the wallets to blacklist (optional)
         * @param {Object} [request.network] The network of query. Defaults to mainnet. (optional)
         * @returns {Object} Response for the request.
         */
        getNFTTransfersByCollection: (request: GetNFTTransfersByCollectionOperationRequest) => Promise<AptosGetNFTTransfersByCollectionResponse>;
        /**
         * @description Get NFT Transfers by creators
         * @param request Request with parameters.
         * @param {Number} request.limit The number of results to return
         * @param {Object[]} request.creatorAddresses The addresses of the creators
         * @param {Number} [request.offset] The number of results to skip (optional)
         * @param {String} [request.cursor] The cursor to use for getting the next page (optional)
         * @param {String[]} [request.collectionBlacklist] The ids of the collections to whitelist (optional)
         * @param {String[]} [request.collectionWhitelist] The ids of the collections to whitelist (optional)
         * @param {Object} [request.network] The network of query. Defaults to mainnet. (optional)
         * @returns {Object} Response for the request.
         */
        getNFTTransfersByCreators: (request: GetNFTTransfersByCreatorsOperationRequest) => Promise<AptosGetNFTTransfersByCreatorsResponse>;
        /**
         * @description Get NFT Transfers by wallets
         * @param request Request with parameters.
         * @param {Number} request.limit The number of tokens to return
         * @param {Object[]} request.walletAddresses The addresses of the wallets to get transfers for
         * @param {Number} [request.offset] The number of results to skip (optional)
         * @param {String} [request.cursor] The cursor to use for getting the next page (optional)
         * @param {String[]} [request.collectionBlacklist] The ids of the collections to whitelist (optional)
         * @param {String[]} [request.collectionWhitelist] The ids of the collections to whitelist (optional)
         * @param {Object} [request.network] The network of query. Defaults to mainnet. (optional)
         * @returns {Object} Response for the request.
         */
        getNFTTransfersByWallets: (request: GetNFTTransfersByWalletsOperationRequest) => Promise<AptosNFTTransfersByWalletsResponse>;
    };
    readonly transactions: {
        /**
         * @description Get transactions
         * @param request Request with parameters.
         * @param {Number} [request.limit] Max number of transactions to retrieve.
         * If not provided, defaults to default page size (optional)
         * @param {String} [request.start] Account sequence number to start list of transactions.
         * If not provided, defaults to showing the latest transactions (optional)
         * @param {Object} [request.network] The network of query. Defaults to mainnet. (optional)
         * @returns {Object[]} Response for the request.
         */
        getTransactions: (request: GetTransactionsOperationRequest) => Promise<AptosGetTransactionsItemValue[]>;
        /**
         * @description Submit transaction
         * @param request Request with parameters.
         * @param {Object} [request.network] The network of query. Defaults to mainnet. (optional)
         * @param body Request body.
         * @param {Object} body.sender A hex encoded 32 byte Aptos account address.
         * @param {String} body.sequenceNumber A string containing a 64-bit unsigned integer.
         * @param {String} body.maxGasAmount A string containing a 64-bit unsigned integer.
         * @param {String} body.gasUnitPrice A string containing a 64-bit unsigned integer.
         * @param {String} body.expirationTimestampSecs A string containing a 64-bit unsigned integer.
         * @param {Object} body.payload An enum of the possible transaction payloads
         * @param {Object} body.signature
         * @returns {Object} Response for the request.
         */
        submitTransaction: (request: SubmitTransactionOperationRequest, body: AptosSubmitTransactionRequestInput | AptosSubmitTransactionRequest) => Promise<AptosPendingTransaction>;
        /**
         * @description Get transaction by hash
         * @param request Request with parameters.
         * @param {String} request.txnHash Hash of transaction to retrieve
         * @param {Object} [request.network] The network of query. Defaults to mainnet. (optional)
         * @returns {Object} Response for the request.
         */
        getTransactionByHash: (request: GetTransactionByHashOperationRequest) => Promise<AptosGetTransactionByHashValue>;
        /**
         * @description Get transaction by version
         * @param request Request with parameters.
         * @param {String} request.txnVersion Version of transaction to retrieve
         * @param {Object} [request.network] The network of query. Defaults to mainnet. (optional)
         * @returns {Object} Response for the request.
         */
        getTransactionByVersion: (request: GetTransactionByVersionOperationRequest) => Promise<AptosGetTransactionByVersionValue>;
        /**
         * @description Get account transactions
         * @param request Request with parameters.
         * @param {String} request.address Address of account with or without a 0x prefix
         * @param {Number} [request.limit] Max number of transactions to retrieve.
         * If not provided, defaults to default page size (optional)
         * @param {String} [request.start] Account sequence number to start list of transactions.
         * If not provided, defaults to showing the latest transactions (optional)
         * @param {Object} [request.network] The network of query. Defaults to mainnet. (optional)
         * @returns {Object[]} Response for the request.
         */
        getAccountTransactions: (request: GetAccountTransactionsOperationRequest) => Promise<AptosGetAccountTransactionsItemValue[]>;
        /**
         * @description Submit batch transactions
         * @param request Request with parameters.
         * @param {Object} [request.network] The network of query. Defaults to mainnet. (optional)
         * @param body Request body.
         * @param {Object} body.sender A hex encoded 32 byte Aptos account address.
         * @param {String} body.sequenceNumber A string containing a 64-bit unsigned integer.
         * @param {String} body.maxGasAmount A string containing a 64-bit unsigned integer.
         * @param {String} body.gasUnitPrice A string containing a 64-bit unsigned integer.
         * @param {String} body.expirationTimestampSecs A string containing a 64-bit unsigned integer.
         * @param {Object} body.payload An enum of the possible transaction payloads
         * @param {Object} body.signature
         * @returns {Object} Response for the request.
         */
        submitBatchTransactions: (request: SubmitBatchTransactionsOperationRequest, body: AptosSubmitTransactionRequestInput[] | AptosSubmitTransactionRequest[]) => Promise<AptosSubmitBatchTransactionResult>;
        /**
         * @description Simulate transaction
         * @param request Request with parameters.
         * @param {Object} [request.network] The network of query. Defaults to mainnet. (optional)
         * @param body Request body.
         * @param {Object} body.sender A hex encoded 32 byte Aptos account address.
         * @param {String} body.sequenceNumber A string containing a 64-bit unsigned integer.
         * @param {String} body.maxGasAmount A string containing a 64-bit unsigned integer.
         * @param {String} body.gasUnitPrice A string containing a 64-bit unsigned integer.
         * @param {String} body.expirationTimestampSecs A string containing a 64-bit unsigned integer.
         * @param {Object} body.payload An enum of the possible transaction payloads
         * @param {Object} body.signature
         * @returns {Object} Response for the request.
         */
        simulateTransaction: (request: SimulateTransactionOperationRequest, body: AptosSubmitTransactionRequestInput | AptosSubmitTransactionRequest) => Promise<AptosSimulateTransactionValue>;
        /**
         * @description Encode submission
         * @param request Request with parameters.
         * @param {Object} [request.network] The network of query. Defaults to mainnet. (optional)
         * @param body Request body.
         * @param {Object} body.sender A hex encoded 32 byte Aptos account address.
         * @param {String} body.sequenceNumber A string containing a 64-bit unsigned integer.
         * @param {String} body.maxGasAmount A string containing a 64-bit unsigned integer.
         * @param {String} body.gasUnitPrice A string containing a 64-bit unsigned integer.
         * @param {String} body.expirationTimestampSecs A string containing a 64-bit unsigned integer.
         * @param {Object} body.payload An enum of the possible transaction payloads
         * @param {String[]} body.secondarySigners Secondary signer accounts of the request for Multi-agent
         * @returns {String} Response for the request.
         */
        encodeSubmission: (request: EncodeSubmissionOperationRequest, body: AptosEncodeSubmissionRequestInput | AptosEncodeSubmissionRequest) => Promise<string>;
        /**
         * @description Estimate gas price
         * @param request Request with parameters.
         * @param {Object} [request.network] The network of query. Defaults to mainnet. (optional)
         * @returns {Object} Response for the request.
         */
        estimateGasPrice: (request: EstimateGasPriceOperationRequest) => Promise<AptosEstimateGasPriceResult>;
    };
    readonly wallets: {
        /**
         * @description Get Coin Balances by wallet addresses
         * @param request Request with parameters.
         * @param {Number} request.limit The number of results to return
         * @param {Object[]} request.ownerAddresses The addresses of the owners to get coin balances for
         * @param {Number} [request.offset] The number of results to skip (optional)
         * @param {String} [request.cursor] The cursor to use for getting the next page (optional)
         * @param {String[]} [request.coinTypeHashBlacklist] The coin type hashes of the coins to whitelist (optional)
         * @param {String[]} [request.coinTypeHashWhitelist] The coin type hashes of the coins to whitelist (optional)
         * @param {Object} [request.network] The network of query. Defaults to mainnet. (optional)
         * @returns {Object} Response for the request.
         */
        getCoinBalancesByWallets: (request: GetCoinBalancesByWalletsOperationRequest) => Promise<AptosGetCoinBalancesByWalletsResponse>;
        /**
         * @description Get Historical Coin Balances by wallet addresses
         * @param request Request with parameters.
         * @param {Number} request.limit The number of results to return
         * @param {Object[]} request.ownerAddresses The addresses of the owner addresses to get historical balances for
         * @param {Number} [request.offset] The number of results to skip (optional)
         * @param {String} [request.cursor] The cursor to use for getting the next page (optional)
         * @param {String[]} [request.coinTypeHashBlacklist] The coin type hash of the coins to whitelist (optional)
         * @param {String[]} [request.coinTypeHashWhitelist] The coin type hash of the coins to whitelist (optional)
         * @param {Object} [request.network] The network of query. Defaults to mainnet. (optional)
         * @returns {Object} Response for the request.
         */
        getHistoricalCoinBalancesByWallets: (request: GetHistoricalCoinBalancesByWalletsOperationRequest) => Promise<AptosGetHistoricalCoinBalancesByWalletsResponse>;
        /**
         * @description Get Coin Transfers by wallet addresses
         * @param request Request with parameters.
         * @param {Number} request.limit The number of results to return
         * @param {Object[]} request.ownerAddresses The addresses of the owners to get tokens for
         * @param {Number} [request.offset] The number of results to skip (optional)
         * @param {String} [request.cursor] The cursor to use for getting the next page (optional)
         * @param {String} [request.fromDate] The date from which to fetch coin transfers (optional)
         * @param {String} [request.toDate] The date to which to fetch coin transfers (optional)
         * @param {String[]} [request.coinTypeBlacklist] The coin types of the coins to whitelist (optional)
         * @param {String[]} [request.coinTypeWhitelist] The coin types of the coins to whitelist (optional)
         * @param {Object} [request.network] The network of query. Defaults to mainnet. (optional)
         * @returns {Object} Response for the request.
         */
        getCoinTransfersByWalletAddresses: (request: GetCoinTransfersByWalletAddressesOperationRequest) => Promise<AptosGetCoinTransfersByOwnerAddressesResponse>;
        /**
         * @description Get NFTs by wallet addresses
         * @param request Request with parameters.
         * @param {Number} request.limit The number of results to return
         * @param {Object[]} request.ownerAddresses The addresses of the owners to get tokens for
         * @param {Number} [request.offset] The number of results to skip (optional)
         * @param {String} [request.cursor] The cursor to use for getting the next page (optional)
         * @param {String[]} [request.collectionBlacklist] The collection data id hashes of the collections to whitelist (optional)
         * @param {String[]} [request.collectionWhitelist] The collection data id hashes of the collections to whitelist (optional)
         * @param {Object} [request.network] The network of query. Defaults to mainnet. (optional)
         * @returns {Object} Response for the request.
         */
        getNFTByOwners: (request: GetNFTByOwnersOperationRequest) => Promise<AptosNFTsByOwnersResponse>;
        /**
         * @description Get NFT Transfers by wallets
         * @param request Request with parameters.
         * @param {Number} request.limit The number of tokens to return
         * @param {Object[]} request.walletAddresses The addresses of the wallets to get transfers for
         * @param {Number} [request.offset] The number of results to skip (optional)
         * @param {String} [request.cursor] The cursor to use for getting the next page (optional)
         * @param {String[]} [request.collectionBlacklist] The ids of the collections to whitelist (optional)
         * @param {String[]} [request.collectionWhitelist] The ids of the collections to whitelist (optional)
         * @param {Object} [request.network] The network of query. Defaults to mainnet. (optional)
         * @returns {Object} Response for the request.
         */
        getWalletsNFTTransfers: (request: GetWalletsNFTTransfersOperationRequest) => Promise<AptosNFTTransfersByWalletsResponse>;
    };
}

declare const operations: ({
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosNFTTokenResponseJSON[]): AptosNFTTokenResponse[];
    serializeRequest(request: GetNFTsByIdsOperationRequest): GetNFTsByIdsOperationRequestJSON;
} | {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosNFTTokensByCollectionResponseJSON): AptosNFTTokensByCollectionResponse;
    serializeRequest(request: GetNFTsByCollectionOperationRequest): GetNFTsByCollectionOperationRequestJSON;
} | {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosNFTTokensByCreatorsResponseJSON): AptosNFTTokensByCreatorsResponse;
    serializeRequest(request: GetNFTsByCreatorsOperationRequest): GetNFTsByCreatorsOperationRequestJSON;
} | {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosNFTCollectionsByNameRangeResponseJSON): AptosNFTCollectionsByNameRangeResponse;
    serializeRequest(request: GetNFTCollectionsOperationRequest): GetNFTCollectionsOperationRequestJSON;
} | {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosNFTCollectionItemResponseJSON[]): AptosNFTCollectionItemResponse[];
    serializeRequest(request: GetNFTCollectionsByIdsOperationRequest): GetNFTCollectionsByIdsOperationRequestJSON;
} | {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosNFTCollectionsByCreatorResponseJSON): AptosNFTCollectionsByCreatorResponse;
    serializeRequest(request: GetNFTCollectionsByCreatorOperationRequest): GetNFTCollectionsByCreatorOperationRequestJSON;
} | {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosNFTOwnersByTokensResponseJSON): AptosNFTOwnersByTokensResponse;
    serializeRequest(request: GetNFTOwnersByTokensOperationRequest): GetNFTOwnersByTokensOperationRequestJSON;
} | {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosNFTOwnersByCollectionResponseJSON): AptosNFTOwnersByCollectionResponse;
    serializeRequest(request: GetNFTOwnersByCollectionOperationRequest): GetNFTOwnersByCollectionOperationRequestJSON;
} | {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosNFTOwnersOfCollectionResponseJSON): AptosNFTOwnersOfCollectionResponse;
    serializeRequest(request: GetNFTOwnersOfCollectionOperationRequest): GetNFTOwnersOfCollectionOperationRequestJSON;
} | {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosNFTTransfersByTokensResponseJSON): AptosNFTTransfersByTokensResponse;
    serializeRequest(request: GetNFTTransfersByIdsOperationRequest): GetNFTTransfersByIdsOperationRequestJSON;
} | {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosGetNFTTransfersByCollectionResponseJSON): AptosGetNFTTransfersByCollectionResponse;
    serializeRequest(request: GetNFTTransfersByCollectionOperationRequest): GetNFTTransfersByCollectionOperationRequestJSON;
} | {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosGetNFTTransfersByCreatorsResponseJSON): AptosGetNFTTransfersByCreatorsResponse;
    serializeRequest(request: GetNFTTransfersByCreatorsOperationRequest): GetNFTTransfersByCreatorsOperationRequestJSON;
} | {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosNFTTransfersByWalletsResponseJSON): AptosNFTTransfersByWalletsResponse;
    serializeRequest(request: GetNFTTransfersByWalletsOperationRequest): GetNFTTransfersByWalletsOperationRequestJSON;
} | {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosCoinInfoDtoJSON[]): AptosCoinInfoDto[];
    serializeRequest(request: GetCoinInfoByCoinTypeHashesOperationRequest): GetCoinInfoByCoinTypeHashesOperationRequestJSON;
} | {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosGetLatestCoinsResponseJSON): AptosGetLatestCoinsResponse;
    serializeRequest(request: GetLatestCoinsOperationRequest): GetLatestCoinsOperationRequestJSON;
} | {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosGetCoinTransfersByOwnerAddressesResponseJSON): AptosGetCoinTransfersByOwnerAddressesResponse;
    serializeRequest(request: GetCoinTransfersByOwnerAddressesOperationRequest): GetCoinTransfersByOwnerAddressesOperationRequestJSON;
} | {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosGetCoinTransfersByBlockHeightsResponseJSON): AptosGetCoinTransfersByBlockHeightsResponse;
    serializeRequest(request: GetCoinTransfersByBlockHeightsOperationRequest): GetCoinTransfersByBlockHeightsOperationRequestJSON;
} | {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosGetCoinTransfersByCoinTypeResponseJSON): AptosGetCoinTransfersByCoinTypeResponse;
    serializeRequest(request: GetCoinTransfersByCoinTypeOperationRequest): GetCoinTransfersByCoinTypeOperationRequestJSON;
} | {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosGetTopHoldersByCoinResponseJSON): AptosGetTopHoldersByCoinResponse;
    serializeRequest(request: GetTopHoldersByCoinOperationRequest): GetTopHoldersByCoinOperationRequestJSON;
} | {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosGetCoinBalancesByWalletsResponseJSON): AptosGetCoinBalancesByWalletsResponse;
    serializeRequest(request: GetCoinBalancesByWalletsOperationRequest): GetCoinBalancesByWalletsOperationRequestJSON;
} | {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosGetHistoricalCoinBalancesByWalletsResponseJSON): AptosGetHistoricalCoinBalancesByWalletsResponse;
    serializeRequest(request: GetHistoricalCoinBalancesByWalletsOperationRequest): GetHistoricalCoinBalancesByWalletsOperationRequestJSON;
} | {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosNFTsByOwnersResponseJSON): AptosNFTsByOwnersResponse;
    serializeRequest(request: GetNFTByOwnersOperationRequest): GetNFTByOwnersOperationRequestJSON;
} | {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosGetAccountResponseJSON): AptosGetAccountResponse;
    serializeRequest(request: GetAccountOperationRequest): GetAccountOperationRequestJSON;
} | {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosGetAccountResourceResponseJSON[]): AptosGetAccountResourceResponse[];
    serializeRequest(request: GetAccountResourcesOperationRequest): GetAccountResourcesOperationRequestJSON;
} | {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosGetAccountModuleResponseJSON[]): AptosGetAccountModuleResponse[];
    serializeRequest(request: GetAccountModulesOperationRequest): GetAccountModulesOperationRequestJSON;
} | {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosGetAccountResourceResponseJSON): AptosGetAccountResourceResponse;
    serializeRequest(request: GetAccountResourceOperationRequest): GetAccountResourceOperationRequestJSON;
} | {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosGetAccountModuleResponseJSON): AptosGetAccountModuleResponse;
    serializeRequest(request: GetAccountModuleOperationRequest): GetAccountModuleOperationRequestJSON;
} | {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosGetEventsByCreationNumberResponseJSON[]): AptosGetEventsByCreationNumberResponse[];
    serializeRequest(request: GetEventsByCreationNumberOperationRequest): GetEventsByCreationNumberOperationRequestJSON;
} | {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosGetEventsByEventHandleResponseJSON[]): AptosGetEventsByEventHandleResponse[];
    serializeRequest(request: GetEventsByEventHandleOperationRequest): GetEventsByEventHandleOperationRequestJSON;
} | {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosGetTransactionsItemJSON[]): AptosGetTransactionsItemValue[];
    serializeRequest(request: GetTransactionsOperationRequest): GetTransactionsOperationRequestJSON;
} | {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosGetTransactionByHashJSON): AptosGetTransactionByHashValue;
    serializeRequest(request: GetTransactionByHashOperationRequest): GetTransactionByHashOperationRequestJSON;
} | {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosGetTransactionByVersionJSON): AptosGetTransactionByVersionValue;
    serializeRequest(request: GetTransactionByVersionOperationRequest): GetTransactionByVersionOperationRequestJSON;
} | {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosSubmitBatchTransactionResultJSON): AptosSubmitBatchTransactionResult;
    serializeRequest(request: SubmitBatchTransactionsOperationRequest): SubmitBatchTransactionsOperationRequestJSON;
    serializeBody(body: AptosSubmitTransactionRequestInput[] | AptosSubmitTransactionRequest[]): AptosSubmitTransactionRequestJSON[];
} | {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosSimulateTransactionJSON): AptosSimulateTransactionValue;
    serializeRequest(request: SimulateTransactionOperationRequest): SimulateTransactionOperationRequestJSON;
    serializeBody(body: AptosSubmitTransactionRequestInput | AptosSubmitTransactionRequest): AptosSubmitTransactionRequestJSON;
} | {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: string): string;
    serializeRequest(request: EncodeSubmissionOperationRequest): EncodeSubmissionOperationRequestJSON;
    serializeBody(body: AptosEncodeSubmissionRequestInput | AptosEncodeSubmissionRequest): AptosEncodeSubmissionRequestJSON;
} | {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosEstimateGasPriceResultJSON): AptosEstimateGasPriceResult;
    serializeRequest(request: EstimateGasPriceOperationRequest): EstimateGasPriceOperationRequestJSON;
} | {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosBlockJSON): AptosBlock;
    serializeRequest(request: GetBlockByHeightOperationRequest): GetBlockByHeightOperationRequestJSON;
} | {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: AptosBlockJSON): AptosBlock;
    serializeRequest(request: GetBlockByVersionOperationRequest): GetBlockByVersionOperationRequestJSON;
})[];

type AptosMultiAgentSignatureRequestSenderJSON = AptosEd25519SignatureRequestJSON | AptosMultiEd25519SignatureRequestJSON;
type AptosMultiAgentSignatureRequestSenderInput = AptosEd25519SignatureRequestInput | AptosMultiEd25519SignatureRequestInput;
type AptosMultiAgentSignatureRequestSenderValue = AptosEd25519SignatureRequest | AptosMultiEd25519SignatureRequest;
declare abstract class AptosMultiAgentSignatureRequestSender {
    static create(input: AptosMultiAgentSignatureRequestSenderInput): AptosMultiAgentSignatureRequestSenderValue;
    static fromJSON(json: AptosMultiAgentSignatureRequestSenderJSON): AptosMultiAgentSignatureRequestSenderValue;
    static toJSON(value: AptosMultiAgentSignatureRequestSenderValue): AptosMultiAgentSignatureRequestSenderJSON;
}

export { AbstractClient, AptosAddress, AptosAddressInput, AptosAddressJSON, AptosBlock, AptosBlockInput, AptosBlockJSON, AptosBlockMetadataTransaction, AptosBlockMetadataTransactionChangesItem, AptosBlockMetadataTransactionChangesItemInput, AptosBlockMetadataTransactionChangesItemJSON, AptosBlockMetadataTransactionChangesItemValue, AptosBlockMetadataTransactionInput, AptosBlockMetadataTransactionJSON, AptosBlockTransactionsItem, AptosBlockTransactionsItemInput, AptosBlockTransactionsItemJSON, AptosBlockTransactionsItemValue, AptosCoinInfoDto, AptosCoinInfoDtoInput, AptosCoinInfoDtoJSON, AptosCoinTransferDto, AptosCoinTransferDtoInput, AptosCoinTransferDtoJSON, AptosCurrentCoinBalanceDto, AptosCurrentCoinBalanceDtoInput, AptosCurrentCoinBalanceDtoJSON, AptosDecodedTableData, AptosDecodedTableDataInput, AptosDecodedTableDataJSON, AptosDeleteModuleChange, AptosDeleteModuleChangeInput, AptosDeleteModuleChangeJSON, AptosDeleteModuleChangeModule, AptosDeleteModuleChangeModuleInput, AptosDeleteModuleChangeModuleJSON, AptosDeleteModuleChangeModuleValue, AptosDeleteResourceChange, AptosDeleteResourceChangeInput, AptosDeleteResourceChangeJSON, AptosDeleteResourceChangeResource, AptosDeleteResourceChangeResourceInput, AptosDeleteResourceChangeResourceJSON, AptosDeleteResourceChangeResourceValue, AptosDeleteTableItemChange, AptosDeleteTableItemChangeHandle, AptosDeleteTableItemChangeHandleInput, AptosDeleteTableItemChangeHandleJSON, AptosDeleteTableItemChangeHandleValue, AptosDeleteTableItemChangeInput, AptosDeleteTableItemChangeJSON, AptosDeleteTableItemChangeKey, AptosDeleteTableItemChangeKeyInput, AptosDeleteTableItemChangeKeyJSON, AptosDeleteTableItemChangeKeyValue, AptosDeletedTableData, AptosDeletedTableDataInput, AptosDeletedTableDataJSON, AptosDirectWriteSet, AptosDirectWriteSetInput, AptosDirectWriteSetJSON, AptosEd25519SignatureRequest, AptosEd25519SignatureRequestInput, AptosEd25519SignatureRequestJSON, AptosEncodeSubmissionRequest, AptosEncodeSubmissionRequestInput, AptosEncodeSubmissionRequestJSON, AptosEncodeSubmissionRequestPayload, AptosEncodeSubmissionRequestPayloadInput, AptosEncodeSubmissionRequestPayloadJSON, AptosEncodeSubmissionRequestPayloadValue, AptosEntryFunctionPayloadRequest, AptosEntryFunctionPayloadRequestInput, AptosEntryFunctionPayloadRequestJSON, AptosEstimateGasPriceResult, AptosEstimateGasPriceResultInput, AptosEstimateGasPriceResultJSON, AptosGenericTypeParam, AptosGenericTypeParamInput, AptosGenericTypeParamJSON, AptosGenesisTransaction, AptosGenesisTransactionChangesItem, AptosGenesisTransactionChangesItemInput, AptosGenesisTransactionChangesItemJSON, AptosGenesisTransactionChangesItemValue, AptosGenesisTransactionInput, AptosGenesisTransactionJSON, AptosGetAccountModuleResponse, AptosGetAccountModuleResponseInput, AptosGetAccountModuleResponseJSON, AptosGetAccountResourceResponse, AptosGetAccountResourceResponseData, AptosGetAccountResourceResponseDataInput, AptosGetAccountResourceResponseDataJSON, AptosGetAccountResourceResponseDataValue, AptosGetAccountResourceResponseInput, AptosGetAccountResourceResponseJSON, AptosGetAccountResponse, AptosGetAccountResponseInput, AptosGetAccountResponseJSON, AptosGetAccountTransactionsItem, AptosGetAccountTransactionsItemInput, AptosGetAccountTransactionsItemJSON, AptosGetAccountTransactionsItemValue, AptosGetCoinBalancesByWalletsResponse, AptosGetCoinBalancesByWalletsResponseInput, AptosGetCoinBalancesByWalletsResponseJSON, AptosGetCoinTransfersByBlockHeightsResponse, AptosGetCoinTransfersByBlockHeightsResponseInput, AptosGetCoinTransfersByBlockHeightsResponseJSON, AptosGetCoinTransfersByCoinTypeResponse, AptosGetCoinTransfersByCoinTypeResponseInput, AptosGetCoinTransfersByCoinTypeResponseJSON, AptosGetCoinTransfersByOwnerAddressesResponse, AptosGetCoinTransfersByOwnerAddressesResponseInput, AptosGetCoinTransfersByOwnerAddressesResponseJSON, AptosGetCoinsByCreatorsResponse, AptosGetCoinsByCreatorsResponseInput, AptosGetCoinsByCreatorsResponseJSON, AptosGetCoinsByNameRangeResponse, AptosGetCoinsByNameRangeResponseInput, AptosGetCoinsByNameRangeResponseJSON, AptosGetCoinsBySymbolRangeResponse, AptosGetCoinsBySymbolRangeResponseInput, AptosGetCoinsBySymbolRangeResponseJSON, AptosGetEventsByCreationNumberResponse, AptosGetEventsByCreationNumberResponseData, AptosGetEventsByCreationNumberResponseDataInput, AptosGetEventsByCreationNumberResponseDataJSON, AptosGetEventsByCreationNumberResponseDataValue, AptosGetEventsByCreationNumberResponseInput, AptosGetEventsByCreationNumberResponseJSON, AptosGetEventsByEventHandleResponse, AptosGetEventsByEventHandleResponseData, AptosGetEventsByEventHandleResponseDataInput, AptosGetEventsByEventHandleResponseDataJSON, AptosGetEventsByEventHandleResponseDataValue, AptosGetEventsByEventHandleResponseInput, AptosGetEventsByEventHandleResponseJSON, AptosGetHistoricalCoinBalancesByWalletsResponse, AptosGetHistoricalCoinBalancesByWalletsResponseInput, AptosGetHistoricalCoinBalancesByWalletsResponseJSON, AptosGetLatestCoinsResponse, AptosGetLatestCoinsResponseInput, AptosGetLatestCoinsResponseJSON, AptosGetNFTTransfersByCollectionResponse, AptosGetNFTTransfersByCollectionResponseInput, AptosGetNFTTransfersByCollectionResponseJSON, AptosGetNFTTransfersByCreatorsResponse, AptosGetNFTTransfersByCreatorsResponseInput, AptosGetNFTTransfersByCreatorsResponseJSON, AptosGetTopHoldersByCoinResponse, AptosGetTopHoldersByCoinResponseInput, AptosGetTopHoldersByCoinResponseJSON, AptosGetTransactionByHash, AptosGetTransactionByHashInput, AptosGetTransactionByHashJSON, AptosGetTransactionByHashValue, AptosGetTransactionByVersion, AptosGetTransactionByVersionInput, AptosGetTransactionByVersionJSON, AptosGetTransactionByVersionValue, AptosGetTransactionsItem, AptosGetTransactionsItemInput, AptosGetTransactionsItemJSON, AptosGetTransactionsItemValue, AptosHistoricalCoinBalanceDto, AptosHistoricalCoinBalanceDtoInput, AptosHistoricalCoinBalanceDtoJSON, AptosModuleBundlePayloadRequest, AptosModuleBundlePayloadRequestInput, AptosModuleBundlePayloadRequestJSON, AptosModuleExposedFunction, AptosModuleExposedFunctionInput, AptosModuleExposedFunctionJSON, AptosModuleStruct, AptosModuleStructField, AptosModuleStructFieldInput, AptosModuleStructFieldJSON, AptosModuleStructInput, AptosModuleStructJSON, AptosMoveModuleAbi, AptosMoveModuleAbiInput, AptosMoveModuleAbiJSON, AptosMultiAgentSignatureRequest, AptosMultiAgentSignatureRequestInput, AptosMultiAgentSignatureRequestJSON, AptosMultiAgentSignatureRequestSecondarySigners, AptosMultiAgentSignatureRequestSecondarySignersInput, AptosMultiAgentSignatureRequestSecondarySignersJSON, AptosMultiAgentSignatureRequestSecondarySignersValue, AptosMultiAgentSignatureRequestSender, AptosMultiAgentSignatureRequestSenderInput, AptosMultiAgentSignatureRequestSenderJSON, AptosMultiAgentSignatureRequestSenderValue, AptosMultiEd25519SignatureRequest, AptosMultiEd25519SignatureRequestInput, AptosMultiEd25519SignatureRequestJSON, AptosNFTCollectionItemResponse, AptosNFTCollectionItemResponseInput, AptosNFTCollectionItemResponseJSON, AptosNFTCollectionsByCreatorResponse, AptosNFTCollectionsByCreatorResponseInput, AptosNFTCollectionsByCreatorResponseJSON, AptosNFTCollectionsByNameRangeResponse, AptosNFTCollectionsByNameRangeResponseInput, AptosNFTCollectionsByNameRangeResponseJSON, AptosNFTOwnerResponse, AptosNFTOwnerResponseInput, AptosNFTOwnerResponseJSON, AptosNFTOwnerResponseTokenProperties, AptosNFTOwnerResponseTokenPropertiesInput, AptosNFTOwnerResponseTokenPropertiesJSON, AptosNFTOwnerResponseTokenPropertiesValue, AptosNFTOwnersByCollectionResponse, AptosNFTOwnersByCollectionResponseInput, AptosNFTOwnersByCollectionResponseJSON, AptosNFTOwnersByTokensResponse, AptosNFTOwnersByTokensResponseInput, AptosNFTOwnersByTokensResponseJSON, AptosNFTOwnersOfCollectionResponse, AptosNFTOwnersOfCollectionResponseInput, AptosNFTOwnersOfCollectionResponseJSON, AptosNFTTokenResponse, AptosNFTTokenResponseDefaultProperties, AptosNFTTokenResponseDefaultPropertiesInput, AptosNFTTokenResponseDefaultPropertiesJSON, AptosNFTTokenResponseDefaultPropertiesValue, AptosNFTTokenResponseInput, AptosNFTTokenResponseJSON, AptosNFTTokensByCollectionResponse, AptosNFTTokensByCollectionResponseInput, AptosNFTTokensByCollectionResponseJSON, AptosNFTTokensByCreatorsResponse, AptosNFTTokensByCreatorsResponseInput, AptosNFTTokensByCreatorsResponseJSON, AptosNFTTransferResponse, AptosNFTTransferResponseInput, AptosNFTTransferResponseJSON, AptosNFTTransfersByTokensResponse, AptosNFTTransfersByTokensResponseInput, AptosNFTTransfersByTokensResponseJSON, AptosNFTTransfersByWalletsResponse, AptosNFTTransfersByWalletsResponseInput, AptosNFTTransfersByWalletsResponseJSON, AptosNFTsByOwnersResponse, AptosNFTsByOwnersResponseInput, AptosNFTsByOwnersResponseJSON, AptosNative, AptosNativeInput, AptosNativeJSON, AptosNativeUnit, AptosNetwork, AptosNetworkInput, AptosNetworkJSON, AptosNetworkName, AptosNetworkResolver, AptosPendingTransaction, AptosPendingTransactionInput, AptosPendingTransactionJSON, AptosPendingTransactionPayload, AptosPendingTransactionPayloadInput, AptosPendingTransactionPayloadJSON, AptosPendingTransactionPayloadValue, AptosPendingTransactionSignature, AptosPendingTransactionSignatureInput, AptosPendingTransactionSignatureJSON, AptosPendingTransactionSignatureValue, AptosScriptPayloadRequest, AptosScriptPayloadRequestCode, AptosScriptPayloadRequestCodeInput, AptosScriptPayloadRequestCodeJSON, AptosScriptPayloadRequestCodeValue, AptosScriptPayloadRequestInput, AptosScriptPayloadRequestJSON, AptosScriptWriteSet, AptosScriptWriteSetInput, AptosScriptWriteSetJSON, AptosSimulateTransaction, AptosSimulateTransactionInput, AptosSimulateTransactionJSON, AptosSimulateTransactionValue, AptosStateCheckpointTransaction, AptosStateCheckpointTransactionChangesItem, AptosStateCheckpointTransactionChangesItemInput, AptosStateCheckpointTransactionChangesItemJSON, AptosStateCheckpointTransactionChangesItemValue, AptosStateCheckpointTransactionInput, AptosStateCheckpointTransactionJSON, AptosSubmitBatchTransactionResult, AptosSubmitBatchTransactionResultInput, AptosSubmitBatchTransactionResultJSON, AptosSubmitTransactionRequest, AptosSubmitTransactionRequestInput, AptosSubmitTransactionRequestJSON, AptosSubmitTransactionRequestPayload, AptosSubmitTransactionRequestPayloadInput, AptosSubmitTransactionRequestPayloadJSON, AptosSubmitTransactionRequestPayloadValue, AptosSubmitTransactionRequestSignature, AptosSubmitTransactionRequestSignatureInput, AptosSubmitTransactionRequestSignatureJSON, AptosSubmitTransactionRequestSignatureValue, AptosTransactionEvent, AptosTransactionEventData, AptosTransactionEventDataInput, AptosTransactionEventDataJSON, AptosTransactionEventDataValue, AptosTransactionEventGuid, AptosTransactionEventGuidInput, AptosTransactionEventGuidJSON, AptosTransactionEventInput, AptosTransactionEventJSON, AptosUserTransaction, AptosUserTransactionChangesItem, AptosUserTransactionChangesItemInput, AptosUserTransactionChangesItemJSON, AptosUserTransactionChangesItemValue, AptosUserTransactionInput, AptosUserTransactionJSON, AptosUserTransactionPayload, AptosUserTransactionPayloadInput, AptosUserTransactionPayloadJSON, AptosUserTransactionPayloadValue, AptosUserTransactionSignature, AptosUserTransactionSignatureInput, AptosUserTransactionSignatureJSON, AptosUserTransactionSignatureValue, AptosWriteModuleData, AptosWriteModuleDataInput, AptosWriteModuleDataJSON, AptosWriteOrUpdateModuleChange, AptosWriteOrUpdateModuleChangeInput, AptosWriteOrUpdateModuleChangeJSON, AptosWriteResourceChange, AptosWriteResourceChangeInput, AptosWriteResourceChangeJSON, AptosWriteResourceData, AptosWriteResourceDataData, AptosWriteResourceDataDataInput, AptosWriteResourceDataDataJSON, AptosWriteResourceDataDataValue, AptosWriteResourceDataInput, AptosWriteResourceDataJSON, AptosWriteSetPayload, AptosWriteSetPayloadInput, AptosWriteSetPayloadJSON, AptosWriteSetPayloadWriteSet, AptosWriteSetPayloadWriteSetInput, AptosWriteSetPayloadWriteSetJSON, AptosWriteSetPayloadWriteSetValue, AptosWriteTableChangeSetChange, AptosWriteTableChangeSetChangeInput, AptosWriteTableChangeSetChangeJSON, CommonAptosUtils, CommonAptosUtilsConfig, CommonAptosUtilsConfigSetup, EncodeSubmissionOperation, EncodeSubmissionOperationRequest, EncodeSubmissionOperationRequestJSON, EstimateGasPriceOperation, EstimateGasPriceOperationRequest, EstimateGasPriceOperationRequestJSON, GetAccountModuleOperation, GetAccountModuleOperationRequest, GetAccountModuleOperationRequestJSON, GetAccountModulesOperation, GetAccountModulesOperationRequest, GetAccountModulesOperationRequestJSON, GetAccountOperation, GetAccountOperationRequest, GetAccountOperationRequestJSON, GetAccountResourceOperation, GetAccountResourceOperationRequest, GetAccountResourceOperationRequestJSON, GetAccountResourcesOperation, GetAccountResourcesOperationRequest, GetAccountResourcesOperationRequestJSON, GetAccountTransactionsOperation, GetAccountTransactionsOperationRequest, GetAccountTransactionsOperationRequestJSON, GetBlockByHeightOperation, GetBlockByHeightOperationRequest, GetBlockByHeightOperationRequestJSON, GetBlockByVersionOperation, GetBlockByVersionOperationRequest, GetBlockByVersionOperationRequestJSON, GetCoinBalancesByWalletsOperation, GetCoinBalancesByWalletsOperationRequest, GetCoinBalancesByWalletsOperationRequestJSON, GetCoinInfoByCoinTypeHashesOperation, GetCoinInfoByCoinTypeHashesOperationRequest, GetCoinInfoByCoinTypeHashesOperationRequestJSON, GetCoinTransfersByBlockHeightsOperation, GetCoinTransfersByBlockHeightsOperationRequest, GetCoinTransfersByBlockHeightsOperationRequestJSON, GetCoinTransfersByCoinTypeOperation, GetCoinTransfersByCoinTypeOperationRequest, GetCoinTransfersByCoinTypeOperationRequestJSON, GetCoinTransfersByOwnerAddressesOperation, GetCoinTransfersByOwnerAddressesOperationRequest, GetCoinTransfersByOwnerAddressesOperationRequestJSON, GetCoinTransfersByWalletAddressesOperation, GetCoinTransfersByWalletAddressesOperationRequest, GetCoinTransfersByWalletAddressesOperationRequestJSON, GetCoinsByCreatorsOperation, GetCoinsByCreatorsOperationRequest, GetCoinsByCreatorsOperationRequestJSON, GetCoinsByNameRangeOperation, GetCoinsByNameRangeOperationRequest, GetCoinsByNameRangeOperationRequestJSON, GetCoinsBySymbolRangeOperation, GetCoinsBySymbolRangeOperationRequest, GetCoinsBySymbolRangeOperationRequestJSON, GetEventsByCreationNumberOperation, GetEventsByCreationNumberOperationRequest, GetEventsByCreationNumberOperationRequestJSON, GetEventsByEventHandleOperation, GetEventsByEventHandleOperationRequest, GetEventsByEventHandleOperationRequestJSON, GetHistoricalCoinBalancesByWalletsOperation, GetHistoricalCoinBalancesByWalletsOperationRequest, GetHistoricalCoinBalancesByWalletsOperationRequestJSON, GetLatestCoinsOperation, GetLatestCoinsOperationRequest, GetLatestCoinsOperationRequestJSON, GetNFTByOwnersOperation, GetNFTByOwnersOperationRequest, GetNFTByOwnersOperationRequestJSON, GetNFTCollectionsByCreatorOperation, GetNFTCollectionsByCreatorOperationRequest, GetNFTCollectionsByCreatorOperationRequestJSON, GetNFTCollectionsByIdsOperation, GetNFTCollectionsByIdsOperationRequest, GetNFTCollectionsByIdsOperationRequestJSON, GetNFTCollectionsOperation, GetNFTCollectionsOperationRequest, GetNFTCollectionsOperationRequestJSON, GetNFTOwnersByCollectionOperation, GetNFTOwnersByCollectionOperationRequest, GetNFTOwnersByCollectionOperationRequestJSON, GetNFTOwnersByTokensOperation, GetNFTOwnersByTokensOperationRequest, GetNFTOwnersByTokensOperationRequestJSON, GetNFTOwnersOfCollectionOperation, GetNFTOwnersOfCollectionOperationRequest, GetNFTOwnersOfCollectionOperationRequestJSON, GetNFTTransfersByCollectionOperation, GetNFTTransfersByCollectionOperationRequest, GetNFTTransfersByCollectionOperationRequestJSON, GetNFTTransfersByCreatorsOperation, GetNFTTransfersByCreatorsOperationRequest, GetNFTTransfersByCreatorsOperationRequestJSON, GetNFTTransfersByIdsOperation, GetNFTTransfersByIdsOperationRequest, GetNFTTransfersByIdsOperationRequestJSON, GetNFTTransfersByWalletsOperation, GetNFTTransfersByWalletsOperationRequest, GetNFTTransfersByWalletsOperationRequestJSON, GetNFTsByCollectionOperation, GetNFTsByCollectionOperationRequest, GetNFTsByCollectionOperationRequestJSON, GetNFTsByCreatorsOperation, GetNFTsByCreatorsOperationRequest, GetNFTsByCreatorsOperationRequestJSON, GetNFTsByIdsOperation, GetNFTsByIdsOperationRequest, GetNFTsByIdsOperationRequestJSON, GetTopHoldersByCoinOperation, GetTopHoldersByCoinOperationRequest, GetTopHoldersByCoinOperationRequestJSON, GetTransactionByHashOperation, GetTransactionByHashOperationRequest, GetTransactionByHashOperationRequestJSON, GetTransactionByVersionOperation, GetTransactionByVersionOperationRequest, GetTransactionByVersionOperationRequestJSON, GetTransactionsOperation, GetTransactionsOperationRequest, GetTransactionsOperationRequestJSON, GetWalletsNFTTransfersOperation, GetWalletsNFTTransfersOperationRequest, GetWalletsNFTTransfersOperationRequestJSON, OperationV3, SimulateTransactionOperation, SimulateTransactionOperationRequest, SimulateTransactionOperationRequestJSON, SubmitBatchTransactionsOperation, SubmitBatchTransactionsOperationRequest, SubmitBatchTransactionsOperationRequestJSON, SubmitTransactionOperation, SubmitTransactionOperationRequest, SubmitTransactionOperationRequestJSON, operations };
