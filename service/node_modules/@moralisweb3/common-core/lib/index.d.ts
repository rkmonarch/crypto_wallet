import { AxiosRequestConfig, AxiosError, AxiosResponse } from 'axios';

declare class Config {
    private readonly items;
    registerKey<Value>(key: ConfigKey<Value>, validator?: ConfigKeyValidator<Value>): void;
    getKeys(): string[];
    hasKey<Value>(key: ConfigKey<Value>): boolean;
    get<Value>(keyOrName: ConfigKey<Value> | string): Value;
    set<Value>(keyOrName: ConfigKey<Value> | string, value: Value): void;
    merge(values: ConfigValues): void;
    reset(): void;
    private getItem;
}
type ConfigKeyValidator<Value> = (value: Value) => string | null;
interface ConfigValues {
    [keyName: string]: any;
}
interface ConfigKey<Value> {
    name: string;
    defaultValue: Value;
}

type LogLevel = 'verbose' | 'debug' | 'info' | 'warning' | 'error' | 'off';
type BuildEnvironment = 'browser' | 'node' | 'react-native';
type EvmConnector = string;
type Network = 'Evm' | 'Solana' | 'Aptos';
declare const CoreConfig: {
    logLevel: ConfigKey<LogLevel>;
    buidEnvironment: ConfigKey<BuildEnvironment>;
    defaultNetwork: ConfigKey<Network>;
    product: ConfigKey<string | undefined>;
    /**
     * @description Maximal number of request retries.
     */
    maxRetries: ConfigKey<number>;
};

/**
 * Note this is just an interface, used in the core config.
 * The implementations are located in the @moralisweb3/common-sol-utils package.
 */
declare const solNetworkNames: readonly ["mainnet", "devnet"];
type SolNetworkName = typeof solNetworkNames[number];
interface SolNetworkable {
    network: SolNetworkName;
}
type SolNetworkish = SolNetworkable | string;

/**
 * Note this is just an interface, used in the core config.
 * The implementations are located in the @moralisweb3/common-evm-utils package.
 */
interface EvmChainable {
    decimal: number;
    hex: string;
    apiHex: string;
}
type EvmChainish = EvmChainable | string | number;

type CoreConfigType = typeof CoreConfig;
type CoreConfigValues = Omit<{
    [Key in keyof CoreConfigType]: CoreConfigType[Key]['defaultValue'];
}, 'product'>;
interface EvmUtilsConfigValues {
    defaultEvmApiChain: EvmChainish;
}
interface EvmApiConfigValues {
    evmApiBaseUrl: string;
}
interface SolApiConfigValues {
    defaultSolNetwork: SolNetworkish;
    solApiBaseUrl: string;
}
type MoralisCoreConfigValues = CoreConfigValues | EvmUtilsConfigValues | EvmApiConfigValues | SolApiConfigValues | {
    [key: string]: string | number;
};

type Details = Record<string, unknown>;
/**
 * LoggerController, responsible to create log messages for each module.
 * It should be created with the name of the module like `new Logger('module-name')`
 * It will then prefix any logs with that module-name for easy debugging
 * It will show only logs up to the specified `logLevel` in the MoralisConfig
 */
declare class LoggerController {
    private readonly moduleName;
    private readonly config;
    static create(moduleName: string, core: Core): LoggerController;
    constructor(moduleName: string, config: Config);
    get level(): LogLevel;
    private _transport;
    private _shouldLog;
    _makeLogMessage(message: string): string;
    error(error: Error | string, details?: Details): void;
    warn(message: string, details?: Details): void;
    info(message: string, details?: Details): void;
    debug(message: string, details?: Details): void;
    verbose(message: string, details?: Details): void;
}

declare enum ModuleType {
    API = "api",
    DEFAULT = "default"
}

/**
 * The base class of every Moralis class that gets registered as a module via MoralisModules
 * It should always be created with:
 * - `name`: name of the module (should be unique)
 * - `core`: the Core instance
 * - `type`: (optional) CoreModuleType, defaults to CoreModuleType.DEFAULT
 *
 * When creating an api, or network module, you should use the ApiModule or NetworkModule
 */
declare abstract class Module {
    readonly name: string;
    protected readonly core: Core;
    readonly type: ModuleType;
    protected readonly logger: LoggerController;
    constructor(name: string, core: Core, type?: ModuleType);
    abstract setup(): void;
    /**
     * Start the module (if needed).
     * This function can be used to initialize variables etc.
     */
    abstract start(): void | Promise<void>;
    /**
     * Any cleanup that needs to be done for removing this module.
     * It also should remove the module via `this.core.modules.remove(this.name)`
     */
    cleanUp(): void;
}
interface ModuleFactory {
    create(core: Core): Module;
}

/**
 * The base class of every Moralis Api class that gets registered as a module via MoralisModules
 * It should always be created with:
 * - `name`: name of the module (should be unique)
 * - `core`: the Core instance
 * - `baseUrlProvider`: the provider of the base URL.
 */
declare abstract class ApiModule extends Module {
    private readonly baseUrlProvider;
    private _baseUrl?;
    /**
     * @description The base URL of the API.
     */
    get baseUrl(): string;
    constructor(name: string, core: Core, baseUrlProvider: () => string);
}

type AnyBaseClass = Module | ApiModule;

/**
 * MoralisModues handles all registered modules.
 * Any package that is used in Moralis, should register itself via this class.
 * This allows cross-communication between modules and easy management of the modules
 *
 * This class is responsible for:
 * - registering new modules
 * - removing modules (in theory possible for exotic usecases, but might break the app if done after initialisation)
 * - getting individual modules by name, type or everything
 */
declare class Modules {
    private readonly modules;
    /**
     * Register and setup a new module by providing a module that is extended from BaseClass.
     * This will throw an error if the name is not unique
     * @param module the module that needs to be registered
     */
    register(module: AnyBaseClass): void;
    /**
     * Returns the module with the given name.
     * This module should have been registered with `register`
     * @param name the module name
     * @returns a valid BaseModule
     * @throws a CoreError if no module with the given name has been registered
     */
    get<CurrentModule extends Module = Module>(name: string): CurrentModule;
    /**
     * Tries to return the module with the given name if exist. Otherwise returns null.
     * @param name the module name
     * @returns a valid BaseModule or null
     */
    tryGet(name: string): Module | null;
    has(name: string): boolean;
    /**
     * Returns the network module with the provided name.
     * @param name the module name
     * @returns a valid ApiModule
     * @throws a CoreError if no network module with the given name has been registered
     */
    getApi(name: string): ApiModule;
    /**
     * Remove the module with the provided name, if it has been registered,
     * @param name the module name
     * @throws a CoreError if the module cannot be found.
     */
    remove(name: string): void;
    /**
     * List all the registered modules
     * @returns an array of BaseModule that have been registered
     */
    list(): Module[];
    /**
     * Returns the names of all registered modules
     */
    listNames(): string[];
    /**
     * List all the registered api modules (eg. modules with the type CoreModuleType.API)
     */
    listApis(): ApiModule[];
}

type Primitive = null | undefined | string | number | boolean | Date;
type MoralisDataObjectValue = {
    [key: string]: Primitive | MoralisDataObjectValue | Primitive[] | (Primitive | Primitive[])[] | MoralisDataObjectValue[] | ArrayLike<Primitive> | ArrayLike<MoralisDataObjectValue> | Record<string, MoralisDataObjectValue> | Array<[string, MoralisDataObjectValue]> | [string, Primitive[]][];
} | MoralisDataObjectValue[];
type MoralisDataFormatted = Primitive | MoralisDataObjectValue;

/**
 * The MoralisData class represents the value of a native currency (like ETH, SOL, BNB etc.)
 *
 * @internal
 * @category DataType
 */
declare abstract class MoralisData {
    abstract format(style?: unknown): MoralisDataFormatted;
    abstract equals(value: this): boolean;
}

declare abstract class MoralisDataObject extends MoralisData {
    abstract toJSON(): MoralisDataObjectValue;
}

/**
 * Valid input types for a BigNumber. This can be a number, string, or bigint.
 */
type BigNumberPrimitive = number | string | bigint;

/**
 * Valid input for a new BigNumber instance.
 * This can be an existing {@link BigNumber} or a valid {@link BigNumberPrimitive} type
 */
type BigNumberish = BigNumberInput;
type BigNumberInput = BigNumber | BigNumberPrimitive;
type BigNumberJSON = string;
/**
 * The BigNumber class is a MoralisData that references to a the value of a BigNumber
 *
 * @category DataType
 */
declare class BigNumber {
    private readonly value;
    /**
     * Create a new instance of BigNumber from any valid address input.
     *
     * @param value - the BigNumberish type
     * @example BigNumber.create(12);
     * @example BigNumber.create("20");
     * @returns a new BigNumber instance
     */
    static create(value: BigNumberish): BigNumber;
    static fromJSON(json: BigNumberJSON): BigNumber;
    private constructor();
    /**
     * Creates a new BigNumber from given decimals.
     * @param value
     * @param decimals - This is optional and defaults to 0
     * @example BigNumber.fromDecimal("1.23456789", 18);
     */
    static fromDecimal(value: BigNumberPrimitive, decimals?: number): BigNumber;
    /**
     * @returns the value of this BigNumber as a BigInt
     * @example BigNumber.create(12).toBigInt();
     */
    toBigInt(): bigint;
    /**
     * Adds a BigNumber to current BigNumber instance.
     * @param value - the BigNumberish to add
     * @returns the result of the addition
     * @example BigNumber.create(12).add(7);
     * @example BigNumber.create(12).add("1000000000000000000");
     */
    add(value: BigNumberish): BigNumber;
    /**
     * Subtracts a BigNumber from current BigNumber instance.
     * @param value - the BigNumberish to subtract
     * @returns the result of the subtraction
     * @example BigNumber.create(12).sub(7);
     * @example BigNumber.create("1000000000000000000").sub(20);
     */
    sub(value: BigNumberish): BigNumber;
    /**
     * Multiplies a BigNumber with current BigNumber instance.
     * @param value - the BigNumberish to multiply
     * @returns the result of the multiplication
     * @example BigNumber.create(12).mul(7);
     * @example BigNumber.create(12).mul("1000000000000000000");
     */
    mul(value: BigNumberish): BigNumber;
    /**
     * Divides a BigNumber with current BigNumber instance.
     * @param value - the BigNumberish to divide
     * @returns the result of the division
     * @example BigNumber.create(12).div(7);
     * @example BigNumber.create(1).div("1000000000000000000");
     */
    div(value: BigNumberish): BigNumber;
    /**
     * Checks the equality of the current BigNumber with another BigNumber.
     * @param value - the BigNumberish to compare
     * @returns true if the BigNumbers are equal
     * @example BigNumber.create(12).equals(BigNumber.create(12)); // true
     */
    equals(value: BigNumber): boolean;
    /**
     * Converts BigNumber instance to value in given decimals.
     * @param decimals - The decimals to convert to
     * @example BigNumber.create(12).toDecimal(18);
     */
    toDecimal(decimals: number): string;
    /**
     * Converts BigNumber instance to string.
     * @example BigNumber.create(12).toString();
     */
    toString(): string;
    /**
     * Converts BigNumber instance to hex string.
     * @example BigNumber.create(12).toHex();
     */
    toHex(): string;
    /**
     * Converts BigNumber instance to hex string.
     * @example BigNumber.create(12).toJSON();
     */
    toJSON(): string;
}

type DateInput = string | Date;
declare const dateInputToDate: (value: DateInput) => Date;

/**
 * Core is used in all Moralis applications
 * This class is **required** to be implemented in every app
 *
 * This class is responsible for:
 * - registering, removing and accessing modules
 * - accessing and changing the config
 */
declare class Core {
    readonly modules: Modules;
    readonly config: Config;
    readonly logger: LoggerController;
    static readonly moduleName = "core";
    static create(): Core;
    readonly name = "core";
    private _isStarted;
    get isStarted(): boolean;
    static readonly libVersion = "2.22.1";
    constructor(modules: Modules, config: Config, logger: LoggerController);
    /**
     * Register all specified modules and configurations
     * @params array of all modules (any module that is extended from BaseModule) that you want to include
     */
    registerModules: (modules: (Module | ModuleFactory)[]) => void;
    /**
     * Register a new module
     */
    registerModule: (module: Module | ModuleFactory) => void;
    getModule: <CurrentModule extends Module = Module>(name: string) => CurrentModule;
    /**
     * Start all modules, this function should be called before any interaction with a module,
     * as it is responsible for initialising the modules.
     *
     * This will call `start()` on every registered module
     */
    start: (providedConfig?: Partial<MoralisCoreConfigValues>) => Promise<void>;
    get BigNumber(): typeof BigNumber;
}

declare class CoreProvider {
    private static core?;
    static getDefault(): Core;
    static setDefault(core: Core): void;
}

/**
 * Verify if the provided class is a api type.
 * Should be used as a Typescript type-guard
 *
 * @example
 * ```
 * if(isApiModule(module)){
 *  // module is types as ApiModule here
 * }
 * ```
 */
declare const isApiModule: (moralisClass: Module) => moralisClass is ApiModule;

declare enum CoreErrorCode {
    GENERIC_CORE_ERROR = "C0001",
    DUPLICATE_MODULE = "C0002",
    MODULE_NOT_FOUND = "C0003",
    VALIDATION_ERROR = "C0004",
    INVALID_ARGUMENT = "C0005",
    REQUEST_ERROR = "C0006",
    NO_DATA_FOUND = "C0007",
    NOT_INITIALIZED = "C0008",
    ALREADY_INITIALIZED = "C0009",
    METHOD_FAILED = "C0010",
    STATE_MACHINE_STARTED = "C0011",
    STATE_MACHINE_NOT_STARTED = "C0012",
    CONFIG_KEY_NOT_EXIST = "C0013",
    CONFIG_INVALID_VALUE = "C0014",
    CONFIG_KEY_ALREADY_EXIST = "C0015",
    INVALID_DATA = "C0016",
    BIG_NUMBER_ERROR = "C0500",
    NOT_IMPLEMENTED = "C9000"
}
declare enum ApiErrorCode {
    GENERIC_API_ERROR = "A0001",
    PAGE_LIMIT_EXCEEDED = "A0002",
    API_KEY_NOT_SET = "A0003",
    INVALID_PARAMS = "A0004",
    NOT_FOUND = "A0404",
    NOT_IMPLEMENTED = "A9000"
}
declare enum AuthErrorCode {
    GENERIC_AUTH_ERROR = "U0001",
    INCORRECT_NETWORK = "U0002",
    INCORRECT_PARAMETER = "U0003",
    NOT_IMPLEMENTED = "U9000"
}
declare enum StreamErrorCode {
    GENERIC_STREAM_ERROR = "S0001",
    INCORRECT_NETWORK = "S0002",
    INCORRECT_PARAMETER = "S0003",
    INVALID_SIGNATURE = "S0004",
    NOT_IMPLEMENTED = "S9000"
}
type MoralisErrorCode = CoreErrorCode | ApiErrorCode | AuthErrorCode | StreamErrorCode;

type MoralisErrorDetails = Record<string, unknown>;
interface MoralisErrorOptions<ErrorCode extends MoralisErrorCode> {
    message: string;
    code: ErrorCode;
    details?: MoralisErrorDetails;
    cause?: Error;
}
declare class MoralisError extends Error {
    readonly name: string;
    readonly code: MoralisErrorCode;
    readonly details?: MoralisErrorDetails;
    readonly cause?: Error | MoralisError;
    readonly isMoralisError = true;
    private static makeMessage;
    constructor({ message, code, details, cause }: MoralisErrorOptions<MoralisErrorCode>);
}
declare class CoreError extends MoralisError {
    readonly name: string;
    constructor(options: MoralisErrorOptions<CoreErrorCode>);
}
declare class MoralisApiError extends MoralisError {
    readonly name: string;
    constructor(options: MoralisErrorOptions<ApiErrorCode>);
}
declare class MoralisAuthError extends MoralisError {
    readonly name: string;
    constructor(options: MoralisErrorOptions<AuthErrorCode>);
}
declare class MoralisStreamError extends MoralisError {
    readonly name: string;
    constructor(options: MoralisErrorOptions<StreamErrorCode>);
}

declare const isMoralisError: (error: unknown) => error is MoralisError;

declare const UnreachableError: CoreError;
/**
 * Typesafe check, to make sure that code never reaches a certain point.
 * Can be used as an exhaustive check in swtich/if-else statements
 *
 * When used properly with Typescript, this code should never reach, as it is typed as 'never'
 *
 * If the code does reach this assertion an UnreachableError is thrown
 */
declare const assertUnreachable: (x: never) => never;

interface RequestOptions {
    headers?: {
        [name: string]: string;
    };
}
/**
 * A controller responsible to handle all requests in Moralis,
 * compatible with browser, nodejJs and react-native
 */
declare class RequestController {
    private readonly config;
    private readonly logger;
    static create(core: Core): RequestController;
    private constructor();
    request<Data, Response>(config: AxiosRequestConfig<Data>): Promise<Response>;
    private makeError;
    post<Response, Body>(url: string, searchParams?: Record<string, unknown>, body?: Body, options?: RequestOptions, abortSignal?: AbortController['signal']): Promise<Response>;
    put<Response, Body>(url: string, searchParams?: Record<string, unknown>, body?: Body, options?: RequestOptions, abortSignal?: AbortController['signal']): Promise<Response>;
    get<Response>(url: string, searchParams?: Record<string, unknown>, options?: RequestOptions, abortSignal?: AbortController['signal']): Promise<Response>;
    delete<Response, Body>(url: string, searchParams?: Record<string, unknown>, body?: Body, options?: RequestOptions, abortSignal?: AbortController['signal']): Promise<Response>;
}

interface AxiosRetryConfig {
    maxRetries: number;
    allowedMethods: string[];
    allowedResponseStatuses: number[];
    beforeRetry?: (attempt: number, error: AxiosError) => void;
}
declare class AxiosRetry {
    static request<Data, Response>(retryConfig: AxiosRetryConfig, requestConfig: AxiosRequestConfig<Data>): Promise<AxiosResponse<Response>>;
}

interface Operation<Request, JSONRequest, Response, JSONResponse> {
    name: string;
    id: string;
    groupName: string;
    method: OperationRequestMethod;
    urlPathPattern: string;
    urlPathParamNames?: (keyof Request)[];
    urlSearchParamNames?: (keyof Request)[];
    bodyType?: OperationBodyType;
    bodyParamNames?: (keyof Request)[];
    isNullable?: boolean;
    firstPageIndex?: number;
    getRequestUrlParams(request: Request, core: Core): OperationRequestUrlParams;
    getRequestBody?(request: Request, core: Core): OperationRequestBody;
    deserializeResponse(jsonResponse: JSONResponse, request: Request, core: Core): Response;
    serializeRequest(request: Request, core: Core): JSONRequest;
    deserializeRequest(jsonRequest: JSONRequest, core: Core): Request;
}
type OperationRequestMethod = 'GET' | 'POST' | 'PUT' | 'DELETE';
type OperationBodyType = 'properties' | 'raw';
type OperationRequestUrlParams = Record<string, string | string[] | boolean | undefined>;
type OperationRequestBody = OperationRequestPropertiesBody | OperationRequestRawBody;
type OperationRequestPropertiesBody = Record<string, unknown>;
type OperationRequestRawBody = string | number | boolean | object;
type UnknownOperation = Operation<unknown, unknown, unknown, unknown>;

interface PaginatedRequest {
    offset?: number;
    limit?: number;
    cursor?: string;
}
interface PaginatedJSONResponse<JSONResult> {
    total?: number;
    page?: number;
    page_size?: number;
    cursor?: string;
    result: JSONResult;
}
interface PaginatedOperation<Request extends PaginatedRequest, JSONRequest, Response, JSONResult> extends Operation<Request, JSONRequest, Response, PaginatedJSONResponse<JSONResult>> {
    firstPageIndex: number;
}

declare class OperationRequestValidator<Request> {
    private readonly allParamNames;
    constructor(operation: Operation<Request, unknown, unknown, unknown>);
    validate(request: Request): void;
}

declare enum OperationType {
    NON_NULLABLE = "nonNullable",
    NULLABLE = "nullable",
    PAGINATED = "paginated"
}
declare function determineOperationType(operation: Operation<unknown, unknown, unknown, unknown>): OperationType;

interface OperationV3<Request, RequestJSON, Response, ResponseJSON, Body, BodyJSON> {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    serializeRequest?: (request: Request) => RequestJSON;
    parseResponse?: (json: ResponseJSON) => Response;
    serializeBody?: (body: Body) => BodyJSON;
}

interface Pagination {
    total?: number;
    page: number;
    pageSize: number;
    cursor?: string;
}

declare class NextPaginatedRequestResolver {
    static resolve<Request extends PaginatedRequest>(firstPageIndex: number, request: Request, pagination: Pagination): Request | null;
}

declare class PaginationReader {
    static read(jsonResponse: PaginatedJSONResponse<unknown>): Pagination;
}

declare class ResponseAdapter<Response, JSONResponse> {
    private readonly jsonResponse;
    private readonly getResponse;
    constructor(jsonResponse: JSONResponse, getResponse: () => Response);
    get result(): Response;
    get raw(): JSONResponse;
    toJSON(): JSONResponse;
}

declare class PaginatedResponseAdapter<Result, JSONResult> {
    readonly pagination: Pagination;
    private readonly jsonResponse;
    private readonly getResult;
    private readonly nextHandler;
    constructor(pagination: Pagination, jsonResponse: PaginatedJSONResponse<JSONResult>, getResult: () => Result, nextHandler: (() => Promise<PaginatedResponseAdapter<Result, JSONResult>>) | undefined);
    get result(): Result;
    get raw(): PaginatedJSONResponse<JSONResult>;
    toJSON(): PaginatedJSONResponse<JSONResult>;
    readonly hasNext: () => boolean;
    next: () => Promise<PaginatedResponseAdapter<Result, JSONResult>>;
}

type CamelCase<Input extends string> = Input extends `${infer P1}_${infer P2}${infer P3}` ? `${P1}${Uppercase<P2>}${CamelCase<P3>}` : Input;
type Camelize<Data> = {
    [Key in keyof Data as CamelCase<string & Key>]: Data[Key] extends Array<infer Value> ? Value extends {} ? Array<Camelize<Value>> : Data[Key] : Data[Key] extends {} ? Camelize<Data[Key]> : Data[Key];
};
declare const toCamel: (value: string) => string;
declare const toCamelCase: <Data extends object>(data: Data) => Camelize<Data>;

/**
 * Converts `null` or `undefined` values to `undefined`
 * Optionally, the value gets transformed by the second argument
 */
declare function maybe<Value>(value: Value | null | undefined): Value | undefined;
declare function maybe<Value, Output>(value: Value | null | undefined, transform: (value: Value) => Output): Output | undefined;

export { AnyBaseClass, ApiErrorCode, ApiModule, AuthErrorCode, AxiosRetry, AxiosRetryConfig, BigNumber, BigNumberInput, BigNumberJSON, BigNumberPrimitive, BigNumberish, BuildEnvironment, Camelize, Config, ConfigKey, ConfigKeyValidator, ConfigValues, Core, CoreConfig, CoreConfigValues, CoreError, CoreErrorCode, CoreProvider, DateInput, EvmApiConfigValues, EvmChainable, EvmChainish, EvmConnector, EvmUtilsConfigValues, LogLevel, LoggerController, Module, ModuleFactory, ModuleType, Modules, MoralisApiError, MoralisAuthError, MoralisCoreConfigValues, MoralisData, MoralisDataFormatted, MoralisDataObject, MoralisDataObjectValue, MoralisError, MoralisErrorCode, MoralisErrorDetails, MoralisErrorOptions, MoralisStreamError, Network, NextPaginatedRequestResolver, Operation, OperationBodyType, OperationRequestBody, OperationRequestMethod, OperationRequestPropertiesBody, OperationRequestRawBody, OperationRequestUrlParams, OperationRequestValidator, OperationType, OperationV3, PaginatedJSONResponse, PaginatedOperation, PaginatedRequest, PaginatedResponseAdapter, Pagination, PaginationReader, RequestController, RequestOptions, ResponseAdapter, SolApiConfigValues, SolNetworkName, SolNetworkable, SolNetworkish, StreamErrorCode, UnknownOperation, UnreachableError, assertUnreachable, dateInputToDate, determineOperationType, isApiModule, isMoralisError, maybe, solNetworkNames, toCamel, toCamelCase };
