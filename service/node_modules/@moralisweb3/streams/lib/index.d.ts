import { IWebhook, IERC20Transfer, Block, IERC20Approval, InternalTransaction, AbiItem, Log, INFTTransfer, INFTApproval, Transaction } from '@moralisweb3/streams-typings';
import * as streamsTypings from '@moralisweb3/streams-typings';
export { streamsTypings as Types };
import * as _moralisweb3_common_evm_utils from '@moralisweb3/common-evm-utils';
import * as _moralisweb3_common_core from '@moralisweb3/common-core';
import { ApiModule, Core } from '@moralisweb3/common-core';
import * as _moralisweb3_common_streams_utils from '@moralisweb3/common-streams-utils';
import { DeleteAddressEvmRequest, DeleteAddressAptosRequest, DeleteAddressAptosResponseAdapter, DeleteAddressEvmResponseAdapter, GetAddressesEvmRequest, GetAddressesAptosRequest, GetAddressesAptosResponseAdapter, GetAddressesEvmResponseAdapter, AddAddressEvmRequest, AddAddressAptosRequest, AddAddressAptosResponseAdapter, AddAddressEvmResponseAdapter, UpdateStreamStatusEvmRequest, UpdateStreamStatusAptosRequest, UpdateStreamStatusAptosResponseAdapter, UpdateStreamStatusEvmResponseAdapter, GetStreamEvmRequest, GetStreamAptosRequest, GetStreamAptosResponseAdapter, GetStreamEvmResponseAdapter, GetStreamsEvmRequest, GetStreamsAptosRequest, GetStreamsAptosResponseAdapter, GetStreamsEvmResponseAdapter, DeleteStreamEvmRequest, DeleteStreamAptosRequest, DeleteStreamAptosResponseAdapter, DeleteStreamEvmResponseAdapter, UpdateStreamEvmRequest, UpdateStreamAptosRequest, UpdateStreamAptosResponseAdapter, UpdateStreamEvmResponseAdapter, CreateStreamEvmRequest, CreateStreamAptosRequest, CreateStreamAptosResponseAdapter, CreateStreamEvmResponseAdapter } from '@moralisweb3/common-streams-utils';
import { BigNumber } from '@ethersproject/bignumber';

declare enum StreamNetwork {
    APTOS = "aptos",
    EVM = "evm"
}
type AptosStreamNetwork = `${StreamNetwork.APTOS}`;
type EvmStreamNetwork = `${StreamNetwork.EVM}`;

interface AptosStreamNetworkOptions {
    networkType: AptosStreamNetwork;
}
interface EvmStreamNetworkOptions {
    networkType?: EvmStreamNetwork;
}

interface DeleteAddressAptosOptions extends DeleteAddressAptosRequest, AptosStreamNetworkOptions {
}
interface DeleteAddressEvmOptions extends DeleteAddressEvmRequest, EvmStreamNetworkOptions {
}
type DeleteAddressOptions = DeleteAddressAptosOptions | DeleteAddressEvmOptions;
type MakeDeleteAddressAptosStream = (deleteAddressOptions: DeleteAddressAptosOptions) => Promise<DeleteAddressAptosResponseAdapter>;
type MakeDeleteAddressEvmStream = (deleteAddressOptions: DeleteAddressEvmOptions) => Promise<DeleteAddressEvmResponseAdapter>;

interface GetAddressesAptosOptions extends GetAddressesAptosRequest, AptosStreamNetworkOptions {
}
interface GetAddressesEvmOptions extends GetAddressesEvmRequest, EvmStreamNetworkOptions {
}
type GetAddressesOptions = GetAddressesAptosOptions | GetAddressesEvmOptions;
type MakeGetAddressesAptos = (getAddressesOptions: GetAddressesAptosOptions) => Promise<GetAddressesAptosResponseAdapter>;
type MakeGetAddressesEvm = (getAddressesOptions: GetAddressesEvmOptions) => Promise<GetAddressesEvmResponseAdapter>;

interface AddAddressAptosOptions extends AddAddressAptosRequest, AptosStreamNetworkOptions {
}
interface AddAddressEvmOptions extends AddAddressEvmRequest, EvmStreamNetworkOptions {
}
type AddAddressOptions = AddAddressAptosOptions | AddAddressEvmOptions;
type MakeAddAddressAptosStream = (addAddressOptions: AddAddressAptosOptions) => Promise<AddAddressAptosResponseAdapter>;
type MakeAddAddressEvmStream = (addAddressOptions: AddAddressEvmOptions) => Promise<AddAddressEvmResponseAdapter>;

interface UpdateStreamAptosStatusOptions extends UpdateStreamStatusAptosRequest, AptosStreamNetworkOptions {
}
interface UpdateStreamEvmStatusOptions extends UpdateStreamStatusEvmRequest, EvmStreamNetworkOptions {
}
type UpdateStreamStatusOptions = UpdateStreamAptosStatusOptions | UpdateStreamEvmStatusOptions;
type MakeUpdateAptosStreamStatus = (updateStreamOptions: UpdateStreamAptosStatusOptions) => Promise<UpdateStreamStatusAptosResponseAdapter>;
type MakeUpdateEvmStreamStatus = (updateStreamOptions: UpdateStreamEvmStatusOptions) => Promise<UpdateStreamStatusEvmResponseAdapter>;

interface StreamNetworkOptions {
    /** @deprecated use networkType instead */
    network?: EvmStreamNetwork;
}
interface GetStreamAptosOptions extends GetStreamAptosRequest, AptosStreamNetworkOptions, StreamNetworkOptions {
}
interface GetStreamEvmOptions extends GetStreamEvmRequest, EvmStreamNetworkOptions, StreamNetworkOptions {
}
type GetStreamOptions = GetStreamAptosOptions | GetStreamEvmOptions;
type MakeGetAptosStream$1 = (getStreamOptions: GetStreamAptosOptions) => Promise<GetStreamAptosResponseAdapter>;
type MakeGetEvmStream$1 = (getStreamOptions: GetStreamEvmOptions) => Promise<GetStreamEvmResponseAdapter>;

interface GetStreamsAptosOptions extends GetStreamsAptosRequest, AptosStreamNetworkOptions {
}
interface GetStreamsEvmOptions extends GetStreamsEvmRequest, EvmStreamNetworkOptions {
}
type GetStreamsOptions = GetStreamsAptosOptions | GetStreamsEvmOptions;
type MakeGetAptosStream = (getStreamOptions: GetStreamsAptosOptions) => Promise<GetStreamsAptosResponseAdapter>;
type MakeGetEvmStream = (getStreamOptions: GetStreamsEvmOptions) => Promise<GetStreamsEvmResponseAdapter>;

interface DeleteStreamAptosOptions extends DeleteStreamAptosRequest, AptosStreamNetworkOptions {
}
interface DeleteStreamEvmOptions extends DeleteStreamEvmRequest, EvmStreamNetworkOptions {
}
type DeleteStreamOptions = DeleteStreamAptosOptions | DeleteStreamEvmOptions;
type MakeDeleteAptosStream = (deleteStreamOptions: DeleteStreamAptosOptions) => Promise<DeleteStreamAptosResponseAdapter>;
type MakeDeleteEvmStream = (deleteStreamOptions: DeleteStreamEvmOptions) => Promise<DeleteStreamEvmResponseAdapter>;

interface UpdateStreamAptosOptions extends UpdateStreamAptosRequest, AptosStreamNetworkOptions {
}
interface UpdateStreamEvmOptions extends UpdateStreamEvmRequest, EvmStreamNetworkOptions {
}
type UpdateStreamOptions = UpdateStreamAptosOptions | UpdateStreamEvmOptions;
type MakeUpdateAptosStream = (updateStreamOptions: UpdateStreamAptosOptions) => Promise<UpdateStreamAptosResponseAdapter>;
type MakeUpdateEvmStream = (updateStreamOptions: UpdateStreamEvmOptions) => Promise<UpdateStreamEvmResponseAdapter>;

interface CreateStreamAptosOptions extends CreateStreamAptosRequest, AptosStreamNetworkOptions {
}
interface CreateStreamEvmOptions extends CreateStreamEvmRequest, EvmStreamNetworkOptions {
}
type CreateStreamOptions = CreateStreamAptosOptions | CreateStreamEvmOptions;
type MakeCreateAptosStream = (createStreamOptions: CreateStreamAptosOptions) => Promise<CreateStreamAptosResponseAdapter>;
type MakeCreateEvmStream = (createStreamOptions: CreateStreamEvmOptions) => Promise<CreateStreamEvmResponseAdapter>;

interface VerifySignatureOptions {
    body: IWebhook;
    signature: string;
}

declare class Streams extends ApiModule {
    static readonly moduleName = "streams";
    static create(core?: Core): Streams;
    private constructor();
    setup(): void;
    start(): void;
    readonly add: MakeCreateAptosStream & MakeCreateEvmStream;
    readonly update: MakeUpdateAptosStream & MakeUpdateEvmStream;
    readonly delete: MakeDeleteAptosStream & MakeDeleteEvmStream;
    readonly getAll: MakeGetAptosStream & MakeGetEvmStream;
    readonly getById: MakeGetAptosStream$1 & MakeGetEvmStream$1;
    readonly updateStatus: MakeUpdateAptosStreamStatus & MakeUpdateEvmStreamStatus;
    readonly addAddress: MakeAddAddressAptosStream & MakeAddAddressEvmStream;
    readonly getAddresses: MakeGetAddressesAptos & MakeGetAddressesEvm;
    readonly deleteAddress: MakeDeleteAddressAptosStream & MakeDeleteAddressEvmStream;
    readonly getHistory: (request: _moralisweb3_common_streams_utils.GetHistoryRequest) => Promise<_moralisweb3_common_core.PaginatedResponseAdapter<{
        id: string;
        date: string;
        payload?: (Partial<{
            block: {
                number: string;
                hash: string;
                timestamp: string;
            };
            chainId: string;
            logs: {
                triggers?: {
                    value: unknown;
                    name: string;
                }[] | undefined;
                logIndex: string;
                transactionHash: string;
                address: string;
                data: string;
                topic0: string | null;
                topic1: string | null;
                topic2: string | null;
                topic3: string | null;
            }[];
            txs: {
                triggers?: {
                    value: unknown;
                    name: string;
                }[] | undefined;
                hash: string;
                gas: string | null;
                gasPrice: string | null;
                nonce: string | null;
                input: string | null;
                transactionIndex: string;
                fromAddress: string;
                toAddress: string | null;
                value: string | null;
                type: string | null;
                v: string | null;
                r: string | null;
                s: string | null;
                receiptCumulativeGasUsed: string | null;
                receiptGasUsed: string | null;
                receiptContractAddress: string | null;
                receiptRoot: string | null;
                receiptStatus: string | null;
            }[];
            txsInternal: {
                from: string | null;
                to: string | null;
                value: string | null;
                transactionHash: string;
                gas: string | null;
            }[];
            abi: {
                anonymous?: boolean | undefined;
                constant?: boolean | undefined;
                inputs?: {
                    name: string;
                    type: string;
                    indexed?: boolean | undefined;
                    components?: any[] | undefined;
                    internalType?: string | undefined;
                }[] | undefined;
                name?: string | undefined;
                outputs?: {
                    name: string;
                    type: string;
                    components?: any[] | undefined;
                    internalType?: string | undefined;
                }[] | undefined;
                payable?: boolean | undefined;
                stateMutability?: string | undefined;
                type: string;
                gas?: number | undefined;
            }[];
            retries: number;
            confirmed: boolean;
            tag: string;
            streamId: string;
        }> & Partial<{
            block: {
                lastVersion: string;
                firstVersion: string;
                hash: string;
                timestamp: string;
                number: string;
            };
            changes: ({
                txHash: string;
            } & {
                [key: string]: unknown;
            })[];
            coinDeposits: {
                txHash: string;
                sequenceNumber: string;
                valueWithDecimals: string;
                coin: {
                    symbol: string;
                    decimals: number;
                    name: string;
                };
                address: string;
                value: string;
            }[];
            coinTransfers: {
                txHash: string;
                transaction: string;
                valueWithDecimals: number;
                from: string;
                value: string;
                to: string;
                coin: {
                    symbol: string;
                    decimals: number;
                    name: string;
                };
            }[];
            coinWithdrawals: {
                txHash: string;
                sequenceNumber: string;
                valueWithDecimals: string;
                coin: {
                    symbol: string;
                    decimals: number;
                    name: string;
                };
                address: string;
                value: string;
            }[];
            events: ({
                txHash: string;
            } & {
                [key: string]: unknown;
            })[];
            network: "mainnet" | "testnet";
            payloads: ({
                txHash: string;
            } & {
                [key: string]: unknown;
            })[];
            retries: number;
            streamId: string;
            tag: string;
            transactions: {
                gasUnitPrice: string;
                type: string;
                gasUsed: string;
                eventChangeHash: string;
                stateChangeHash: string;
                gasLimit: string;
                sender: string;
                success: boolean;
                hash: string;
            }[];
        }>) | undefined;
        tinyPayload: {
            chainId: string;
            confirmed: boolean;
            block: string;
            records: number;
            retries: number;
        };
        errorMessage: string;
        webhookUrl: string;
        streamId: string;
        tag: string;
    }[], {
        id: string;
        date: string;
        payload?: (Partial<{
            block: {
                number: string;
                hash: string;
                timestamp: string;
            };
            chainId: string;
            logs: {
                triggers?: {
                    value: unknown;
                    name: string;
                }[] | undefined;
                logIndex: string;
                transactionHash: string;
                address: string;
                data: string;
                topic0: string | null;
                topic1: string | null;
                topic2: string | null;
                topic3: string | null;
            }[];
            txs: {
                triggers?: {
                    value: unknown;
                    name: string;
                }[] | undefined;
                hash: string;
                gas: string | null;
                gasPrice: string | null;
                nonce: string | null;
                input: string | null;
                transactionIndex: string;
                fromAddress: string;
                toAddress: string | null;
                value: string | null;
                type: string | null;
                v: string | null;
                r: string | null;
                s: string | null;
                receiptCumulativeGasUsed: string | null;
                receiptGasUsed: string | null;
                receiptContractAddress: string | null;
                receiptRoot: string | null;
                receiptStatus: string | null;
            }[];
            txsInternal: {
                from: string | null;
                to: string | null;
                value: string | null;
                transactionHash: string;
                gas: string | null;
            }[];
            abi: {
                anonymous?: boolean | undefined;
                constant?: boolean | undefined;
                inputs?: {
                    name: string;
                    type: string;
                    indexed?: boolean | undefined;
                    components?: any[] | undefined;
                    internalType?: string | undefined;
                }[] | undefined;
                name?: string | undefined;
                outputs?: {
                    name: string;
                    type: string;
                    components?: any[] | undefined;
                    internalType?: string | undefined;
                }[] | undefined;
                payable?: boolean | undefined;
                stateMutability?: string | undefined;
                type: string;
                gas?: number | undefined;
            }[];
            retries: number;
            confirmed: boolean;
            tag: string;
            streamId: string;
        }> & Partial<{
            block: {
                lastVersion: string;
                firstVersion: string;
                hash: string;
                timestamp: string;
                number: string;
            };
            changes: ({
                txHash: string;
            } & {
                [key: string]: unknown;
            })[];
            coinDeposits: {
                txHash: string;
                sequenceNumber: string;
                valueWithDecimals: string;
                coin: {
                    symbol: string;
                    decimals: number;
                    name: string;
                };
                address: string;
                value: string;
            }[];
            coinTransfers: {
                txHash: string;
                transaction: string;
                valueWithDecimals: number;
                from: string;
                value: string;
                to: string;
                coin: {
                    symbol: string;
                    decimals: number;
                    name: string;
                };
            }[];
            coinWithdrawals: {
                txHash: string;
                sequenceNumber: string;
                valueWithDecimals: string;
                coin: {
                    symbol: string;
                    decimals: number;
                    name: string;
                };
                address: string;
                value: string;
            }[];
            events: ({
                txHash: string;
            } & {
                [key: string]: unknown;
            })[];
            network: "mainnet" | "testnet";
            payloads: ({
                txHash: string;
            } & {
                [key: string]: unknown;
            })[];
            retries: number;
            streamId: string;
            tag: string;
            transactions: {
                gasUnitPrice: string;
                type: string;
                gasUsed: string;
                eventChangeHash: string;
                stateChangeHash: string;
                gasLimit: string;
                sender: string;
                success: boolean;
                hash: string;
            }[];
        }>) | undefined;
        tinyPayload: {
            chainId: string;
            confirmed: boolean;
            block: string;
            records: number;
            retries: number;
        };
        errorMessage: string;
        webhookUrl: string;
        streamId: string;
        tag: string;
    }[]>>;
    readonly getLogs: (request: _moralisweb3_common_streams_utils.GetLogsRequest) => Promise<_moralisweb3_common_core.PaginatedResponseAdapter<{
        chain: _moralisweb3_common_evm_utils.EvmChain;
        id: string;
        streamId: string;
        webhookUrl: string;
        tag: string;
        retries: number;
        deliveryStatus: "failed" | "success";
        blockNumber: number;
        errorMessage: string;
        type: "aptos" | "evm";
        createdAt: string;
    }[], {
        id: string;
        streamId: string;
        chain: string;
        webhookUrl: string;
        tag: string;
        retries: number;
        deliveryStatus: "failed" | "success";
        blockNumber: number;
        errorMessage: string;
        type: "aptos" | "evm";
        createdAt: string;
    }[]>>;
    readonly retry: (request: _moralisweb3_common_streams_utils.ReplayHistoryRequest) => Promise<_moralisweb3_common_core.ResponseAdapter<{
        id: string;
        date: string;
        payload?: (Partial<{
            block: {
                number: string;
                hash: string;
                timestamp: string;
            };
            chainId: string;
            logs: {
                triggers?: {
                    value: unknown;
                    name: string;
                }[] | undefined;
                logIndex: string;
                transactionHash: string;
                address: string;
                data: string;
                topic0: string | null;
                topic1: string | null;
                topic2: string | null;
                topic3: string | null;
            }[];
            txs: {
                triggers?: {
                    value: unknown;
                    name: string;
                }[] | undefined;
                hash: string;
                gas: string | null;
                gasPrice: string | null;
                nonce: string | null;
                input: string | null;
                transactionIndex: string;
                fromAddress: string;
                toAddress: string | null;
                value: string | null;
                type: string | null;
                v: string | null;
                r: string | null;
                s: string | null;
                receiptCumulativeGasUsed: string | null;
                receiptGasUsed: string | null;
                receiptContractAddress: string | null;
                receiptRoot: string | null;
                receiptStatus: string | null;
            }[];
            txsInternal: {
                from: string | null;
                to: string | null;
                value: string | null;
                transactionHash: string;
                gas: string | null;
            }[];
            abi: {
                anonymous?: boolean | undefined;
                constant?: boolean | undefined;
                inputs?: {
                    name: string;
                    type: string;
                    indexed?: boolean | undefined;
                    components?: any[] | undefined;
                    internalType?: string | undefined;
                }[] | undefined;
                name?: string | undefined;
                outputs?: {
                    name: string;
                    type: string;
                    components?: any[] | undefined;
                    internalType?: string | undefined;
                }[] | undefined;
                payable?: boolean | undefined;
                stateMutability?: string | undefined;
                type: string;
                gas?: number | undefined;
            }[];
            retries: number;
            confirmed: boolean;
            tag: string;
            streamId: string;
        }> & Partial<{
            block: {
                lastVersion: string;
                firstVersion: string;
                hash: string;
                timestamp: string;
                number: string;
            };
            changes: ({
                txHash: string;
            } & {
                [key: string]: unknown;
            })[];
            coinDeposits: {
                txHash: string;
                sequenceNumber: string;
                valueWithDecimals: string;
                coin: {
                    symbol: string;
                    decimals: number;
                    name: string;
                };
                address: string;
                value: string;
            }[];
            coinTransfers: {
                txHash: string;
                transaction: string;
                valueWithDecimals: number;
                from: string;
                value: string;
                to: string;
                coin: {
                    symbol: string;
                    decimals: number;
                    name: string;
                };
            }[];
            coinWithdrawals: {
                txHash: string;
                sequenceNumber: string;
                valueWithDecimals: string;
                coin: {
                    symbol: string;
                    decimals: number;
                    name: string;
                };
                address: string;
                value: string;
            }[];
            events: ({
                txHash: string;
            } & {
                [key: string]: unknown;
            })[];
            network: "mainnet" | "testnet";
            payloads: ({
                txHash: string;
            } & {
                [key: string]: unknown;
            })[];
            retries: number;
            streamId: string;
            tag: string;
            transactions: {
                gasUnitPrice: string;
                type: string;
                gasUsed: string;
                eventChangeHash: string;
                stateChangeHash: string;
                gasLimit: string;
                sender: string;
                success: boolean;
                hash: string;
            }[];
        }>) | undefined;
        tinyPayload: {
            chainId: string;
            confirmed: boolean;
            block: string;
            records: number;
            retries: number;
        };
        errorMessage: string;
        webhookUrl: string;
        streamId: string;
        tag: string;
    }, {
        id: string;
        date: string;
        payload?: (Partial<{
            block: {
                number: string;
                hash: string;
                timestamp: string;
            };
            chainId: string;
            logs: {
                triggers?: {
                    value: unknown;
                    name: string;
                }[] | undefined;
                logIndex: string;
                transactionHash: string;
                address: string;
                data: string;
                topic0: string | null;
                topic1: string | null;
                topic2: string | null;
                topic3: string | null;
            }[];
            txs: {
                triggers?: {
                    value: unknown;
                    name: string;
                }[] | undefined;
                hash: string;
                gas: string | null;
                gasPrice: string | null;
                nonce: string | null;
                input: string | null;
                transactionIndex: string;
                fromAddress: string;
                toAddress: string | null;
                value: string | null;
                type: string | null;
                v: string | null;
                r: string | null;
                s: string | null;
                receiptCumulativeGasUsed: string | null;
                receiptGasUsed: string | null;
                receiptContractAddress: string | null;
                receiptRoot: string | null;
                receiptStatus: string | null;
            }[];
            txsInternal: {
                from: string | null;
                to: string | null;
                value: string | null;
                transactionHash: string;
                gas: string | null;
            }[];
            abi: {
                anonymous?: boolean | undefined;
                constant?: boolean | undefined;
                inputs?: {
                    name: string;
                    type: string;
                    indexed?: boolean | undefined;
                    components?: any[] | undefined;
                    internalType?: string | undefined;
                }[] | undefined;
                name?: string | undefined;
                outputs?: {
                    name: string;
                    type: string;
                    components?: any[] | undefined;
                    internalType?: string | undefined;
                }[] | undefined;
                payable?: boolean | undefined;
                stateMutability?: string | undefined;
                type: string;
                gas?: number | undefined;
            }[];
            retries: number;
            confirmed: boolean;
            tag: string;
            streamId: string;
        }> & Partial<{
            block: {
                lastVersion: string;
                firstVersion: string;
                hash: string;
                timestamp: string;
                number: string;
            };
            changes: ({
                txHash: string;
            } & {
                [key: string]: unknown;
            })[];
            coinDeposits: {
                txHash: string;
                sequenceNumber: string;
                valueWithDecimals: string;
                coin: {
                    symbol: string;
                    decimals: number;
                    name: string;
                };
                address: string;
                value: string;
            }[];
            coinTransfers: {
                txHash: string;
                transaction: string;
                valueWithDecimals: number;
                from: string;
                value: string;
                to: string;
                coin: {
                    symbol: string;
                    decimals: number;
                    name: string;
                };
            }[];
            coinWithdrawals: {
                txHash: string;
                sequenceNumber: string;
                valueWithDecimals: string;
                coin: {
                    symbol: string;
                    decimals: number;
                    name: string;
                };
                address: string;
                value: string;
            }[];
            events: ({
                txHash: string;
            } & {
                [key: string]: unknown;
            })[];
            network: "mainnet" | "testnet";
            payloads: ({
                txHash: string;
            } & {
                [key: string]: unknown;
            })[];
            retries: number;
            streamId: string;
            tag: string;
            transactions: {
                gasUnitPrice: string;
                type: string;
                gasUsed: string;
                eventChangeHash: string;
                stateChangeHash: string;
                gasLimit: string;
                sender: string;
                success: boolean;
                hash: string;
            }[];
        }>) | undefined;
        tinyPayload: {
            chainId: string;
            confirmed: boolean;
            block: string;
            records: number;
            retries: number;
        };
        errorMessage: string;
        webhookUrl: string;
        streamId: string;
        tag: string;
    }>>;
    private readonly _getStats;
    readonly getStats: () => Promise<_moralisweb3_common_core.ResponseAdapter<{
        totalWebhooksDelivered: number;
        totalWebhooksFailed: number;
        totalLogsProcessed: number;
        totalTxsProcessed: number;
        totalTxsInternalProcessed: number;
        streams?: {
            totalWebhooksDelivered: number;
            totalWebhooksFailed: number;
            totalLogsProcessed: number;
            totalTxsProcessed: number;
            totalTxsInternalProcessed: number;
            streamId: string;
        }[] | undefined;
        createdAt?: string | undefined;
        updatedAt?: string | undefined;
    }, {
        totalWebhooksDelivered: number;
        totalWebhooksFailed: number;
        totalLogsProcessed: number;
        totalTxsProcessed: number;
        totalTxsInternalProcessed: number;
        streams?: {
            totalWebhooksDelivered: number;
            totalWebhooksFailed: number;
            totalLogsProcessed: number;
            totalTxsProcessed: number;
            totalTxsInternalProcessed: number;
            streamId: string;
        }[] | undefined;
        createdAt?: string | undefined;
        updatedAt?: string | undefined;
    }>>;
    readonly getStatsById: (request: _moralisweb3_common_streams_utils.GetStatsByIdRequest) => Promise<_moralisweb3_common_core.ResponseAdapter<{
        totalWebhooksDelivered: number;
        totalWebhooksFailed: number;
        totalLogsProcessed: number;
        totalTxsProcessed: number;
        totalTxsInternalProcessed: number;
        streams?: {
            totalWebhooksDelivered: number;
            totalWebhooksFailed: number;
            totalLogsProcessed: number;
            totalTxsProcessed: number;
            totalTxsInternalProcessed: number;
            streamId: string;
        }[] | undefined;
        createdAt?: string | undefined;
        updatedAt?: string | undefined;
    }, {
        totalWebhooksDelivered: number;
        totalWebhooksFailed: number;
        totalLogsProcessed: number;
        totalTxsProcessed: number;
        totalTxsInternalProcessed: number;
        streams?: {
            totalWebhooksDelivered: number;
            totalWebhooksFailed: number;
            totalLogsProcessed: number;
            totalTxsProcessed: number;
            totalTxsInternalProcessed: number;
            streamId: string;
        }[] | undefined;
        createdAt?: string | undefined;
        updatedAt?: string | undefined;
    }>>;
    readonly setSettings: (request: _moralisweb3_common_streams_utils.SetSettingsRequest) => Promise<_moralisweb3_common_core.ResponseAdapter<{
        region?: "us-east-1" | "us-west-2" | "eu-central-1" | "ap-southeast-1" | undefined;
    }, {
        region?: "us-east-1" | "us-west-2" | "eu-central-1" | "ap-southeast-1" | undefined;
    }>>;
    private readonly _readSettings;
    readonly readSettings: () => Promise<_moralisweb3_common_core.ResponseAdapter<{
        region?: "us-east-1" | "us-west-2" | "eu-central-1" | "ap-southeast-1" | undefined;
    }, {
        region?: "us-east-1" | "us-west-2" | "eu-central-1" | "ap-southeast-1" | undefined;
    }>>;
    readonly verifySignature: (options: VerifySignatureOptions) => boolean;
    readonly parsedLogs: <Event_1>(webhookData: IWebhook) => Event_1[];
    private createFetcher;
    private createPaginatedFetcher;
}

declare class CollectionNameBuilder {
    private readonly cache;
    private cacheLimit;
    build(tag: string): string;
    private process;
}

interface Update<Doc = Document> {
    collectionName: string;
    document: Doc;
}
interface Document {
    id: string;
    confirmed: boolean;
}
interface TriggerItem {
    name: string;
    value: TriggerItemValue;
}
type TriggerItemValue = string | number | boolean | TriggerItemValue[];

interface Erc20TransferDocument extends Document {
    id: string;
    transactionHash: string;
    contract: string;
    logIndex: string;
    from: string;
    to: string;
    value: string;
    tokenDecimals: number;
    tokenName: string;
    tokenSymbol: string;
    blockHash: string;
    blockTimestamp: number;
    blockNumber: number;
    confirmed: boolean;
    chainId: number;
    triggers: TriggerItem[] | undefined;
}
declare class Erc20TransferDocumentBuilder {
    static build(transfer: IERC20Transfer, block: Block, confirmed: boolean, chainId: string): Erc20TransferDocument;
}

declare class Erc20TransfersProcessor {
    private readonly collectionNameBuilder;
    private readonly simpleProcessor;
    constructor(collectionNameBuilder: CollectionNameBuilder);
    process(batch: IWebhook): Erc20TransferUpdate[];
}
interface Erc20TransferUpdate extends Update<Erc20TransferDocument> {
}

interface Erc20ApprovalDocument extends Document {
    id: string;
    transactionHash: string;
    contract: string;
    logIndex: string;
    owner: string;
    spender: string;
    value: string;
    tokenDecimals: number;
    tokenName: string;
    tokenSymbol: string;
    blockHash: string;
    blockTimestamp: number;
    blockNumber: number;
    confirmed: boolean;
    chainId: number;
    triggers: TriggerItem[] | undefined;
}
declare class Erc20ApprovalDocumentBuilder {
    static build(approval: IERC20Approval, block: Block, confirmed: boolean, chainId: string): Erc20ApprovalDocument;
}

declare class Erc20ApprovalsProcessor {
    private readonly collectionNameBuilder;
    private readonly processor;
    constructor(collectionNameBuilder: CollectionNameBuilder);
    process(batch: IWebhook): Erc20ApprovalUpdate[];
}
interface Erc20ApprovalUpdate extends Update<Erc20ApprovalDocument> {
}

interface InternalTxDocument extends Document {
    id: string;
    hash: string;
    chainId: number;
    from: string;
    to: string;
    value: string;
    gas: number;
    blockHash: string;
    blockTimestamp: number;
    blockNumber: number;
    confirmed: boolean;
}
declare class InternalTxDocumentBuilder {
    static build(tx: InternalTransaction, block: Block, confirmed: boolean, chainId: string): InternalTxDocument;
}

declare class InternalTxsProcessor {
    private readonly collectionNameBuilder;
    private readonly simpleProcessor;
    constructor(collectionNameBuilder: CollectionNameBuilder);
    process(batch: IWebhook): InternalTxDocumentUpdate[];
}
interface InternalTxDocumentUpdate extends Update<InternalTxDocument> {
}

interface ParsedLog {
    name: string;
    params: Record<string, LogParam>;
}
interface LogParam {
    value: LogParamValue;
    type: string;
}
type LogParamValue = BigNumber | string;
declare class LogParser {
    private readonly abiInterface;
    constructor(abiItems: AbiItem[]);
    read(log: Log): ParsedLog;
}

interface BaseLogDocument {
    id: string;
    name: string;
    logIndex: number;
    transactionHash: string;
    address: string;
    blockHash: string;
    blockTimestamp: number;
    blockNumber: number;
    confirmed: boolean;
    chainId: number;
    triggers: TriggerItem[] | undefined;
}
interface LogDocument extends BaseLogDocument, Document {
    [paramName: string]: LogDocumentValue;
}
type LogDocumentValue = string | number | boolean | object | undefined;
declare class LogDocumentBuilder {
    static build(log: Log, parsedLog: ParsedLog, block: Block, confirmed: boolean, chainId: string): LogDocument;
}

declare class LogDocumentValueFormatter {
    static format(param: LogParam): LogDocumentValue;
}

declare class LogsProcessor {
    private readonly collectionNameBuilder;
    constructor(collectionNameBuilder: CollectionNameBuilder);
    process(batch: IWebhook): LogDocumentUpdate[];
}
interface LogDocumentUpdate extends Update<LogDocument> {
}

declare class ParamNameResolver {
    private readonly restrictedNames;
    private readonly usedNames;
    constructor(restrictedNames: string[]);
    iterate<Value>(object: Record<string, Value>, callback: (safeName: string, value: Value) => void): void;
    resolve(name: string): string;
    private isUsed;
}

interface NftTransferDocument extends Document {
    id: string;
    transactionHash: string;
    contract: string;
    logIndex: string;
    operator: string | null;
    from: string;
    to: string;
    tokenId: string;
    amount: string;
    tokenContractType: string;
    tokenName: string;
    tokenSymbol: string;
    blockHash: string;
    blockTimestamp: number;
    blockNumber: number;
    confirmed: boolean;
    chainId: number;
    triggers: TriggerItem[] | undefined;
}
declare class NftTransferDocumentBuilder {
    static build(transfer: INFTTransfer, block: Block, confirmed: boolean, chainId: string): NftTransferDocument;
}

declare class NftTransfersProcessor {
    private readonly collectionNameBuilder;
    private readonly simpleProcessor;
    constructor(collectionNameBuilder: CollectionNameBuilder);
    process(batch: IWebhook): NftTransferUpdate[];
}
interface NftTransferUpdate extends Update<NftTransferDocument> {
}

interface NftApprovalDocument extends Document {
    id: string;
    transactionHash: string;
    contract: string;
    logIndex: string;
    operator: string;
    account: string;
    approvedAll: boolean;
    tokenId: string | null;
    tokenContractType: string;
    tokenName: string;
    tokenSymbol: string;
    blockHash: string;
    blockTimestamp: number;
    blockNumber: number;
    confirmed: boolean;
    chainId: number;
}
declare class NftApprovalDocumentBuilder {
    static build(approval: INFTApproval, block: Block, confirmed: boolean, chainId: string): NftApprovalDocument;
}

declare class NftApprovalsProcessor {
    private readonly collectionNameBuilder;
    private readonly simpleProcessor;
    constructor(collectionNameBuilder: CollectionNameBuilder);
    process(batch: IWebhook): NftApprovalUpdate[];
}
interface NftApprovalUpdate extends Update<NftApprovalDocument> {
}

interface TxDocument extends Document {
    id: string;
    hash: string;
    chainId: number;
    transactionIndex: number;
    gas: number;
    gasPrice: number;
    nonce: number;
    fromAddress: string;
    toAddress: string | null;
    value: string;
    input: string | null;
    type: number;
    receiptStatus: number;
    receiptGasUsed: number;
    receiptCumulativeGasUsed: number;
    blockHash: string;
    blockTimestamp: number;
    blockNumber: number;
    confirmed: boolean;
    triggers: TriggerItem[] | undefined;
}
declare class TxDocumentBuilder {
    static build(tx: Transaction, block: Block, confirmed: boolean, chainId: string): TxDocument;
}

declare class TxsProcessor {
    private readonly collectionNameBuilder;
    private readonly processor;
    constructor(collectionNameBuilder: CollectionNameBuilder);
    process(batch: IWebhook): TxDocumentUpdate[];
}
interface TxDocumentUpdate extends Update<TxDocument> {
}

declare class BatchProcessor {
    private readonly erc20ApprovalsProcessor;
    private readonly erc20TransfersProcessor;
    private readonly internalTxsProcessor;
    private readonly logsProcessor;
    private readonly nftApprovalsProcessor;
    private readonly nftTransfersProcessor;
    private readonly txsProcessor;
    static create(): BatchProcessor;
    private constructor();
    process(batch: IWebhook): {
        erc20Approvals: () => Erc20ApprovalUpdate[];
        erc20Transfers: () => Erc20TransferUpdate[];
        internalTxs: () => InternalTxDocumentUpdate[];
        logs: () => LogDocumentUpdate[];
        nftApprovals: () => NftApprovalUpdate[];
        nftTransfers: () => NftTransferUpdate[];
        txs: () => TxDocumentUpdate[];
    };
}

export { AddAddressEvmOptions, AddAddressOptions, BatchProcessor, CollectionNameBuilder, CreateStreamEvmOptions, CreateStreamOptions, DeleteAddressEvmOptions, DeleteAddressOptions, DeleteStreamEvmOptions, DeleteStreamOptions, Document, Erc20ApprovalDocument, Erc20ApprovalDocumentBuilder, Erc20ApprovalUpdate, Erc20ApprovalsProcessor, Erc20TransferDocument, Erc20TransferDocumentBuilder, Erc20TransferUpdate, Erc20TransfersProcessor, GetAddressesEvmOptions, GetAddressesOptions, GetStreamEvmOptions, GetStreamOptions, GetStreamsEvmOptions, GetStreamsOptions, InternalTxDocument, InternalTxDocumentBuilder, InternalTxDocumentUpdate, InternalTxsProcessor, LogDocument, LogDocumentBuilder, LogDocumentUpdate, LogDocumentValue, LogDocumentValueFormatter, LogParam, LogParamValue, LogParser, LogsProcessor, NftApprovalDocument, NftApprovalDocumentBuilder, NftApprovalUpdate, NftApprovalsProcessor, NftTransferDocument, NftTransferDocumentBuilder, NftTransferUpdate, NftTransfersProcessor, ParamNameResolver, ParsedLog, Streams, TriggerItem, TriggerItemValue, TxDocument, TxDocumentBuilder, TxDocumentUpdate, TxsProcessor, Update, UpdateStreamEvmOptions, UpdateStreamEvmStatusOptions, UpdateStreamOptions, UpdateStreamStatusOptions, VerifySignatureOptions };
