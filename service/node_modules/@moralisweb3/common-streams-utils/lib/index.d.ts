import { AptosNetworkInput, AptosNetwork, AptosAddressInput, AptosAddress } from '@moralisweb3/common-aptos-utils';
import * as _moralisweb3_common_core from '@moralisweb3/common-core';
import { MoralisDataObject, MoralisData, BigNumberish, BigNumber, MoralisDataObjectValue, MoralisDataFormatted, Camelize, ResponseAdapter, Operation, PaginatedResponseAdapter, PaginatedOperation } from '@moralisweb3/common-core';
import * as _moralisweb3_common_evm_utils from '@moralisweb3/common-evm-utils';
import { EvmAddressish, EvmAddress, EvmChainish, EvmChain, EvmNativeish, EvmNative, EvmSignature, EvmSimpleBlock } from '@moralisweb3/common-evm-utils';
import * as _ethersproject_abi from '@ethersproject/abi';
import { Interface } from '@ethersproject/abi';
import { INFTApproval, IWebhook } from '@moralisweb3/streams-typings';

type StreamStatus = 'active' | 'paused' | 'error' | 'terminated';
interface AptosStreamInput {
    id: string;
    allAddresses: boolean;
    demo: boolean;
    description: string;
    includeChanges: boolean;
    includeEvents: boolean;
    includePayload: boolean;
    isErrorSince: string | null;
    network: AptosNetworkInput[];
    status: StreamStatus;
    statusMessage: string;
    events: string[];
    functions: string[];
    tag: string;
    webhookUrl: string;
    amountOfAddresses: number;
}
interface AptosStreamData {
    id: string;
    allAddresses: boolean;
    demo: boolean;
    description: string;
    includeChanges: boolean;
    includeEvents: boolean;
    includePayload: boolean;
    isErrorSince: string | null;
    network: AptosNetwork[];
    status: StreamStatus;
    statusMessage: string;
    events: string[];
    functions: string[];
    tag: string;
    webhookUrl: string;
    amountOfAddresses: number;
}
type AptosStreamJSON = {
    id: string;
    allAddresses: boolean;
    demo: boolean;
    description: string;
    includeChanges: boolean;
    includeEvents: boolean;
    includePayload: boolean;
    isErrorSince: string | null;
    network: string[];
    status: StreamStatus;
    statusMessage: string;
    events: string[];
    functions: string[];
    tag: string;
    webhookUrl: string;
    amountOfAddresses: number;
};

type AptosStreamish = AptosStreamInput | AptosStream;
/**
 * The AptosStream class is a representation of an Aptos Stream that is returned by the Moralis Stream API
 *
 * @category DataType
 */
declare class AptosStream implements MoralisDataObject {
    private _data;
    constructor(data: AptosStreamInput);
    /**
     * Create a new instance of AptosStream
     *
     * @param data - the AptosStreamish type
     * @example
     * ```ts
     * const aptosStream = AptosStream.create(data);
     * ```
     * @returns an instance of AptosStream
     */
    static create(data: AptosStreamish): AptosStream;
    private static parse;
    /**
     * Compares two AptosStream data. It checks a deep equality check of both values.
     * @param valueA - the first AptosStreamish data to compare
     * @param valueB - the second AptosStreamish data to compare
     * @returns true if the values are equal, false otherwise
     * @example
     * ```ts
     *  AptosStream.equals(valueA, valueB);
     * ```
     */
    static equals(valueA: AptosStreamish, valueB: AptosStreamish): boolean;
    /**
     * Compares an AptosStreamish data to this AptosStream instance.
     * @param value - the value to compare
     * @returns true if the value is equal to the current instance, false otherwise
     * @example
     * ```ts
     * aptosStream.equals(value);
     * ```
     */
    equals(value: AptosStreamish): boolean;
    /**
     * Converts the AptosStream instance to a JSON object.
     * @returns JSON object of the AptosStream instance
     * @example `aptosStream.toJSON()`
     */
    toJSON(): AptosStreamJSON;
    /**
     * Converts the AptosStream instance to a JSON object.
     * @returns JSON object of the AptosStream instance
     * @example `aptosStream.format()`
     */
    format(): AptosStreamJSON;
    get network(): AptosNetwork[];
    get webhookUrl(): string;
    get description(): string;
    get tag(): string;
    get allAddresses(): boolean;
    get id(): string;
    get status(): StreamStatus;
    get statusMessage(): string;
    get demo(): boolean;
    get includeChanges(): boolean;
    get includeEvents(): boolean;
    get includePayload(): boolean;
    get isErrorSince(): string | null;
    get events(): string[];
    get functions(): string[];
    get amountOfAddresses(): number;
}

/**
 * This can be a string that starts with $ and is the path of any field in the stream data.
 */
type StreamSelectorInput = string;
/**
 * Valid input for a new StreamSelector instance.
 * This can be an existing StreamSelector or a valid input string.
 */
type StreamSelectorish = StreamSelector | StreamSelectorInput;
/**
 * The StreamSelector class is a representation of a stream selector
 *
 * Use this class any time you want to use a value in your stream trigger data that is not a static value
 *
 * @category DataType
 */
declare class StreamSelector implements MoralisData {
    private readonly _value;
    /**
     * Create a new instance of StreamSelector from any valid stream data field
     *
     * @example
     * ```
     * const receiverSelector = StreamSelector.create('$to')
     * const selector = StreamSelector.create('$contract')
     * ```
     */
    constructor(data: StreamSelectorInput);
    static isSelectorString(selector: StreamSelectorish): boolean;
    static create(streamSelector: StreamSelectorish): StreamSelector;
    private static parse;
    /**
     * Compares two StreamSelector data. It checks a deep equality check of both values.
     * @param valueA - the first StreamSelectorish data to compare
     * @param valueB - the second StreamSelectorish data to compare
     * @returns true if the values are equal, false otherwise
     * @example
     * ```ts
     *  StreamSelector.equals(valueA, valueB);
     * ```
     */
    static equals(valueA: StreamSelectorish, valueB: StreamSelectorish): boolean;
    /**
     * Compares an StreamSelectorish data to this StreamSelector instance.
     * @param streamSelector - the streamSelector to compare
     * @returns true if the streamSelector is equal to the current instance, false otherwise
     * @example
     * ```ts
     * streamSelector.equals(streamSelector);
     * ```
     */
    equals(streamSelector: StreamSelectorish): boolean;
    /**
     * @deprecated This method will be removed soon. To format the value, use one of the properties.
     */
    format(): string;
    /**
     * @returns the selector path
     * @example '$from'
     */
    get value(): string;
    toJSON(): string;
}

interface StreamTriggerInput {
    type: 'tx' | 'log' | 'erc20transfer' | 'erc20approval' | 'nfttransfer';
    contractAddress: StreamSelectorish | EvmAddressish;
    functionAbi: unknown;
    inputs?: (string | string[])[];
    topic0?: string;
    callFrom?: StreamSelectorish | EvmAddressish;
}
interface StreamTriggerData {
    type: 'tx' | 'log' | 'erc20transfer' | 'erc20approval' | 'nfttransfer';
    contractAddress: StreamSelector | EvmAddress;
    functionAbi: unknown;
    inputs?: (string | string[])[];
    topic0?: string;
    callFrom?: StreamSelector | EvmAddress;
}
type StreamTriggerJSON = {
    type: 'tx' | 'log' | 'erc20transfer' | 'erc20approval' | 'nfttransfer';
    contractAddress: string;
    functionAbi: any;
    inputs?: (string | string[])[];
    topic0?: string;
    callFrom?: string;
};

type StreamTriggerish = StreamTrigger | StreamTriggerInput | StreamTriggerData;
/**
 * The StreamTrigger class is a representation of a stream trigger that is used by the Moralis Stream API
 *
 * @category DataType
 */
declare class StreamTrigger implements MoralisDataObject {
    private readonly _data;
    constructor(data: StreamTriggerInput);
    static create(data: StreamTriggerish): StreamTrigger;
    private static parseSelectorOrAddress;
    private static parse;
    static equals(valueA: StreamTriggerish, valueB: StreamTriggerish): boolean;
    /**
     * Compares two StreamTrigger arrays. It checks a deep equality check of both values, meaning that all the values have to be on both arrays.
     * @param valueA - the first StreamTriggerish[] data to compare
     * @param valueB - the second StreamTriggerish[] data to compare
     * @returns true if all values are equal, false otherwise
     * @example
     * ```ts
     *  StreamTrigger.arrayEquals(valueA, valueB);
     * ```
     */
    static arrayEquals(valueA: StreamTriggerish[], valueB: StreamTriggerish[]): boolean;
    /**
     * Compares an StreamTrigger data to this StreamTrigger instance.
     * @param value - the value to compare
     * @returns true if the value is equal to the current instance, false otherwise
     * @example
     * ```ts
     * streamTrigger.equals(value);
     * ```
     */
    equals(value: StreamTriggerish): boolean;
    /**
     * Converts the StreamTrigger instance to a JSON object.
     * @returns JSON object of the StreamTrigger instance
     * @example `streamTrigger.toJSON()`
     */
    toJSON(): StreamTriggerJSON;
    /**
     * @deprecated This method will be removed soon. To format the value, use one of the properties.
     */
    format(): StreamTriggerJSON;
    get type(): "tx" | "log" | "erc20transfer" | "erc20approval" | "nfttransfer";
    get contractAddress(): StreamSelector | EvmAddress;
    get functionAbi(): unknown;
    get inputs(): (string | string[])[] | undefined;
    get topic0(): string | undefined;
    get callFrom(): StreamSelector | EvmAddress | undefined;
}

type EvmAbi = any[];

type EvmStreamAdvancedOptions = {
    topic0: string;
    filter?: Record<string, any>;
    includeNativeTxs?: boolean;
};
type GetNativeBalanceType = 'tx' | 'log' | 'erc20transfer' | 'erc20approval' | 'nfttransfer' | 'internalTx';
interface EvmStreamInput {
    webhookUrl: string;
    description: string;
    tag: string;
    topic0?: string[] | null;
    allAddresses?: boolean;
    includeNativeTxs?: boolean;
    includeContractLogs?: boolean;
    includeInternalTxs?: boolean;
    includeAllTxLogs?: boolean;
    abi?: EvmAbi | null;
    advancedOptions?: EvmStreamAdvancedOptions[] | null;
    chainIds: EvmChainish[];
    id: string;
    status: string;
    statusMessage: string;
    triggers?: StreamTriggerish[] | null;
    getNativeBalances?: {
        selectors: string[];
        type: GetNativeBalanceType;
    }[];
}
interface EvmStreamData {
    webhookUrl: string;
    description: string;
    tag: string;
    topic0?: string[];
    allAddresses: boolean;
    includeNativeTxs: boolean;
    includeContractLogs: boolean;
    includeInternalTxs: boolean;
    includeAllTxLogs: boolean;
    abi?: EvmAbi;
    advancedOptions?: EvmStreamAdvancedOptions[];
    chains: EvmChain[];
    id: string;
    status: string;
    statusMessage: string;
    triggers?: StreamTrigger[];
    getNativeBalances?: {
        selectors: string[];
        type: GetNativeBalanceType;
    }[];
}
type EvmStreamJSON = {
    webhookUrl: string;
    description: string;
    tag: string;
    topic0?: string[];
    allAddresses: boolean;
    includeNativeTxs: boolean;
    includeContractLogs: boolean;
    includeInternalTxs: boolean;
    includeAllTxLogs: boolean;
    abi?: EvmAbi;
    advancedOptions?: EvmStreamAdvancedOptions[];
    chainIds: (string | number)[];
    id: string;
    status: string;
    statusMessage: string;
    triggers?: StreamTriggerJSON[];
    getNativeBalances?: {
        selectors: string[];
        type: GetNativeBalanceType;
    }[];
};

type EvmStreamish = EvmStreamInput | EvmStream;
/**
 * The EvmStream class is a representation of Moralis Stream that is returned by the Moralis Stream API
 *
 * @category DataType
 */
declare class EvmStream implements MoralisDataObject {
    private _data;
    constructor(data: EvmStreamInput);
    /**
     * Create a new instance of EvmStream
     *
     * @param data - the EvmStreamish type
     * @example
     * ```ts
     * const evmStream = EvmStream.create(data);
     * ```
     * @returns an instance of EvmStream
     */
    static create(data: EvmStreamish): EvmStream;
    private static parse;
    /**
     * Compares two EvmStream data. It checks a deep equality check of both values.
     * @param valueA - the first EvmStreamish data to compare
     * @param valueB - the second EvmStreamish data to compare
     * @returns true if the values are equal, false otherwise
     * @example
     * ```ts
     *  EvmStream.equals(valueA, valueB);
     * ```
     */
    static equals(valueA: EvmStreamish, valueB: EvmStreamish): boolean;
    /**
     * Compares an EvmStreamish data to this EvmStream instance.
     * @param value - the value to compare
     * @returns true if the value is equal to the current instance, false otherwise
     * @example
     * ```ts
     * evmStream.equals(value);
     * ```
     */
    equals(value: EvmStreamish): boolean;
    /**
     * Converts the EvmStream instance to a JSON object.
     * @returns JSON object of the EvmStream instance
     * @example `evmStream.toJSON()`
     */
    toJSON(): EvmStreamJSON;
    /**
     * @deprecated This method will be removed soon. To format the value, use one of the properties.
     */
    format(): EvmStreamJSON;
    get chains(): EvmChain[];
    get chainIds(): string[];
    get webhookUrl(): string;
    get description(): string;
    get tag(): string;
    get topic0(): string[] | undefined;
    get allAddresses(): boolean;
    get includeNativeTxs(): boolean;
    get includeContractLogs(): boolean;
    get includeInternalTxs(): boolean;
    get includeAllTxLogs(): boolean;
    get abi(): EvmAbi | undefined;
    get advancedOptions(): EvmStreamAdvancedOptions[] | undefined;
    get id(): string;
    get status(): string;
    get statusMessage(): string;
    get triggers(): StreamTrigger[] | undefined;
    get getNativeBalances(): {
        selectors: string[];
        type: GetNativeBalanceType;
    }[] | undefined;
}

interface StreamNativeBalanceInput {
    address: EvmAddressish;
    balance: EvmNativeish;
}
interface StreamNativeBalanceData {
    address: EvmAddress;
    balance: EvmNative;
}
type StreamNativeBalanceJSON = {
    address: string;
    balance: string;
};

type StreamNativeBalanceish = StreamNativeBalance | StreamNativeBalanceInput | StreamNativeBalanceData;
/**
 * The NativeBalance class is a representation of a nativeBalance-address pair
 *
 * @category DataType
 */
declare class StreamNativeBalance implements MoralisDataObject {
    private readonly _data;
    constructor(data: StreamNativeBalanceInput);
    static create(data: StreamNativeBalanceish): StreamNativeBalance;
    private static parse;
    static equals(valueA: StreamNativeBalanceish, valueB: StreamNativeBalanceish): boolean;
    /**
     * Compares an NativeBalance data to this NativeBalance instance.
     * @param value - the value to compare
     * @returns true if the value is equal to the current instance, false otherwise
     * @example
     * ```ts
     * nativeBalanceTrigger.equals(value);
     * ```
     */
    equals(value: StreamNativeBalanceish): boolean;
    /**
     * Converts the NativeBalance instance to a JSON object.
     * @returns JSON object of the NativeBalance instance
     * @example `nativeBalanceTrigger.toJSON()`
     */
    toJSON(): StreamNativeBalanceJSON;
    /**
     * @deprecated This method will be removed soon. To format the value, use one of the properties.
     */
    format(): StreamNativeBalanceJSON;
    get address(): EvmAddress;
    get balance(): EvmNative;
}

interface StreamTriggerOutputInput {
    name: string;
    value: string;
}
interface StreamTriggerOutputData {
    name: string;
    value: string;
}
type StreamTriggerOutputJSON = {
    name: string;
    value: string;
};

type StreamTriggerOutputish = StreamTriggerOutput | StreamTriggerOutputInput | StreamTriggerOutputData;
/**
 * The StreamTrigger class is a representation of a stream trigger that is used by the Moralis Stream API
 *
 * @category DataType
 */
declare class StreamTriggerOutput implements MoralisDataObject {
    private readonly _data;
    constructor(data: StreamTriggerOutputInput);
    static create(data: StreamTriggerOutputish): StreamTriggerOutput;
    private static parse;
    /**
     * Compares two StreamTriggerOutput data. It checks a deep equality check of both values.
     * @param valueA - the first StreamTriggerOutputish data to compare
     * @param valueB - the second StreamTriggerOutputish data to compare
     * @returns true if the values are equal, false otherwise
     * @example
     * ```ts
     *  StreamTriggerOutput.equals(valueA, valueB);
     * ```
     */
    static equals(valueA: StreamTriggerOutputish, valueB: StreamTriggerOutputish): boolean;
    /**
     * Compares two StreamTriggerOutput arrays. It checks a deep equality check of both values, meaning that all the values have to be on both arrays.
     * @param valueA - the first StreamTriggerOutputish[] data to compare
     * @param valueB - the second StreamTriggerOutputish[] data to compare
     * @returns true if all values are equal, false otherwise
     * @example
     * ```ts
     *  StreamTriggerOutput.arrayEquals(valueA, valueB);
     * ```
     */
    static arrayEquals(valueA: StreamTriggerOutputish[], valueB: StreamTriggerOutputish[]): boolean;
    /**
     * Compares an StreamTriggerOutputish data to this StreamTriggerOutput instance.
     * @param value - the value to compare
     * @returns true if the value is equal to the current instance, false otherwise
     * @example
     * ```ts
     * streamTriggerOutput.equals(value);
     * ```
     */
    equals(value: StreamTriggerOutputish): boolean;
    /**
     * Converts the StreamTriggerOutput instance to a JSON object.
     * @returns JSON object of the StreamTriggerOutput instance
     * @example `streamTriggerOutput.toJSON()`
     */
    toJSON(): StreamTriggerOutputJSON;
    /**
     * @deprecated This method will be removed soon. To format the value, use one of the properties.
     */
    format(): StreamTriggerOutputJSON;
    get name(): string;
    get value(): string;
}

interface StreamErc1155ApprovalInput {
    chain: EvmChainish;
    transactionHash: string;
    contract: EvmAddressish;
    logIndex: number | string;
    account: EvmAddressish;
    operator: EvmAddressish;
    approved: boolean;
    tokenContractType: string;
    tokenName: string;
    tokenSymbol: string;
    triggers?: StreamTriggerOutputish[];
}
interface StreamErc1155ApprovalData {
    chain: EvmChain;
    transactionHash: string;
    contract: EvmAddress;
    logIndex: number;
    account: EvmAddress;
    operator: EvmAddress;
    approved: boolean;
    tokenContractType: string;
    tokenName: string;
    tokenSymbol: string;
    triggers?: StreamTriggerOutput[];
}
type StreamErc1155ApprovalJSON = {
    chain: number | string;
    transactionHash: string;
    contract: string;
    logIndex: number | string;
    account: string;
    operator: string;
    approved: boolean;
    tokenContractType: string;
    tokenName: string;
    tokenSymbol: string;
    triggers?: StreamTriggerOutputJSON[];
};

type StreamErc1155Approvalish = StreamErc1155ApprovalInput | StreamErc1155Approval;
/**
 * The StreamErc1155Approval class is a representation of a nft approval (ERC1155) that is returned by the Moralis Stream API
 *
 * @category DataType
 */
declare class StreamErc1155Approval implements MoralisDataObject {
    /**
     * Create a new instance of StreamErc1155Approval
     *
     * @param data - the StreamErc1155Approvalish type
     * @example
     * ```ts
     * const evmNftApproval = StreamErc1155Approval.create(data);
     * ```
     * @returns an instance of StreamErc1155Approval
     */
    static create(data: StreamErc1155Approvalish): StreamErc1155Approval;
    private _data;
    constructor(data: StreamErc1155ApprovalInput);
    private static parse;
    /**
     * Compares two StreamErc1155Approval data. It checks a deep equality check of both values.
     * @param valueA - the first StreamErc1155Approvalish data to compare
     * @param valueB - the second StreamErc1155Approvalish data to compare
     * @returns true if the values are equal, false otherwise
     * @example
     * ```ts
     *  StreamErc1155Approval.equals(valueA, valueB);
     * ```
     */
    static equals(valueA: StreamErc1155Approvalish, valueB: StreamErc1155Approvalish): boolean;
    /**
     * Compares an StreamErc1155Approvalish data to this StreamErc1155Approval instance.
     * @param value - the value to compare
     * @returns true if the value is equal to the current instance, false otherwise
     * @example
     * ```ts
     * evmNftApproval.equals(value);
     * ```
     */
    equals(value: StreamErc1155Approvalish): boolean;
    /**
     * Converts the StreamErc1155Approval instance to a JSON object.
     * @returns JSON object of the StreamErc1155Approval instance
     * @example `evmNftApproval.toJSON()`
     */
    toJSON(): StreamErc1155ApprovalJSON;
    /**
     * Converts the StreamErc1155Approval instance to a JSON object.
     * @returns JSON object of the StreamErc1155Approval instance
     * @example `evmNftApproval.format()`
     */
    format(): StreamErc1155ApprovalJSON;
    get chain(): EvmChain;
    get approved(): boolean;
    get transactionHash(): string;
    get contract(): EvmAddress;
    get logIndex(): number;
    get account(): EvmAddress;
    get operator(): EvmAddress;
    get tokenContractType(): string;
    get tokenName(): string;
    get tokenSymbol(): string;
    get triggers(): StreamTriggerOutput[] | undefined;
}

interface StreamErc721ApprovalInput {
    chain: EvmChainish;
    owner: EvmAddressish;
    transactionHash: string;
    contract: EvmAddressish;
    logIndex: number | string;
    approved: EvmAddressish;
    tokenId: string;
    tokenContractType: string;
    tokenName: string;
    tokenSymbol: string;
    triggers?: StreamTriggerOutputish[];
}
interface StreamErc721ApprovalData {
    chain: EvmChain;
    owner: EvmAddress;
    transactionHash: string;
    contract: EvmAddress;
    logIndex: number;
    approved: EvmAddress;
    tokenId: string;
    tokenContractType: string;
    tokenName: string;
    tokenSymbol: string;
    triggers?: StreamTriggerOutput[];
}
type StreamErc721ApprovalJSON = {
    chain: number | string;
    owner: string;
    transactionHash: string;
    contract: string;
    logIndex: number;
    approved: string;
    tokenId: string;
    tokenContractType: string;
    tokenName: string;
    tokenSymbol: string;
    triggers?: StreamTriggerOutputJSON[];
};

type StreamErc721Approvalish = StreamErc721ApprovalInput | StreamErc721Approval;
/**
 * The StreamErc1155Approval class is a representation of a nft approval (ERC721) that is returned by the Moralis Stream API
 *
 * @category DataType
 */
declare class StreamErc721Approval implements MoralisDataObject {
    /**
     * Create a new instance of StreamErc721Approval
     *
     * @param data - the StreamErc721Approvalish type
     * @example
     * ```ts
     * const evmNftApproval = StreamErc721Approval.create(data);
     * ```
     * @returns an instance of StreamErc721Approval
     */
    static create(data: StreamErc721Approvalish): StreamErc721Approval;
    private _data;
    constructor(data: StreamErc721ApprovalInput);
    private static parse;
    /**
     * Compares two StreamErc721Approval data. It checks a deep equality check of both values.
     * @param valueA - the first StreamErc721Approvalish data to compare
     * @param valueB - the second StreamErc721Approvalish data to compare
     * @returns true if the values are equal, false otherwise
     * @example
     * ```ts
     *  StreamErc721Approval.equals(valueA, valueB);
     * ```
     */
    static equals(valueA: StreamErc721Approvalish, valueB: StreamErc721Approvalish): boolean;
    /**
     * Compares an StreamErc721Approvalish data to this StreamErc721Approval instance.
     * @param value - the value to compare
     * @returns true if the value is equal to the current instance, false otherwise
     * @example
     * ```ts
     * evmNftApproval.equals(value);
     * ```
     */
    equals(value: StreamErc721Approvalish): boolean;
    /**
     * Converts the StreamErc721Approval instance to a JSON object.
     * @returns JSON object of the StreamErc721Approval instance
     * @example `evmNftApproval.toJSON()`
     */
    toJSON(): StreamErc721ApprovalJSON;
    /**
     * @deprecated This method will be removed soon. To format the value, use one of the properties.
     */
    format(): StreamErc721ApprovalJSON;
    get chain(): EvmChain;
    get approved(): EvmAddress;
    get owner(): EvmAddress;
    get transactionHash(): string;
    get contract(): EvmAddress;
    get logIndex(): number;
    get tokenId(): string;
    get tokenContractType(): string;
    get tokenName(): string;
    get tokenSymbol(): string;
    get triggers(): StreamTriggerOutput[] | undefined;
}

interface StreamErc20ApprovalInput {
    chain: EvmChainish;
    transactionHash: string;
    contract: EvmAddressish;
    logIndex: string | number;
    owner: EvmAddressish;
    spender: EvmAddressish;
    value: BigNumberish;
    tokenDecimals: number | string;
    tokenName: string;
    tokenSymbol: string;
    valueWithDecimals?: null | string;
    triggers?: StreamTriggerOutputish[];
}
interface StreamErc20ApprovalData {
    chain: EvmChain;
    transactionHash: string;
    contract: EvmAddress;
    logIndex: string | number;
    owner: EvmAddress;
    spender: EvmAddress;
    value: BigNumber;
    tokenDecimals?: number;
    tokenName: string;
    tokenSymbol: string;
    valueWithDecimals?: string;
    triggers?: StreamTriggerOutput[];
}
type StreamErc20ApprovalJSON = {
    chain: number | string;
    transactionHash: string;
    contract: string;
    logIndex: string | number;
    owner: string;
    spender: string;
    value: string;
    tokenDecimals?: number;
    tokenName: string;
    tokenSymbol: string;
    valueWithDecimals?: string;
    triggers?: StreamTriggerOutputJSON[];
};

type StreamErc20Approvalish = StreamErc20ApprovalInput | StreamErc20Approval;
/**
 * The StreamErc20Transfer class is a representation of a erc20 approval that is returned by the Moralis Stream API
 *
 * @category DataTypexw
 */
declare class StreamErc20Approval implements MoralisDataObject {
    /**
     * Create a new instance of StreamErc20Approval
     *
     * @param data - the StreamErc20Approvalish type
     * @example
     * ```ts
     * const erc20Approval = StreamErc20Approval.create(data);
     * ```
     * @returns an instance of StreamErc20Approval
     */
    static create(data: StreamErc20Approvalish): StreamErc20Approval;
    private _data;
    constructor(data: StreamErc20ApprovalInput);
    private static parse;
    /**
     * Compares two StreamErc20Approval data. It checks a deep equality check of both values.
     * @param valueA - the first StreamErc20Approvalish data to compare
     * @param valueB - the second StreamErc20Approvalish data to compare
     * @returns true if the values are equal, false otherwise
     * @example
     * ```ts
     *  StreamErc20Approval.equals(valueA, valueB);
     * ```
     */
    static equals(valueA: StreamErc20Approvalish, valueB: StreamErc20Approvalish): boolean;
    /**
     * Compares an StreamErc20Approvalish data to this StreamErc20Approval instance.
     * @param value - the value to compare
     * @returns true if the value is equal to the current instance, false otherwise
     * @example
     * ```ts
     * erc20Approval.equals(value);
     * ```
     */
    equals(value: StreamErc20Approvalish): boolean;
    /**
     * Converts the StreamErc20Approval instance to a JSON object.
     * @returns JSON object of the StreamErc20Approval instance
     * @example `erc20Approval.toJSON()`
     */
    toJSON(): StreamErc20ApprovalJSON;
    /**
     * @deprecated This method will be removed soon. To format the value, use one of the properties.
     */
    format(): StreamErc20ApprovalJSON;
    get chain(): EvmChain;
    get transactionHash(): string;
    get logIndex(): string | number;
    get owner(): EvmAddress;
    get spender(): EvmAddress;
    get value(): BigNumber;
    get contract(): EvmAddress;
    get tokenName(): string;
    get tokenSymbol(): string;
    get tokenDecimals(): number | undefined;
    get valueWithDecimals(): string | undefined;
    get triggers(): StreamTriggerOutput[] | undefined;
}

interface StreamErc20TransferInput {
    chain: EvmChainish;
    transactionHash: string;
    contract: EvmAddressish;
    logIndex: string | number;
    from: EvmAddressish;
    to: EvmAddressish;
    value: BigNumberish;
    tokenDecimals: number | string;
    tokenName: string;
    tokenSymbol: string;
    valueWithDecimals?: null | string;
    triggers?: StreamTriggerOutputish[];
}
interface StreamErc20TransferData {
    chain: EvmChain;
    transactionHash: string;
    contract: EvmAddress;
    logIndex: string | number;
    from: EvmAddress;
    to: EvmAddress;
    value: BigNumber;
    tokenDecimals?: number;
    tokenName: string;
    tokenSymbol: string;
    valueWithDecimals?: string;
    triggers?: StreamTriggerOutput[];
}
type StreamErc20TransferJSON = {
    chain: number | string;
    transactionHash: string;
    contract: string;
    logIndex: string | number;
    from: string;
    to: string;
    value: string;
    tokenDecimals?: number;
    tokenName: string;
    tokenSymbol: string;
    valueWithDecimals?: string;
    triggers?: StreamTriggerOutputJSON[];
};

type StreamErc20Transferish = StreamErc20TransferInput | StreamErc20Transfer;
/**
 * The StreamErc20Transfer class is a representation of a erc20 transfer that is returned by the Moralis Stream API
 *
 * @category DataType
 */
declare class StreamErc20Transfer implements MoralisDataObject {
    private _data;
    constructor(data: StreamErc20TransferInput);
    /**
     * Create a new instance of StreamErc20Transfer
     *
     * @param data - the StreamErc20Transferish type
     * @example
     * ```ts
     * const erc20Transfer = StreamErc20Transfer.create(data);
     * ```
     * @returns an instance of StreamErc20Transfer
     */
    static create(data: StreamErc20Transferish): StreamErc20Transfer;
    private static parse;
    /**
     * Compares two StreamErc20Transfer data. It checks a deep equality check of both values.
     * @param valueA - the first StreamErc20Transferish data to compare
     * @param valueB - the second StreamErc20Transferish data to compare
     * @returns true if the values are equal, false otherwise
     * @example
     * ```ts
     *  StreamErc20Transfer.equals(valueA, valueB);
     * ```
     */
    static equals(valueA: StreamErc20Transferish, valueB: StreamErc20Transferish): boolean;
    /**
     * Compares an StreamErc20Transferish data to this StreamErc20Transfer instance.
     * @param value - the value to compare
     * @returns true if the value is equal to the current instance, false otherwise
     * @example
     * ```ts
     * erc20Transfer.equals(value);
     * ```
     */
    equals(value: StreamErc20Transferish): boolean;
    /**
     * Converts the StreamErc20Transfer instance to a JSON object.
     * @returns JSON object of the StreamErc20Transfer instance
     * @example `erc20Transfer.toJSON()`
     */
    toJSON(): StreamErc20TransferJSON;
    /**
     * @deprecated This method will be removed soon. To format the value, use one of the properties.
     */
    format(): StreamErc20TransferJSON;
    get chain(): EvmChain;
    get transactionHash(): string;
    get logIndex(): string | number;
    get from(): EvmAddress;
    get to(): EvmAddress;
    get value(): BigNumber;
    get contract(): EvmAddress;
    get tokenName(): string;
    get tokenSymbol(): string;
    get tokenDecimals(): number | undefined;
    get valueWithDecimals(): string | undefined;
    get triggers(): StreamTriggerOutput[] | undefined;
}

interface StreamEvmInternalTransactionInput {
    chain: EvmChainish;
    from?: null | EvmAddressish;
    to?: null | EvmAddressish;
    value?: null | BigNumberish;
    transactionHash: string;
    gas?: null | BigNumberish;
    triggers?: StreamTriggerOutputish[];
}
interface StreamEvmInternalTransactionData {
    chain: EvmChain;
    from?: EvmAddress;
    to?: EvmAddress;
    value?: BigNumber;
    transactionHash: string;
    gas?: BigNumber;
    triggers?: StreamTriggerOutput[];
}
type StreamEvmInternalTransactionJSON = {
    chain: string | number;
    from?: string;
    to?: string;
    value?: string;
    transactionHash: string;
    gas?: string;
    triggers?: StreamTriggerOutputJSON[];
};

type StreamEvmInternalTransactionish = StreamEvmInternalTransactionInput | StreamEvmInternalTransaction;
/**
 * The StreamEvmInternalTransaction class is a representation of an internal transaction that is returned by the Moralis Stream API
 *
 * @category DataType
 */
declare class StreamEvmInternalTransaction implements MoralisDataObject {
    private _data;
    constructor(data: StreamEvmInternalTransactionInput);
    /**
     * Create a new instance of StreamEvmInternalTransactionish
     *
     * @param data - the StreamEvmInternalTransactionishish type
     * @example
     * ```ts
     * const transaction = StreamEvmTransactionish.create(data);
     * ```
     * @returns an instance of StreamEvmInternalTransaction
     */
    static create(data: StreamEvmInternalTransactionish): StreamEvmInternalTransaction;
    private static parse;
    /**
     * Compares two StreamEvmInternalTransaction data. It checks a deep equality check of both values.
     * @param valueA - the first StreamEvmInternalTransactionish data to compare
     * @param valueB - the second StreamEvmInternalTransactionish data to compare
     * @returns true if the values are equal, false otherwise
     * @example
     * ```ts
     *  StreamEvmInternalTransaction.equals(valueA, valueB);
     * ```
     */
    static equals(valueA: StreamEvmInternalTransactionish, valueB: StreamEvmInternalTransactionish): boolean;
    /**
     * Compares an StreamEvmInternalTransactionish data to this StreamEvmInternalTransaction instance.
     * @param value - the value to compare
     * @returns true if the value is equal to the current instance, false otherwise
     * @example
     * ```ts
     * evmInternalTransaction.equals(value);
     * ```
     */
    equals(value: StreamEvmInternalTransactionish): boolean;
    /**
     * Converts the StreamEvmInternalTransaction instance to a JSON object.
     * @returns JSON object of the StreamEvmInternalTransaction instance
     * @example `evmInternalTransaction.toJSON()`
     */
    toJSON(): StreamEvmInternalTransactionJSON;
    /**
     * @deprecated This method will be removed soon. To format the value, use one of the properties.
     */
    format(): StreamEvmInternalTransactionJSON;
    get chain(): EvmChain;
    get from(): EvmAddress | undefined;
    get to(): EvmAddress | undefined;
    get value(): BigNumber | undefined;
    get transactionHash(): string;
    get gas(): BigNumber | undefined;
    get triggers(): StreamTriggerOutput[] | undefined;
}

interface StreamEvmNftTransferInput {
    chain: EvmChainish;
    transactionHash: string;
    contract: EvmAddressish;
    logIndex: string | number;
    operator?: EvmAddressish | null;
    from: EvmAddressish;
    to: EvmAddressish;
    tokenId: string;
    amount: string | number;
    tokenContractType: string;
    tokenName: string;
    tokenSymbol: string;
    triggers?: StreamTriggerOutputish[];
}
interface StreamEvmNftTransferData {
    chain: EvmChain;
    transactionHash: string;
    contract: EvmAddress;
    logIndex: number;
    operator?: EvmAddress;
    from: EvmAddress;
    to: EvmAddress;
    tokenId: string;
    amount: number;
    tokenContractType: string;
    tokenName: string;
    tokenSymbol: string;
    triggers?: StreamTriggerOutput[];
}
type StreamEvmNftTransferJSON = {
    chain: string | number;
    transactionHash: string;
    contract: string;
    logIndex: number;
    operator?: string;
    from: string;
    to: string;
    tokenId: string;
    amount: number;
    tokenContractType: string;
    tokenName: string;
    tokenSymbol: string;
    triggers?: StreamTriggerOutputJSON[];
};

type StreamEvmNftTransferish = StreamEvmNftTransfer | StreamEvmNftTransferInput;
/**
 * The StreamEvmNftTransfer class is a representation of a nft transfer (EREC721 or ERC1155) that is returned by the Moralis Stream API
 *
 * @category DataType
 */
declare class StreamEvmNftTransfer implements MoralisDataObject {
    private _data;
    constructor(data: StreamEvmNftTransferInput);
    /**
     * Create a new instance of StreamEvmNftTransferish
     *
     * @param data - the StreamEvmNftTransferishish type
     * @example
     * ```ts
     * const transfer = StreamEvmTransactionish.create(data);
     * ```
     * @returns an instance of StreamEvmNftTransfer
     */
    static create(data: StreamEvmNftTransferish): StreamEvmNftTransfer;
    private static parse;
    /**
     * Compares two StreamEvmNftTransfer data. It checks a deep equality check of both values.
     * @param valueA - the first StreamEvmNftTransferish data to compare
     * @param valueB - the second StreamEvmNftTransferish data to compare
     * @returns true if the values are equal, false otherwise
     * @example
     * ```ts
     *  StreamEvmNftTransfer.equals(valueA, valueB);
     * ```
     */
    static equals(valueA: StreamEvmNftTransferish, valueB: StreamEvmNftTransferish): boolean;
    /**
     * Compares an StreamEvmNftTransferish data to this StreamEvmNftTransfer instance.
     * @param value - the value to compare
     * @returns true if the value is equal to the current instance, false otherwise
     * @example
     * ```ts
     * transfer.equals(value);
     * ```
     */
    equals(value: StreamEvmNftTransferish): boolean;
    /**
     * Converts the StreamEvmNftTransfer instance to a JSON object.
     * @returns JSON object of the StreamEvmNftTransfer instance
     * @example `transfer.toJSON()`
     */
    toJSON(): StreamEvmNftTransferJSON;
    /**
     * @deprecated This method will be removed soon. To format the value, use one of the properties.
     */
    format(): StreamEvmNftTransferJSON;
    get chain(): EvmChain;
    get transactionHash(): string;
    get from(): EvmAddress;
    get to(): EvmAddress;
    get contract(): EvmAddress;
    get logIndex(): number;
    get tokenId(): string;
    get amount(): number;
    get tokenContractType(): string;
    get tokenName(): string;
    get tokenSymbol(): string;
    get operator(): EvmAddress | undefined;
    get triggers(): StreamTriggerOutput[] | undefined;
}

interface StreamEvmTransactionInput {
    chain: EvmChainish;
    hash: string;
    gas?: BigNumberish | null;
    gasPrice?: BigNumberish | null;
    nonce?: BigNumberish | null;
    input?: string | null;
    transactionIndex: number | string;
    fromAddress: EvmAddressish;
    toAddress?: EvmAddressish | null;
    value?: BigNumberish | null;
    type?: number | string | null;
    receiptCumulativeGasUsed?: BigNumberish | null;
    receiptGasUsed?: BigNumberish | null;
    receiptContractAddress?: EvmAddressish | null;
    receiptRoot?: string | null;
    receiptStatus?: number | string | null;
    r?: string | null;
    s?: string | null;
    v?: number | string | null;
    triggers?: StreamTriggerOutputish[];
}
interface StreamEvmTransactionData {
    chain: EvmChain;
    hash: string;
    gas?: BigNumber;
    gasPrice?: BigNumber;
    nonce?: BigNumber;
    input?: string;
    transactionIndex: number;
    fromAddress: EvmAddress;
    toAddress?: EvmAddress;
    value?: BigNumber;
    type?: number;
    receiptCumulativeGasUsed?: BigNumber;
    receiptGasUsed?: BigNumber;
    receiptContractAddress?: EvmAddress;
    receiptRoot?: string;
    receiptStatus?: number;
    signature?: EvmSignature;
    triggers?: StreamTriggerOutput[];
}
type StreamEvmTransactionJSON = {
    chain: string | number;
    hash: string;
    gas?: string;
    gasPrice?: string;
    nonce?: string;
    input?: string;
    transactionIndex: number;
    fromAddress: string;
    toAddress?: string;
    value?: string;
    type?: number;
    receiptCumulativeGasUsed?: string;
    receiptGasUsed?: string;
    receiptContractAddress?: string;
    receiptRoot?: string;
    receiptStatus?: number;
    r?: string;
    s?: string;
    v?: number;
    triggers?: StreamTriggerOutputJSON[];
};

type StreamEvmTransactionish = StreamEvmTransaction | StreamEvmTransactionInput;
/**
 * The StreamEvmTransaction class is a representation of a transaction that is returned by the Moralis Stream API
 *
 * @category DataType
 */
declare class StreamEvmTransaction implements MoralisDataObject {
    private _data;
    constructor({ ...data }: StreamEvmTransactionInput);
    /**
     * Create a new instance of StreamEvmTransactionish
     *
     * @param data - the StreamEvmTransactionishish type
     * @example
     * ```ts
     * const transaction = StreamEvmTransactionish.create(data);
     * ```
     * @returns an instance of StreamEvmTransaction
     */
    static create(data: StreamEvmTransactionish): StreamEvmTransaction;
    private static parse;
    /**
     * Compares two StreamEvmTransaction data. It checks a deep equality check of both values.
     * @param valueA - the first StreamEvmTransactionish data to compare
     * @param valueB - the second StreamEvmTransactionish data to compare
     * @returns true if the values are equal, false otherwise
     * @example
     * ```ts
     *  StreamEvmTransaction.equals(valueA, valueB);
     * ```
     */
    static equals(valueA: StreamEvmTransactionish, valueB: StreamEvmTransactionish): boolean;
    /**
     * Compares an StreamEvmTransactionish data to this StreamEvmTransaction instance.
     * @param value - the value to compare
     * @returns true if the value is equal to the current instance, false otherwise
     * @example
     * ```ts
     * transaction.equals(value);
     * ```
     */
    equals(value: StreamEvmTransactionish): boolean;
    /**
     * Converts the StreamEvmTransaction instance to a JSON object.
     * @returns JSON object of the StreamEvmTransaction instance
     * @example `transaction.toJSON()`
     */
    toJSON(): StreamEvmTransactionJSON;
    /**
     * @deprecated This method will be removed soon. To format the value, use one of the properties.
     */
    format(): StreamEvmTransactionJSON;
    get chain(): EvmChain;
    get input(): string | undefined;
    get transactionIndex(): number;
    get fromAddress(): EvmAddress;
    get toAddress(): EvmAddress | undefined;
    get receiptGasUsed(): BigNumber | undefined;
    get receiptCumulativeGasUsed(): BigNumber | undefined;
    get receiptContractAddress(): EvmAddress | undefined;
    get signature(): EvmSignature | undefined;
    get r(): string | undefined;
    get s(): string | undefined;
    get v(): number | undefined;
    get hash(): string;
    get gas(): BigNumber | undefined;
    get gasPrice(): BigNumber | undefined;
    get nonce(): BigNumber | undefined;
    get value(): BigNumber | undefined;
    get type(): number | undefined;
    get receiptRoot(): string | undefined;
    get receiptStatus(): number | undefined;
    get triggers(): StreamTriggerOutput[] | undefined;
}

interface StreamEvmTransactionLogInput {
    chain: EvmChainish;
    logIndex: number | string;
    transactionHash: string;
    address: EvmAddressish;
    data: string;
    topic0?: string | null;
    topic1?: string | null;
    topic2?: string | null;
    topic3?: string | null;
    triggers?: StreamTriggerOutputish[];
}
interface StreamEvmTransactionLogData {
    chain: EvmChain;
    logIndex: number;
    transactionHash: string;
    address: EvmAddress;
    data: string;
    topic0?: string;
    topic1?: string;
    topic2?: string;
    topic3?: string;
    triggers?: StreamTriggerOutput[];
}
type StreamEvmTransactionLogJSON = {
    chain: string | number;
    logIndex: number;
    transactionHash: string;
    address: string;
    data: string;
    topic0?: string;
    topic1?: string;
    topic2?: string;
    topic3?: string;
    triggers?: StreamTriggerOutputJSON[];
};

type StreamEvmTransactionLogish = StreamEvmTransactionLog | StreamEvmTransactionLogInput;
/**
 * The StreamEvmTransactionLog class is a representation of a transaction log that is returned by the Moralis Stream API
 *
 * @category DataType
 */
declare class StreamEvmTransactionLog implements MoralisDataObject {
    private _data;
    constructor({ ...data }: StreamEvmTransactionLogInput);
    /**
     * Create a new instance of StreamEvmTransactionLog
     *
     * @param data - the StreamEvmTransactionLogish type
     * @example
     * ```ts
     * const transactionLog = StreamEvmTransactionLog.create(data);
     * ```
     * @returns an instance of StreamEvmTransactionLog
     */
    static create(data: StreamEvmTransactionLogish): StreamEvmTransactionLog;
    private static parse;
    /**
     * Compares two StreamEvmTransactionLog data. It checks a deep equality check of both values.
     * @param valueA - the first StreamEvmTransactionLogish data to compare
     * @param valueB - the second StreamEvmTransactionLogish data to compare
     * @returns true if the values are equal, false otherwise
     * @example
     * ```ts
     *  StreamEvmTransactionLog.equals(valueA, valueB);
     * ```
     */
    static equals(valueA: StreamEvmTransactionLogish, valueB: StreamEvmTransactionLogish): boolean;
    /**
     * Compares an StreamEvmTransactionLogish data to this StreamEvmTransactionLog instance.
     * @param value - the value to compare
     * @returns true if the value is equal to the current instance, false otherwise
     * @example
     * ```ts
     * transactionLog.equals(value);
     * ```
     */
    equals(value: StreamEvmTransactionLogish): boolean;
    /**
     * Converts the StreamEvmTransactionLog instance to a JSON object.
     * @returns JSON object of the StreamEvmTransactionLog instance
     * @example `transactionLog.toJSON()`
     */
    toJSON(): StreamEvmTransactionLogJSON;
    /**
     * @deprecated This method will be removed soon. To format the value, use one of the properties.
     */
    format(): StreamEvmTransactionLogJSON;
    get chain(): EvmChain;
    get logIndex(): number;
    get transactionHash(): string;
    get address(): EvmAddress;
    get data(): string;
    get topic0(): string | undefined;
    get topic1(): string | undefined;
    get topic2(): string | undefined;
    get topic3(): string | undefined;
    get triggers(): StreamTriggerOutput[] | undefined;
}

type StreamEvmNftTokenApprovalish = INFTApproval & {
    chain: EvmChainish;
};
type StreamEvmNftTokenApprovalData = INFTApproval & {
    chain: EvmChain;
};

/**
 * The `StreamEvmNftTokenApproval` class is a representation of the NFT approval data.
 *
 * @category DataType
 */
declare class StreamEvmNftTokenApproval implements StreamEvmNftTokenApprovalData, MoralisDataObject {
    private readonly data;
    static create(data: StreamEvmNftTokenApprovalish): StreamEvmNftTokenApproval;
    private constructor();
    get chain(): EvmChain;
    get contract(): string;
    get account(): string;
    get operator(): string;
    get approvedAll(): boolean;
    get tokenId(): string | null;
    get transactionHash(): string;
    get logIndex(): string;
    get tokenContractType(): string;
    get tokenName(): string;
    get tokenSymbol(): string;
    toJSON(): MoralisDataObjectValue;
    format(): MoralisDataFormatted;
    equals(value: this): boolean;
}

interface EvmStreamResultData {
    chain: EvmChain;
    retries: number;
    confirmed: boolean;
    block: EvmSimpleBlock;
    erc20Transfers: StreamErc20Transfer[];
    erc20Approvals: StreamErc20Approval[];
    nftTransfers: StreamEvmNftTransfer[];
    /**
     * @deprecated Use `ntfTokenApprovals` instead. This property will be removed in the future.
     */
    nftApprovals: {
        ERC721: StreamErc721Approval[];
        ERC1155: StreamErc1155Approval[];
    };
    ntfTokenApprovals: StreamEvmNftTokenApproval[];
    logs: StreamEvmTransactionLog[];
    txs: StreamEvmTransaction[];
    txsInternal: StreamEvmInternalTransaction[];
    abi: EvmAbi;
    tag: string;
    streamId: string;
    nativeBalances: StreamNativeBalance[];
}
type EvmStreamResultInput = IWebhook;

type EvmStreamResultish = EvmStreamResultInput | EvmStreamResult;
/**
 * The EvmStreamResult class is representation of the webhook data that is returned from the Stream api
 *
 * @category DataType
 */
declare class EvmStreamResult implements MoralisDataObject {
    /**
     * Create a new instance of EvmStreamResult
     *
     * @param data - the EvmStreamResultish type
     * @param core - the Core instance
     * @example
     * ```ts
     * const evmStreamResult = EvmStreamResult.create(data);
     * ```
     * @returns an instance of EvmStreamResult
     */
    static create(data: EvmStreamResultish): EvmStreamResult;
    private _data;
    constructor(data: EvmStreamResultInput);
    private static parse;
    /**
     * Compares two EvmStreamResult data. It checks a deep equality check of both values.
     * @param valueA - the first EvmStreamResultish data to compare
     * @param valueB - the second EvmStreamResultish data to compare
     * @returns true if the values are equal, false otherwise
     * @example
     * ```ts
     *  EvmStreamResult.equals(valueA, valueB);
     * ```
     */
    static equals(valueA: EvmStreamResultish, valueB: EvmStreamResultish): boolean;
    /**
     * Compares an EvmStreamResultish data to this EvmStreamResult instance.
     * @param value - the value to compare
     * @returns true if the value is equal to the current instance, false otherwise
     * @example
     * ```ts
     * evmStreamResult.equals(value);
     * ```
     */
    equals(value: EvmStreamResultish): boolean;
    /**
     * Converts the EvmStreamResult instance to a JSON object.
     * @returns JSON object of the EvmStreamResult instance
     * @example `evmStreamResult.toJSON()`
     */
    toJSON(): {
        erc20Transfers: StreamErc20TransferJSON[];
        erc20Approvals: StreamErc20ApprovalJSON[];
        nftTransfers: StreamEvmNftTransferJSON[];
        nftApprovals: {
            ERC721: StreamErc721ApprovalJSON[];
            ERC1155: StreamErc1155ApprovalJSON[];
        };
        ntfTokenApprovals: _moralisweb3_common_core.MoralisDataObjectValue[];
        chain: string;
        block: {
            number: string;
            chain: string;
            timestamp: Date;
            hash: string;
        };
        logs: StreamEvmTransactionLogJSON[];
        txs: StreamEvmTransactionJSON[];
        txsInternal: StreamEvmInternalTransactionJSON[];
        abi: EvmAbi;
        nativeBalances: StreamNativeBalanceJSON[];
        retries: number;
        confirmed: boolean;
        tag: string;
        streamId: string;
    };
    /**
     * @deprecated This method will be removed soon. To format the value, use one of the properties.
     */
    format(): {
        erc20Transfers: StreamErc20TransferJSON[];
        erc20Approvals: StreamErc20ApprovalJSON[];
        nftTransfers: StreamEvmNftTransferJSON[];
        nftApprovals: {
            ERC721: StreamErc721ApprovalJSON[];
            ERC1155: StreamErc1155ApprovalJSON[];
        };
        ntfTokenApprovals: _moralisweb3_common_core.MoralisDataObjectValue[];
        chain: string;
        block: {
            number: string;
            chain: string;
            timestamp: Date;
            hash: string;
        };
        logs: StreamEvmTransactionLogJSON[];
        txs: StreamEvmTransactionJSON[];
        txsInternal: StreamEvmInternalTransactionJSON[];
        abi: EvmAbi;
        nativeBalances: StreamNativeBalanceJSON[];
        retries: number;
        confirmed: boolean;
        tag: string;
        streamId: string;
    };
    get abiInterface(): Interface | null;
    get decodedLogs(): _ethersproject_abi.LogDescription[];
    get chain(): _moralisweb3_common_evm_utils.EvmChain;
    get streamId(): string;
    get tag(): string;
    get block(): _moralisweb3_common_evm_utils.EvmSimpleBlock;
    get retries(): number;
    get confirmed(): boolean;
    get erc20Approvals(): StreamErc20Approval[];
    get erc20Transfers(): StreamErc20Transfer[];
    get logs(): StreamEvmTransactionLog[];
    /**
     * @deprecated Use `ntfTokenApprovals` instead. This property will be removed in the future.
     */
    get nftApprovals(): {
        ERC721: StreamErc721Approval[];
        ERC1155: StreamErc1155Approval[];
    };
    get ntfTokenApprovals(): StreamEvmNftTokenApproval[];
    get nftTransfers(): StreamEvmNftTransfer[];
    get txs(): StreamEvmTransaction[];
    get txsInternal(): StreamEvmInternalTransaction[];
    get abi(): EvmAbi;
    get nativeBalances(): StreamNativeBalance[];
}

interface components {
    schemas: {
        /**
         * Format: uuid
         * @description Stringified UUIDv4.
         * See [RFC 4112](https://tools.ietf.org/html/rfc4122)
         */
        UUID: string;
        Block: {
            number: string;
            hash: string;
            timestamp: string;
        };
        TriggerOutput: {
            value: unknown;
            name: string;
        };
        Log: {
            triggers?: components["schemas"]["TriggerOutput"][];
            logIndex: string;
            transactionHash: string;
            address: string;
            data: string;
            topic0: string | null;
            topic1: string | null;
            topic2: string | null;
            topic3: string | null;
        };
        Transaction: {
            triggers?: components["schemas"]["TriggerOutput"][];
            hash: string;
            gas: string | null;
            gasPrice: string | null;
            nonce: string | null;
            input: string | null;
            transactionIndex: string;
            fromAddress: string;
            toAddress: string | null;
            value: string | null;
            type: string | null;
            v: string | null;
            r: string | null;
            s: string | null;
            receiptCumulativeGasUsed: string | null;
            receiptGasUsed: string | null;
            receiptContractAddress: string | null;
            receiptRoot: string | null;
            receiptStatus: string | null;
        };
        InternalTransaction: {
            from: string | null;
            to: string | null;
            value: string | null;
            transactionHash: string;
            gas: string | null;
        };
        AbiInput: {
            name: string;
            type: string;
            indexed?: boolean;
            components?: components["schemas"]["AbiInput"][];
            internalType?: string;
        };
        AbiOutput: {
            name: string;
            type: string;
            components?: components["schemas"]["AbiOutput"][];
            internalType?: string;
        };
        /**
         * @description The abi to parse the log object of the contract
         * @example {}
         */
        AbiItem: {
            anonymous?: boolean;
            constant?: boolean;
            inputs?: components["schemas"]["AbiInput"][];
            name?: string;
            outputs?: components["schemas"]["AbiOutput"][];
            payable?: boolean;
            stateMutability?: string;
            type: string;
            /** Format: double */
            gas?: number;
        };
        "webhookTypes.IWebhookUnParsed": {
            block: components["schemas"]["Block"];
            chainId: string;
            logs: components["schemas"]["Log"][];
            txs: components["schemas"]["Transaction"][];
            txsInternal: components["schemas"]["InternalTransaction"][];
            abi: components["schemas"]["AbiItem"][];
            /** Format: double */
            retries: number;
            confirmed: boolean;
            tag: string;
            streamId: string;
        };
        AptosBlock: {
            lastVersion: string;
            firstVersion: string;
            hash: string;
            timestamp: string;
            number: string;
        };
        AptosCoin: {
            symbol: string;
            /** Format: double */
            decimals: number;
            name: string;
        };
        AptosCoinDeposit: {
            txHash: string;
            sequenceNumber: string;
            valueWithDecimals: string;
            coin: components["schemas"]["AptosCoin"];
            address: string;
            value: string;
        };
        AptosCoinTransfer: {
            txHash: string;
            transaction: string;
            /** Format: double */
            valueWithDecimals: number;
            from: string;
            value: string;
            to: string;
            coin: components["schemas"]["AptosCoin"];
        };
        AptosCoinWithdrawal: {
            txHash: string;
            sequenceNumber: string;
            valueWithDecimals: string;
            coin: components["schemas"]["AptosCoin"];
            address: string;
            value: string;
        };
        AptosTransaction: {
            gasUnitPrice: string;
            type: string;
            gasUsed: string;
            eventChangeHash: string;
            stateChangeHash: string;
            gasLimit: string;
            sender: string;
            success: boolean;
            hash: string;
        };
        "webhookTypes.AptosWebhook": {
            block: components["schemas"]["AptosBlock"];
            changes: ({
                txHash: string;
            } & {
                [key: string]: unknown;
            })[];
            coinDeposits: components["schemas"]["AptosCoinDeposit"][];
            coinTransfers: components["schemas"]["AptosCoinTransfer"][];
            coinWithdrawals: components["schemas"]["AptosCoinWithdrawal"][];
            events: ({
                txHash: string;
            } & {
                [key: string]: unknown;
            })[];
            /** @enum {string} */
            network: "mainnet" | "testnet";
            payloads: ({
                txHash: string;
            } & {
                [key: string]: unknown;
            })[];
            /** Format: double */
            retries: number;
            streamId: string;
            tag: string;
            transactions: components["schemas"]["AptosTransaction"][];
        };
        "webhookTypes.ITinyPayload": {
            chainId: string;
            confirmed: boolean;
            block: string;
            /** Format: double */
            records: number;
            /** Format: double */
            retries: number;
        };
        HistoryModel: {
            id: components["schemas"]["UUID"];
            /** Format: date-time */
            date: string;
            payload?: Partial<components["schemas"]["webhookTypes.IWebhookUnParsed"]> & Partial<components["schemas"]["webhookTypes.AptosWebhook"]>;
            tinyPayload: components["schemas"]["webhookTypes.ITinyPayload"];
            errorMessage: string;
            webhookUrl: string;
            streamId: string;
            tag: string;
        };
        "historyTypes.HistoryResponse": {
            result: components["schemas"]["HistoryModel"][];
            cursor?: string;
            /** Format: double */
            total: number;
        };
        "historyTypes.HistoryModel": {
            id: components["schemas"]["UUID"];
            /** Format: date-time */
            date: string;
            payload?: Partial<components["schemas"]["webhookTypes.IWebhookUnParsed"]> & Partial<components["schemas"]["webhookTypes.AptosWebhook"]>;
            tinyPayload: components["schemas"]["webhookTypes.ITinyPayload"];
            errorMessage: string;
            webhookUrl: string;
            streamId: string;
            tag: string;
        };
        /**
         * Format: uuid
         * @description Stringified UUIDv4.
         * See [RFC 4112](https://tools.ietf.org/html/rfc4122)
         */
        "streamTypes.UUID": string;
        /**
         * Format: uuid
         * @description Stringified UUIDv4.
         * See [RFC 4112](https://tools.ietf.org/html/rfc4122)
         */
        "historyTypes.UUID": string;
        IWebhookDeliveryLogsModel: {
            id: components["schemas"]["UUID"];
            streamId: string;
            chain: string;
            webhookUrl: string;
            tag: string;
            /** Format: double */
            retries: number;
            /** @enum {string} */
            deliveryStatus: "failed" | "success";
            /** Format: double */
            blockNumber: number;
            errorMessage: string;
            /** @enum {string} */
            type: "evm" | "aptos";
            /** Format: date-time */
            createdAt: string;
        };
        "historyTypes.IWebhookDeliveryLogsResponse": {
            result: components["schemas"]["IWebhookDeliveryLogsModel"][];
            cursor?: string;
            /** Format: double */
            total: number;
        };
        /** @enum {string} */
        SettingsRegion: "us-east-1" | "us-west-2" | "eu-central-1" | "ap-southeast-1";
        "settingsTypes.SettingsModel": {
            /** @description The region from where all the webhooks will be posted for this project */
            region?: components["schemas"]["SettingsRegion"];
        };
        UsageStatsStreams: {
            /**
             * Format: double
             * @description The total amount of webhooks delivered across all streams
             */
            totalWebhooksDelivered: number;
            /**
             * Format: double
             * @description The total amount of failed webhooks across all streams
             */
            totalWebhooksFailed: number;
            /**
             * Format: double
             * @description The total amount of logs processed across all streams, this includes failed webhooks
             */
            totalLogsProcessed: number;
            /**
             * Format: double
             * @description The total amount of txs processed across all streams, this includes failed webhooks
             */
            totalTxsProcessed: number;
            /**
             * Format: double
             * @description The total amount of internal txs processed across all streams, this includes failed webhooks
             */
            totalTxsInternalProcessed: number;
            /** @description The stream id */
            streamId: string;
        };
        "usagestatsTypes.UsageStatsModel": {
            /**
             * Format: double
             * @description The total amount of webhooks delivered across all streams
             */
            totalWebhooksDelivered: number;
            /**
             * Format: double
             * @description The total amount of failed webhooks across all streams
             */
            totalWebhooksFailed: number;
            /**
             * Format: double
             * @description The total amount of logs processed across all streams, this includes failed webhooks
             */
            totalLogsProcessed: number;
            /**
             * Format: double
             * @description The total amount of txs processed across all streams, this includes failed webhooks
             */
            totalTxsProcessed: number;
            /**
             * Format: double
             * @description The total amount of internal txs processed across all streams, this includes failed webhooks
             */
            totalTxsInternalProcessed: number;
            /** @description Array of stream stats */
            streams?: components["schemas"]["UsageStatsStreams"][];
            /**
             * Format: date-time
             * @description The date since this stats are being counted
             */
            createdAt?: string;
            /**
             * Format: date-time
             * @description The date since this stats were last updated
             */
            updatedAt?: string;
        };
        /**
         * Format: uuid
         * @description Stringified UUIDv4.
         * See [RFC 4112](https://tools.ietf.org/html/rfc4122)
         */
        "streamsTypes.UUID": string;
        /**
         * @description The stream status:
         * [active] The Stream is healthy and processing blocks
         * [paused] The Stream is paused and is not processing blocks
         * [error] The Stream has encountered an error and is not processing blocks
         * @enum {string}
         */
        StreamsStatus: "active" | "paused" | "error" | "terminated";
        getNativeBalances: {
            selectors: string[];
            /** @enum {string} */
            type: "tx" | "log" | "erc20transfer" | "erc20approval" | "nfttransfer" | "internalTx";
        };
        /**
         * @description The filter object for the topic0
         * https://docs.moralis.io/docs/filter-streams
         * @example {}
         */
        StreamsFilter: {
            [key: string]: unknown;
        };
        /** @description Advanced Options for each specific topic */
        advancedOptions: {
            topic0: string;
            filter?: components["schemas"]["StreamsFilter"];
            includeNativeTxs?: boolean;
        };
        /** @description Trigger */
        StreamsTrigger: {
            /** @enum {string} */
            type: "tx" | "log" | "erc20transfer" | "erc20approval" | "nfttransfer";
            contractAddress: string;
            inputs?: (Partial<string> & Partial<unknown[]>)[];
            functionAbi: components["schemas"]["AbiItem"];
            topic0?: string;
            callFrom?: string;
        };
        StreamsModel: {
            /** @description Webhook URL where moralis will send the POST request. */
            webhookUrl: string;
            /** @description A description for this stream */
            description: string;
            /** @description A user-provided tag that will be send along the webhook, the user can use this tag to identify the specific stream if multiple streams are present */
            tag: string;
            /** @description An Array of topic0's in string-signature format ex: ['FunctionName(address,uint256)'] */
            topic0?: string[] | null;
            /** @description Include events for all addresses (only applied when abi and topic0 is provided) */
            allAddresses?: boolean;
            /** @description Include or not native transactions defaults to false */
            includeNativeTxs?: boolean;
            /** @description Include or not logs of contract interactions defaults to false */
            includeContractLogs?: boolean;
            /** @description Include or not include internal transactions defaults to false */
            includeInternalTxs?: boolean;
            /** @description Include all logs if atleast one value in tx or log matches stream config */
            includeAllTxLogs?: boolean;
            /** @description Include native balances for each address in the webhook */
            getNativeBalances?: components["schemas"]["getNativeBalances"][];
            abi?: components["schemas"]["AbiItem"][] | null;
            advancedOptions?: components["schemas"]["advancedOptions"][] | null;
            /** @description The ids of the chains for this stream in hex Ex: ["0x1","0x38"] */
            chainIds: string[];
            /** @description Indicator if it is a demo stream */
            demo?: boolean;
            /** @description triggers */
            triggers?: components["schemas"]["StreamsTrigger"][] | null;
            /** @description The unique uuid of the stream */
            id: components["schemas"]["UUID"];
            /** @description The status of the stream. */
            status: components["schemas"]["StreamsStatus"];
            /** @description Description of current status of stream. */
            statusMessage: string;
        };
        "streamsTypes.StreamsResponse": {
            /** @description Array of project Streams */
            result: components["schemas"]["StreamsModel"][];
            /** @description Cursor for fetching next page */
            cursor?: string;
            /**
             * Format: double
             * @description Total count of streams on the project
             */
            total: number;
        };
        "streamsTypes.StreamsModel": {
            /** @description Webhook URL where moralis will send the POST request. */
            webhookUrl: string;
            /** @description A description for this stream */
            description: string;
            /** @description A user-provided tag that will be send along the webhook, the user can use this tag to identify the specific stream if multiple streams are present */
            tag: string;
            /** @description An Array of topic0's in string-signature format ex: ['FunctionName(address,uint256)'] */
            topic0?: string[] | null;
            /** @description Include events for all addresses (only applied when abi and topic0 is provided) */
            allAddresses?: boolean;
            /** @description Include or not native transactions defaults to false */
            includeNativeTxs?: boolean;
            /** @description Include or not logs of contract interactions defaults to false */
            includeContractLogs?: boolean;
            /** @description Include or not include internal transactions defaults to false */
            includeInternalTxs?: boolean;
            /** @description Include all logs if atleast one value in tx or log matches stream config */
            includeAllTxLogs?: boolean;
            /** @description Include native balances for each address in the webhook */
            getNativeBalances?: components["schemas"]["getNativeBalances"][];
            abi?: components["schemas"]["AbiItem"][] | null;
            advancedOptions?: components["schemas"]["advancedOptions"][] | null;
            /** @description The ids of the chains for this stream in hex Ex: ["0x1","0x38"] */
            chainIds: string[];
            /** @description Indicator if it is a demo stream */
            demo?: boolean;
            /** @description triggers */
            triggers?: components["schemas"]["StreamsTrigger"][] | null;
            /** @description The unique uuid of the stream */
            id: components["schemas"]["UUID"];
            /** @description The status of the stream. */
            status: components["schemas"]["StreamsStatus"];
            /** @description Description of current status of stream. */
            statusMessage: string;
        };
        "streamsTypes.StreamsModelCreate": {
            /** @description Webhook URL where moralis will send the POST request. */
            webhookUrl: string;
            /** @description A description for this stream */
            description: string;
            /** @description A user-provided tag that will be send along the webhook, the user can use this tag to identify the specific stream if multiple streams are present */
            tag: string;
            /** @description An Array of topic0's in string-signature format ex: ['FunctionName(address,uint256)'] */
            topic0?: string[] | null;
            /** @description Include events for all addresses (only applied when abi and topic0 is provided) */
            allAddresses?: boolean;
            /** @description Include or not native transactions defaults to false */
            includeNativeTxs?: boolean;
            /** @description Include or not logs of contract interactions defaults to false */
            includeContractLogs?: boolean;
            /** @description Include or not include internal transactions defaults to false */
            includeInternalTxs?: boolean;
            /** @description Include all logs if atleast one value in tx or log matches stream config */
            includeAllTxLogs?: boolean;
            /** @description Include native balances for each address in the webhook */
            getNativeBalances?: components["schemas"]["getNativeBalances"][];
            abi?: components["schemas"]["AbiItem"][] | null;
            advancedOptions?: components["schemas"]["advancedOptions"][] | null;
            /** @description The ids of the chains for this stream in hex Ex: ["0x1","0x38"] */
            chainIds: string[];
            /** @description Indicator if it is a demo stream */
            demo?: boolean;
            /** @description triggers */
            triggers?: components["schemas"]["StreamsTrigger"][] | null;
        };
        /** @description Make all properties in T optional */
        "Partial_streamsTypes.StreamsModelCreate_": {
            /** @description Webhook URL where moralis will send the POST request. */
            webhookUrl?: string;
            /** @description A description for this stream */
            description?: string;
            /** @description A user-provided tag that will be send along the webhook, the user can use this tag to identify the specific stream if multiple streams are present */
            tag?: string;
            /** @description An Array of topic0's in string-signature format ex: ['FunctionName(address,uint256)'] */
            topic0?: string[] | null;
            /** @description Include events for all addresses (only applied when abi and topic0 is provided) */
            allAddresses?: boolean;
            /** @description Include or not native transactions defaults to false */
            includeNativeTxs?: boolean;
            /** @description Include or not logs of contract interactions defaults to false */
            includeContractLogs?: boolean;
            /** @description Include or not include internal transactions defaults to false */
            includeInternalTxs?: boolean;
            /** @description Include all logs if atleast one value in tx or log matches stream config */
            includeAllTxLogs?: boolean;
            /** @description Include native balances for each address in the webhook */
            getNativeBalances?: components["schemas"]["getNativeBalances"][];
            abi?: components["schemas"]["AbiItem"][] | null;
            advancedOptions?: components["schemas"]["advancedOptions"][] | null;
            /** @description The ids of the chains for this stream in hex Ex: ["0x1","0x38"] */
            chainIds?: string[];
            /** @description Indicator if it is a demo stream */
            demo?: boolean;
            /** @description triggers */
            triggers?: components["schemas"]["StreamsTrigger"][] | null;
        };
        "streamsTypes.StreamsStatusUpdate": {
            /** @description The status of the stream. */
            status: components["schemas"]["StreamsStatus"];
        };
        Addresses: {
            /** @description Address */
            address: string;
        };
        "addressesTypes.AddressesResponse": {
            /** @description Array of project Streams */
            result: components["schemas"]["Addresses"][];
            /** @description Cursor for fetching next page */
            cursor?: string;
            /**
             * Format: double
             * @description Total count of streams on the project
             */
            total: number;
        };
        /**
         * Format: uuid
         * @description Stringified UUIDv4.
         * See [RFC 4112](https://tools.ietf.org/html/rfc4122)
         */
        "addressesTypes.UUID": string;
        "addressesTypes.AddressResponse": {
            /** @description The streamId */
            streamId: string;
            /** @description Address */
            address: Partial<string> & Partial<string[]>;
        };
        "addressesTypes.AddressesAdd": {
            /** @description The address or a list of addresses to be added to the Stream. */
            address: Partial<string> & Partial<string[]>;
        };
        "addressesTypes.AddressesRemove": {
            /** @description The address or a list of addresses to be removed from the Stream. */
            address: Partial<string> & Partial<string[]>;
        };
        AptosNetwork: ("mainnet" | "testnet")[];
        AptosStreamType: {
            id: string;
            allAddresses: boolean;
            demo: boolean;
            description: string;
            includeChanges: boolean;
            includeEvents: boolean;
            includePayload: boolean;
            /** Format: date-time */
            isErrorSince: string | null;
            network: components["schemas"]["AptosNetwork"];
            status: components["schemas"]["StreamsStatus"];
            statusMessage: string;
            events: string[];
            functions: string[];
            tag: string;
            webhookUrl: string;
            /** Format: double */
            amountOfAddresses: number;
        };
        AptosCreateStreamType: {
            /** @description Webhook URL where moralis will send the POST request. */
            webhookUrl: string;
            /** @description A user-provided tag that will be send along the webhook, the user can use this tag to identify the specific stream if multiple streams are present */
            tag: string;
            /** @description An Array of events in string-signature format ex: ['0x1::aptos_account::transfer'] */
            functions?: string[];
            /** @description An Array of events in string-signature format ex: ['0x1::coin::WithdrawEvent'] */
            events?: string[];
            /** @description The network to listen to */
            network: components["schemas"]["AptosNetwork"];
            /** @description Include or not payload for every transaction in webhook defaults to false */
            includePayload?: boolean;
            /** @description Include or not events in webhook defaults to false */
            includeEvents?: boolean;
            /** @description Include or not raw changes for every transaction in webhook defaults to false */
            includeChanges?: boolean;
            /** @description A description for this stream */
            description: string;
            /** @description Indicator if it is a demo stream */
            demo?: boolean;
            /** @description Include events for all addresses (only applied when at least one event or function is provided) */
            allAddresses?: boolean;
        };
        /** @description Make all properties in T optional */
        Partial_AptosCreateStreamType_: {
            /** @description Include events for all addresses (only applied when at least one event or function is provided) */
            allAddresses?: boolean;
            /** @description Indicator if it is a demo stream */
            demo?: boolean;
            /** @description A description for this stream */
            description?: string;
            /** @description Include or not raw changes for every transaction in webhook defaults to false */
            includeChanges?: boolean;
            /** @description Include or not events in webhook defaults to false */
            includeEvents?: boolean;
            /** @description Include or not payload for every transaction in webhook defaults to false */
            includePayload?: boolean;
            /** @description The network to listen to */
            network?: components["schemas"]["AptosNetwork"];
            /** @description An Array of events in string-signature format ex: ['0x1::coin::WithdrawEvent'] */
            events?: string[];
            /** @description An Array of events in string-signature format ex: ['0x1::aptos_account::transfer'] */
            functions?: string[];
            /** @description A user-provided tag that will be send along the webhook, the user can use this tag to identify the specific stream if multiple streams are present */
            tag?: string;
            /** @description Webhook URL where moralis will send the POST request. */
            webhookUrl?: string;
        };
        /** @description From T, pick a set of properties whose keys are in the union K */
        "Pick_AptosStreamType.status-or-statusMessage_": {
            status: components["schemas"]["StreamsStatus"];
            statusMessage: string;
        };
    };
    responses: {};
    parameters: {};
    requestBodies: {};
    headers: {};
}
interface operations {
    /** Get all history */
    GetHistory: {
        parameters: {
            query: {
                limit: number;
                cursor?: string;
                excludePayload?: boolean;
            };
        };
        responses: {
            /** Ok */
            200: {
                content: {
                    "application/json": components["schemas"]["historyTypes.HistoryResponse"];
                };
            };
        };
    };
    /** Replay a specific history. */
    ReplayHistory: {
        parameters: {
            path: {
                /** The id of the stream the history will be replayed */
                streamId: components["schemas"]["streamTypes.UUID"];
                /** The id of the history to replay */
                id: components["schemas"]["historyTypes.UUID"];
            };
        };
        responses: {
            /** Ok */
            200: {
                content: {
                    "application/json": components["schemas"]["historyTypes.HistoryModel"];
                };
            };
        };
    };
    /** get all failed logs */
    GetLogs: {
        parameters: {
            query: {
                limit: number;
                cursor?: string;
            };
        };
        responses: {
            /** Ok */
            200: {
                content: {
                    "application/json": components["schemas"]["historyTypes.IWebhookDeliveryLogsResponse"];
                };
            };
        };
    };
    /** Get the settings for the current project based on the project api-key. */
    GetSettings: {
        parameters: {};
        responses: {
            /** Ok */
            200: {
                content: {
                    "application/json": components["schemas"]["settingsTypes.SettingsModel"];
                };
            };
        };
    };
    /** Set the settings for the current project based on the project api-key. */
    SetSettings: {
        parameters: {};
        responses: {
            /** Ok */
            200: {
                content: {
                    "application/json": components["schemas"]["settingsTypes.SettingsModel"];
                };
            };
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["settingsTypes.SettingsModel"];
            };
        };
    };
    /** Get the global stats for the account. */
    GetStats: {
        parameters: {};
        responses: {
            /** Ok */
            200: {
                content: {
                    "application/json": components["schemas"]["usagestatsTypes.UsageStatsModel"];
                };
            };
        };
    };
    /** Get the stats for the streamId specified */
    GetStatsByStreamId: {
        parameters: {
            path: {
                /** The id of the stream to get the stats */
                streamId: components["schemas"]["streamsTypes.UUID"];
            };
        };
        responses: {
            /** Ok */
            200: {
                content: {
                    "application/json": components["schemas"]["usagestatsTypes.UsageStatsModel"];
                };
            };
        };
    };
    /** Get all the evm streams for the current project based on the project api-key. */
    GetStreams: {
        parameters: {
            query: {
                /** Limit response results max value 100 */
                limit: number;
                /** Cursor for fetching next page */
                cursor?: string;
            };
        };
        responses: {
            /** Ok */
            200: {
                content: {
                    "application/json": components["schemas"]["streamsTypes.StreamsResponse"];
                };
            };
        };
    };
    /** Creates a new evm stream. */
    CreateStream: {
        parameters: {};
        responses: {
            /** Ok */
            200: {
                content: {
                    "application/json": components["schemas"]["streamsTypes.StreamsModel"];
                };
            };
        };
        /** Provide a Stream Model */
        requestBody: {
            content: {
                "application/json": components["schemas"]["streamsTypes.StreamsModelCreate"];
            };
        };
    };
    /** Get a specific evm stream. */
    GetStream: {
        parameters: {
            path: {
                /** The id of the stream to get */
                id: components["schemas"]["streamsTypes.UUID"];
            };
        };
        responses: {
            /** Ok */
            200: {
                content: {
                    "application/json": components["schemas"]["streamsTypes.StreamsModel"];
                };
            };
        };
    };
    /** Updates a specific evm stream. */
    UpdateStream: {
        parameters: {
            path: {
                /** The id of the stream to update */
                id: components["schemas"]["streamsTypes.UUID"];
            };
        };
        responses: {
            /** Ok */
            200: {
                content: {
                    "application/json": components["schemas"]["streamsTypes.StreamsModel"];
                };
            };
        };
        /** Provide a Stream Model */
        requestBody: {
            content: {
                "application/json": components["schemas"]["Partial_streamsTypes.StreamsModelCreate_"];
            };
        };
    };
    /** Delete a specific evm stream. */
    DeleteStream: {
        parameters: {
            path: {
                /** The id of the stream to delete */
                id: components["schemas"]["streamsTypes.UUID"];
            };
        };
        responses: {
            /** Ok */
            200: {
                content: {
                    "application/json": components["schemas"]["streamsTypes.StreamsModel"];
                };
            };
        };
    };
    /** Updates the status of specific evm stream. */
    UpdateStreamStatus: {
        parameters: {
            path: {
                /** The id of the stream to update */
                id: components["schemas"]["streamsTypes.UUID"];
            };
        };
        responses: {
            /** Ok */
            200: {
                content: {
                    "application/json": components["schemas"]["streamsTypes.StreamsModel"];
                };
            };
        };
        /** Provide a Stream Model */
        requestBody: {
            content: {
                "application/json": components["schemas"]["streamsTypes.StreamsStatusUpdate"];
            };
        };
    };
    /** Get all addresses associated with a specific stream. */
    GetAddresses: {
        parameters: {
            path: {
                /** the id of the stream to get the addresses from */
                id: components["schemas"]["addressesTypes.UUID"];
            };
            query: {
                /** Limit response results max value 100 */
                limit: number;
                /** Cursor for fetching next page */
                cursor?: string;
            };
        };
        responses: {
            /** Ok */
            200: {
                content: {
                    "application/json": components["schemas"]["addressesTypes.AddressesResponse"];
                };
            };
        };
    };
    /** Adds an address to a Stream. */
    AddAddressToStream: {
        parameters: {
            path: {
                /** The id of the stream to add the address to */
                id: components["schemas"]["streamsTypes.UUID"];
            };
        };
        responses: {
            /** Ok */
            200: {
                content: {
                    "application/json": components["schemas"]["addressesTypes.AddressResponse"];
                };
            };
        };
        /** Provide a Address Model */
        requestBody: {
            content: {
                "application/json": components["schemas"]["addressesTypes.AddressesAdd"];
            };
        };
    };
    /** Deletes an address from a Stream. */
    DeleteAddressFromStream: {
        parameters: {
            path: {
                /** The id of the stream to delete the address from */
                id: components["schemas"]["streamsTypes.UUID"];
            };
        };
        responses: {
            /** Ok */
            200: {
                content: {
                    "application/json": components["schemas"]["addressesTypes.AddressResponse"];
                };
            };
        };
        /** Provide a Address Model */
        requestBody: {
            content: {
                "application/json": components["schemas"]["addressesTypes.AddressesRemove"];
            };
        };
    };
    /** Get all aptos streams. */
    aptosStreamsGetAll: {
        parameters: {
            query: {
                /** Limit response results max value 100 */
                limit: number;
                /** Cursor for fetching next page */
                cursor?: string;
            };
        };
        responses: {
            /** Ok */
            200: {
                content: {
                    "application/json": {
                        /** Format: double */
                        total: number;
                        result: components["schemas"]["AptosStreamType"][];
                    };
                };
            };
        };
    };
    /** Creates a new aptos stream. */
    aptosStreamsCreate: {
        parameters: {};
        responses: {
            /** Ok */
            200: {
                content: {
                    "application/json": components["schemas"]["AptosStreamType"];
                };
            };
        };
        /** Provide a valid Aptos Stream Model */
        requestBody: {
            content: {
                "application/json": components["schemas"]["AptosCreateStreamType"];
            };
        };
    };
    /** Get a specific aptos stream. */
    aptosStreamsGet: {
        parameters: {
            path: {
                /** The id of the stream to get */
                id: components["schemas"]["streamsTypes.UUID"];
            };
        };
        responses: {
            /** Ok */
            200: {
                content: {
                    "application/json": components["schemas"]["AptosStreamType"];
                };
            };
        };
    };
    /** Updates a new aptos stream. */
    aptosStreamsUpdate: {
        parameters: {
            path: {
                id: string;
            };
        };
        responses: {
            /** Ok */
            200: {
                content: {
                    "application/json": components["schemas"]["AptosStreamType"];
                };
            };
        };
        /** Provide valid values of a Aptos Stream Model */
        requestBody: {
            content: {
                "application/json": components["schemas"]["Partial_AptosCreateStreamType_"];
            };
        };
    };
    /** Deletes a aptos stream. */
    aptosStreamsDelete: {
        parameters: {
            path: {
                /** the id of the aptos stream to delete */
                id: string;
            };
        };
        responses: {
            /** Ok */
            200: {
                content: {
                    "application/json": boolean;
                };
            };
        };
    };
    /** Get all addresses associated with a specific aptos stream. */
    aptosStreamsGetAddresses: {
        parameters: {
            path: {
                /** the id of the aptos stream to get the addresses from */
                id: components["schemas"]["streamsTypes.UUID"];
            };
            query: {
                /** Limit response results max value 100 */
                limit: number;
                /** Cursor for fetching next page */
                cursor?: string;
            };
        };
        responses: {
            /** Ok */
            200: {
                content: {
                    "application/json": {
                        cursor?: string;
                        /** Format: double */
                        total: number;
                        result: {
                            address: Partial<string> & Partial<string[]>;
                        }[];
                    };
                };
            };
        };
    };
    /** Adds addresses to an existing aptos stream */
    aptosStreamsAddAddresses: {
        parameters: {
            path: {
                /** the id of the aptos stream to get the addresses from */
                id: components["schemas"]["streamsTypes.UUID"];
            };
        };
        responses: {
            /** Ok */
            200: {
                content: {
                    "application/json": {
                        address: Partial<string> & Partial<string[]>;
                        streamId: string;
                    };
                };
            };
        };
        requestBody: {
            content: {
                "application/json": {
                    address: Partial<string> & Partial<string[]>;
                };
            };
        };
    };
    /** Deletes addresses of an existing aptos stream */
    aptosStreamsDeleteAddresses: {
        parameters: {
            path: {
                /** the id of the aptos stream to get the addresses from */
                id: components["schemas"]["streamsTypes.UUID"];
            };
        };
        responses: {
            /** Ok */
            200: {
                content: {
                    "application/json": {
                        address: Partial<string> & Partial<string[]>;
                        streamId: string;
                    };
                };
            };
        };
        /** Provide a list of valid Aptos addresses, or a single address */
        requestBody: {
            content: {
                "application/json": {
                    address: Partial<string> & Partial<string[]>;
                };
            };
        };
    };
    /** Update a Stream Status */
    aptosStreamsUpdateStatus: {
        parameters: {
            path: {
                /** the id of the aptos stream to update the status */
                id: components["schemas"]["streamsTypes.UUID"];
            };
        };
        responses: {
            /** Ok */
            200: {
                content: {
                    "application/json": components["schemas"]["Pick_AptosStreamType.status-or-statusMessage_"];
                };
            };
        };
        /** Provide an object with the status to update can be 'active' or 'paused' */
        requestBody: {
            content: {
                "application/json": components["schemas"]["streamsTypes.StreamsStatusUpdate"];
            };
        };
    };
}

type OperationId$o = 'aptosStreamsAddAddresses';
type PathParams$f = operations[OperationId$o]['parameters']['path'];
type BodyParams$a = operations[OperationId$o]['requestBody']['content']['application/json'];
type RequestParams$m = PathParams$f & BodyParams$a;
type SuccessResponse$o = operations[OperationId$o]['responses']['200']['content']['application/json'];
interface AddAddressAptosRequest extends Camelize<Omit<RequestParams$m, 'address'>> {
    address: AptosAddressInput | AptosAddressInput[];
}
type AddAddressAptosJSONRequest = ReturnType<typeof serializeRequest$m>;
type AddAddressAptosJSONResponse = SuccessResponse$o;
type AddAddressAptosResponse = ReturnType<typeof deserializeResponse$o>;
interface AddAddressAptosResponseAdapter extends ResponseAdapter<AddAddressAptosResponse, AddAddressAptosJSONResponse> {
}
declare const addAddressAptosOperation: Operation<AddAddressAptosRequest, AddAddressAptosJSONRequest, AddAddressAptosResponse, AddAddressAptosJSONResponse>;
declare function deserializeResponse$o(jsonResponse: AddAddressAptosJSONResponse): {
    address: AptosAddress | AptosAddress[] | undefined;
    streamId: string;
};
declare function serializeRequest$m(request: AddAddressAptosRequest): {
    id: string;
    address: string | string[];
};

type OperationId$n = 'aptosStreamsGetAll';
type QueryParams$5 = operations[OperationId$n]['parameters']['query'];
type RequestParams$l = QueryParams$5;
type SuccessResponse$n = operations[OperationId$n]['responses']['200']['content']['application/json'];
interface GetStreamsAptosRequest extends Camelize<RequestParams$l> {
}
type GetStreamsAptosJSONRequest = ReturnType<typeof serializeRequest$l>;
type GetStreamsAptosJSONResponse = SuccessResponse$n;
type GetStreamsAptosResponse = ReturnType<typeof deserializeResponse$n>;
interface GetStreamsAptosResponseAdapter extends PaginatedResponseAdapter<GetStreamsAptosResponse, GetStreamsAptosJSONResponse['result']> {
}
declare const getStreamsAptosOperation: PaginatedOperation<GetStreamsAptosRequest, GetStreamsAptosJSONRequest, GetStreamsAptosResponse, GetStreamsAptosJSONResponse['result']>;
declare function deserializeResponse$n(jsonResponse: GetStreamsAptosJSONResponse): AptosStream[];
declare function serializeRequest$l(request: GetStreamsAptosRequest): {
    cursor: string | undefined;
    limit: number;
};

type OperationId$m = 'aptosStreamsGet';
type PathParams$e = operations[OperationId$m]['parameters']['path'];
type RequestParams$k = PathParams$e;
type SuccessResponse$m = operations[OperationId$m]['responses']['200']['content']['application/json'];
interface GetStreamAptosRequest extends Camelize<RequestParams$k> {
}
type GetStreamAptosJSONRequest = ReturnType<typeof serializeRequest$k>;
type GetStreamAptosJSONResponse = SuccessResponse$m;
type GetStreamAptosResponse = ReturnType<typeof deserializeResponse$m>;
interface GetStreamAptosResponseAdapter extends ResponseAdapter<GetStreamAptosResponse, GetStreamAptosJSONResponse> {
}
declare const getStreamAptosOperation: Operation<GetStreamAptosRequest, GetStreamAptosJSONRequest, GetStreamAptosResponse, GetStreamAptosJSONResponse>;
declare function deserializeResponse$m(jsonResponse: GetStreamAptosJSONResponse): AptosStream;
declare function serializeRequest$k(request: GetStreamAptosRequest): {
    id: string;
};

type OperationId$l = 'aptosStreamsCreate';
type BodyParams$9 = operations[OperationId$l]['requestBody']['content']['application/json'];
type RequestParams$j = BodyParams$9;
type SuccessResponse$l = operations[OperationId$l]['responses']['200']['content']['application/json'];
interface CreateStreamAptosRequest extends Camelize<Omit<RequestParams$j, 'network'>> {
    network: AptosNetworkInput[];
}
type CreateStreamAptosJSONRequest = ReturnType<typeof serializeRequest$j>;
type CreateStreamAptosJSONResponse = SuccessResponse$l;
type CreateStreamAptosResponse = ReturnType<typeof deserializeResponse$l>;
interface CreateStreamAptosResponseAdapter extends ResponseAdapter<CreateStreamAptosResponse, CreateStreamAptosJSONResponse> {
}
declare const createStreamAptosOperation: Operation<CreateStreamAptosRequest, CreateStreamAptosJSONRequest, CreateStreamAptosResponse, CreateStreamAptosJSONResponse>;
declare function deserializeResponse$l(jsonResponse: CreateStreamAptosJSONResponse): AptosStream;
declare function serializeRequest$j(request: CreateStreamAptosRequest): {
    allAddresses: boolean | undefined;
    demo: boolean | undefined;
    description: string;
    includeChanges: boolean | undefined;
    includeEvents: boolean | undefined;
    includePayload: boolean | undefined;
    network: ("mainnet" | "testnet" | "devnet")[];
    events: string[] | undefined;
    functions: string[] | undefined;
    tag: string;
    webhookUrl: string;
};

type OperationId$k = 'aptosStreamsDeleteAddresses';
type PathParams$d = operations[OperationId$k]['parameters']['path'];
type BodyParams$8 = operations[OperationId$k]['requestBody']['content']['application/json'];
type RequestParams$i = PathParams$d & BodyParams$8;
type SuccessResponse$k = operations[OperationId$k]['responses']['200']['content']['application/json'];
interface DeleteAddressAptosRequest extends Camelize<Omit<RequestParams$i, 'address'>> {
    address: AptosAddressInput | AptosAddressInput[];
}
type DeleteAddressAptosJSONRequest = ReturnType<typeof serializeRequest$i>;
type DeleteAddressAptosJSONResponse = SuccessResponse$k;
type DeleteAddressAptosResponse = ReturnType<typeof deserializeResponse$k>;
interface DeleteAddressAptosResponseAdapter extends ResponseAdapter<DeleteAddressAptosResponse, DeleteAddressAptosJSONResponse> {
}
declare const deleteAddressAptosOperation: Operation<DeleteAddressAptosRequest, DeleteAddressAptosJSONRequest, DeleteAddressAptosResponse, DeleteAddressAptosJSONResponse>;
declare function deserializeResponse$k(jsonResponse: DeleteAddressAptosJSONResponse): {
    address: string & (string | undefined)[];
    streamId: string;
};
declare function serializeRequest$i(request: DeleteAddressAptosRequest): {
    id: string;
    address: string | string[];
};

type OperationId$j = 'aptosStreamsDelete';
type PathParams$c = operations[OperationId$j]['parameters']['path'];
type RequestParams$h = PathParams$c;
type SuccessResponse$j = operations[OperationId$j]['responses']['200']['content']['application/json'];
interface DeleteStreamAptosRequest extends Camelize<RequestParams$h> {
}
type DeleteStreamAptosJSONRequest = ReturnType<typeof serializeRequest$h>;
type DeleteStreamAptosJSONResponse = SuccessResponse$j;
type DeleteStreamAptosResponse = ReturnType<typeof deserializeResponse$j>;
interface DeleteStreamAptosResponseAdapter extends ResponseAdapter<DeleteStreamAptosResponse, DeleteStreamAptosJSONResponse> {
}
declare const deleteStreamAptosOperation: Operation<DeleteStreamAptosRequest, DeleteStreamAptosJSONRequest, DeleteStreamAptosResponse, DeleteStreamAptosJSONResponse>;
declare function deserializeResponse$j(jsonResponse: DeleteStreamAptosJSONResponse): boolean;
declare function serializeRequest$h(request: DeleteStreamAptosRequest): {
    id: string;
};

type OperationId$i = 'aptosStreamsGetAddresses';
type PathParams$b = operations[OperationId$i]['parameters']['path'];
type QueryParams$4 = operations[OperationId$i]['parameters']['query'];
type RequestParams$g = PathParams$b & QueryParams$4;
type SuccessResponse$i = operations[OperationId$i]['responses']['200']['content']['application/json'];
interface GetAddressesAptosRequest extends Camelize<Omit<RequestParams$g, 'limit'>> {
    limit?: number;
}
type GetAddressesAptosJSONRequest = ReturnType<typeof serializeRequest$g>;
type GetAddressesAptosJSONResponse = SuccessResponse$i;
type GetAddressesAptosResponse = ReturnType<typeof deserializeResponse$i>;
interface GetAddressesAptosResponseAdapter extends PaginatedResponseAdapter<GetAddressesAptosResponse, GetAddressesAptosJSONResponse> {
}
declare const getAddressesAptosOperation: PaginatedOperation<GetAddressesAptosRequest, GetAddressesAptosJSONRequest, GetAddressesAptosResponse, GetAddressesAptosJSONResponse['result']>;
declare function deserializeResponse$i(jsonResponse: GetAddressesAptosJSONResponse): {
    result: AptosAddress[];
    total: number;
};
declare function serializeRequest$g(request: GetAddressesAptosRequest): {
    id: string;
    limit: number | undefined;
    cursor: string | undefined;
};

type OperationId$h = 'aptosStreamsUpdate';
type PathParams$a = operations[OperationId$h]['parameters']['path'];
type BodyParams$7 = operations[OperationId$h]['requestBody']['content']['application/json'];
type RequestParams$f = PathParams$a & BodyParams$7;
type SuccessResponse$h = operations[OperationId$h]['responses']['200']['content']['application/json'];
interface UpdateStreamAptosRequest extends Camelize<Omit<RequestParams$f, 'network'>> {
    network: AptosNetworkInput[];
}
type UpdateStreamAptosJSONRequest = ReturnType<typeof serializeRequest$f>;
type UpdateStreamAptosJSONResponse = SuccessResponse$h;
type UpdateStreamAptosResponse = ReturnType<typeof deserializeResponse$h>;
interface UpdateStreamAptosResponseAdapter extends ResponseAdapter<UpdateStreamAptosResponse, UpdateStreamAptosJSONResponse> {
}
declare const updateStreamAptosOperation: Operation<UpdateStreamAptosRequest, UpdateStreamAptosJSONRequest, UpdateStreamAptosResponse, UpdateStreamAptosJSONResponse>;
declare function deserializeResponse$h(jsonResponse: UpdateStreamAptosJSONResponse): AptosStream;
declare function serializeRequest$f(request: UpdateStreamAptosRequest): {
    id: string;
    allAddresses: boolean | undefined;
    demo: boolean | undefined;
    description: string | undefined;
    includeChanges: boolean | undefined;
    includeEvents: boolean | undefined;
    includePayload: boolean | undefined;
    network: ("mainnet" | "testnet" | "devnet")[];
    events: string[] | undefined;
    functions: string[] | undefined;
    tag: string | undefined;
    webhookUrl: string | undefined;
};

type OperationId$g = 'aptosStreamsUpdateStatus';
type PathParams$9 = operations[OperationId$g]['parameters']['path'];
type BodyParams$6 = operations[OperationId$g]['requestBody']['content']['application/json'];
type RequestParams$e = PathParams$9 & BodyParams$6;
type SuccessResponse$g = operations[OperationId$g]['responses']['200']['content']['application/json'];
interface UpdateStreamStatusAptosRequest extends Camelize<RequestParams$e> {
}
type UpdateStreamStatusAptosJSONRequest = ReturnType<typeof serializeRequest$e>;
type UpdateStreamStatusAptosJSONResponse = SuccessResponse$g;
type UpdateStreamStatusAptosResponse = ReturnType<typeof deserializeResponse$g>;
interface UpdateStreamStatusAptosResponseAdapter extends ResponseAdapter<UpdateStreamStatusAptosResponse, UpdateStreamStatusAptosJSONResponse> {
}
declare const updateStreamStatusAptosOperation: Operation<UpdateStreamStatusAptosRequest, UpdateStreamStatusAptosJSONRequest, UpdateStreamStatusAptosResponse, UpdateStreamStatusAptosJSONResponse>;
declare function deserializeResponse$g(jsonResponse: UpdateStreamStatusAptosJSONResponse): {
    status: "active" | "paused" | "error" | "terminated";
    statusMessage: string;
};
declare function serializeRequest$e(request: UpdateStreamStatusAptosRequest): {
    id: string;
    status: Camelize<"active" | "paused" | "error" | "terminated">;
};

type OperationId$f = 'AddAddressToStream';
type PathParams$8 = operations[OperationId$f]['parameters']['path'];
type BodyParams$5 = operations[OperationId$f]['requestBody']['content']['application/json'];
type RequestParams$d = PathParams$8 & BodyParams$5;
type SuccessResponse$f = operations[OperationId$f]['responses']['200']['content']['application/json'];
interface AddAddressEvmRequest extends Camelize<Omit<RequestParams$d, 'address'>> {
    address: EvmAddressish | EvmAddressish[];
}
type AddAddressEvmJSONRequest = ReturnType<typeof serializeRequest$d>;
type AddAddressEvmJSONResponse = SuccessResponse$f;
type AddAddressEvmResponse = ReturnType<typeof deserializeResponse$f>;
interface AddAddressEvmResponseAdapter extends ResponseAdapter<AddAddressEvmResponse, AddAddressEvmJSONResponse> {
}
declare const addAddressEvmOperation: Operation<AddAddressEvmRequest, AddAddressEvmJSONRequest, AddAddressEvmResponse, AddAddressEvmJSONResponse>;
declare function deserializeResponse$f(jsonResponse: AddAddressEvmJSONResponse): {
    address: EvmAddress | EvmAddress[] | undefined;
    streamId: string;
};
declare function serializeRequest$d(request: AddAddressEvmRequest): {
    id: string;
    address: string | string[];
};

type OperationId$e = 'GetStreams';
type QueryParams$3 = operations[OperationId$e]['parameters']['query'];
type RequestParams$c = QueryParams$3;
type SuccessResponse$e = operations[OperationId$e]['responses']['200']['content']['application/json'];
interface GetStreamsEvmRequest extends Camelize<RequestParams$c> {
}
type GetStreamsEvmJSONRequest = ReturnType<typeof serializeRequest$c>;
type GetStreamsEvmJSONResponse = SuccessResponse$e;
type GetStreamsEvmResponse = ReturnType<typeof deserializeResponse$e>;
interface GetStreamsEvmResponseAdapter extends PaginatedResponseAdapter<GetStreamsEvmResponse, GetStreamsEvmJSONResponse['result']> {
}
declare const getStreamsEvmOperation: PaginatedOperation<GetStreamsEvmRequest, GetStreamsEvmJSONRequest, GetStreamsEvmResponse, GetStreamsEvmJSONResponse['result']>;
declare function deserializeResponse$e(jsonResponse: GetStreamsEvmJSONResponse): EvmStream[];
declare function serializeRequest$c(request: GetStreamsEvmRequest): {
    cursor: string | undefined;
    limit: number;
};

type OperationId$d = 'GetStream';
type PathParams$7 = operations[OperationId$d]['parameters']['path'];
type RequestParams$b = PathParams$7;
type SuccessResponse$d = operations[OperationId$d]['responses']['200']['content']['application/json'];
interface GetStreamEvmRequest extends Camelize<RequestParams$b> {
}
type GetStreamEvmJSONRequest = ReturnType<typeof serializeRequest$b>;
type GetStreamEvmJSONResponse = SuccessResponse$d;
type GetStreamEvmResponse = ReturnType<typeof deserializeResponse$d>;
interface GetStreamEvmResponseAdapter extends ResponseAdapter<GetStreamEvmResponse, GetStreamEvmJSONResponse> {
}
declare const getStreamEvmOperation: Operation<GetStreamEvmRequest, GetStreamEvmJSONRequest, GetStreamEvmResponse, GetStreamEvmJSONResponse>;
declare function deserializeResponse$d(jsonResponse: GetStreamEvmJSONResponse): EvmStream;
declare function serializeRequest$b(request: GetStreamEvmRequest): {
    id: string;
};

type OperationId$c = 'CreateStream';
type BodyParams$4 = operations[OperationId$c]['requestBody']['content']['application/json'];
type RequestParams$a = BodyParams$4;
type SuccessResponse$c = operations[OperationId$c]['responses']['200']['content']['application/json'];
interface CreateStreamEvmRequest extends Camelize<Omit<RequestParams$a, 'chainIds' | 'triggers'>> {
    chains: EvmChainish[];
    triggers?: StreamTriggerish[];
}
type CreateStreamEvmJSONRequest = ReturnType<typeof serializeRequest$a>;
type CreateStreamEvmJSONResponse = SuccessResponse$c;
type CreateStreamEvmResponse = ReturnType<typeof deserializeResponse$c>;
interface CreateStreamEvmResponseAdapter extends ResponseAdapter<CreateStreamEvmResponse, CreateStreamEvmJSONResponse> {
}
declare const createStreamEvmOperation: Operation<CreateStreamEvmRequest, CreateStreamEvmJSONRequest, CreateStreamEvmResponse, CreateStreamEvmJSONResponse>;
declare function deserializeResponse$c(jsonResponse: CreateStreamEvmJSONResponse): EvmStream;
declare function serializeRequest$a(request: CreateStreamEvmRequest): {
    webhookUrl: string;
    description: string;
    tag: string;
    topic0: string[] | null | undefined;
    allAddresses: boolean | undefined;
    includeNativeTxs: boolean | undefined;
    includeContractLogs: boolean | undefined;
    includeInternalTxs: boolean | undefined;
    includeAllTxLogs: boolean | undefined;
    chainIds: ("0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa")[];
    abi: {
        anonymous?: boolean | undefined;
        constant?: boolean | undefined;
        inputs?: {
            name: string;
            type: string;
            indexed?: boolean | undefined;
            components?: any[] | undefined;
            internalType?: string | undefined;
        }[] | undefined;
        name?: string | undefined;
        outputs?: {
            name: string;
            type: string;
            components?: any[] | undefined;
            internalType?: string | undefined;
        }[] | undefined;
        payable?: boolean | undefined;
        stateMutability?: string | undefined;
        type: string;
        gas?: number | undefined;
    }[] | null | undefined;
    advancedOptions: {
        topic0: string;
        filter?: {
            [key: string]: unknown;
        } | undefined;
        includeNativeTxs?: boolean | undefined;
    }[] | null | undefined;
    demo: boolean | undefined;
    triggers: StreamTriggerJSON[] | undefined;
};

type OperationId$b = 'DeleteAddressFromStream';
type PathParams$6 = operations[OperationId$b]['parameters']['path'];
type BodyParams$3 = operations[OperationId$b]['requestBody']['content']['application/json'];
type RequestParams$9 = PathParams$6 & BodyParams$3;
type SuccessResponse$b = operations[OperationId$b]['responses']['200']['content']['application/json'];
interface DeleteAddressEvmRequest extends Camelize<Omit<RequestParams$9, 'address'>> {
    address: EvmAddressish | EvmAddressish[];
}
type DeleteAddressEvmJSONRequest = ReturnType<typeof serializeRequest$9>;
type DeleteAddressEvmJSONResponse = SuccessResponse$b;
type DeleteAddressEvmResponse = ReturnType<typeof deserializeResponse$b>;
interface DeleteAddressEvmResponseAdapter extends ResponseAdapter<DeleteAddressEvmResponse, DeleteAddressEvmJSONResponse> {
}
declare const deleteAddressEvmOperation: Operation<DeleteAddressEvmRequest, DeleteAddressEvmJSONRequest, DeleteAddressEvmResponse, DeleteAddressEvmJSONResponse>;
declare function deserializeResponse$b(jsonResponse: DeleteAddressEvmJSONResponse): {
    streamId: string;
    address: EvmAddress | EvmAddress[] | undefined;
};
declare function serializeRequest$9(request: DeleteAddressEvmRequest): {
    id: string;
    address: string | string[];
};

type OperationId$a = 'DeleteStream';
type PathParams$5 = operations[OperationId$a]['parameters']['path'];
type RequestParams$8 = PathParams$5;
type SuccessResponse$a = operations[OperationId$a]['responses']['200']['content']['application/json'];
interface DeleteStreamEvmRequest extends Camelize<RequestParams$8> {
}
type DeleteStreamEvmJSONRequest = ReturnType<typeof serializeRequest$8>;
type DeleteStreamEvmJSONResponse = SuccessResponse$a;
type DeleteStreamEvmResponse = ReturnType<typeof deserializeResponse$a>;
interface DeleteStreamEvmResponseAdapter extends ResponseAdapter<DeleteStreamEvmResponse, DeleteStreamEvmJSONResponse> {
}
declare const deleteStreamEvmOperation: Operation<DeleteStreamEvmRequest, DeleteStreamEvmJSONRequest, DeleteStreamEvmResponse, DeleteStreamEvmJSONResponse>;
declare function deserializeResponse$a(jsonResponse: DeleteStreamEvmJSONResponse): EvmStream;
declare function serializeRequest$8(request: DeleteStreamEvmRequest): {
    id: string;
};

type OperationId$9 = 'GetAddresses';
type PathParams$4 = operations[OperationId$9]['parameters']['path'];
type QueryParams$2 = operations[OperationId$9]['parameters']['query'];
type RequestParams$7 = PathParams$4 & QueryParams$2;
type SuccessResponse$9 = operations[OperationId$9]['responses']['200']['content']['application/json'];
interface GetAddressesEvmRequest extends Camelize<Omit<RequestParams$7, 'limit'>> {
    limit?: number;
}
type GetAddressesEvmJSONRequest = ReturnType<typeof serializeRequest$7>;
type GetAddressesEvmJSONResponse = SuccessResponse$9;
type GetAddressesEvmResponse = ReturnType<typeof deserializeResponse$9>;
interface GetAddressesEvmResponseAdapter extends PaginatedResponseAdapter<GetAddressesEvmResponse, GetAddressesEvmJSONResponse['result']> {
}
declare const getAddressesEvmOperation: PaginatedOperation<GetAddressesEvmRequest, GetAddressesEvmJSONRequest, GetAddressesEvmResponse, GetAddressesEvmJSONResponse['result']>;
declare function deserializeResponse$9(jsonResponse: GetAddressesEvmJSONResponse): {
    address: EvmAddress | undefined;
}[];
declare function serializeRequest$7(request: GetAddressesEvmRequest): {
    id: string;
    limit: number | undefined;
    cursor: string | undefined;
};

type OperationId$8 = 'UpdateStream';
type PathParams$3 = operations[OperationId$8]['parameters']['path'];
type BodyParams$2 = operations[OperationId$8]['requestBody']['content']['application/json'];
type RequestParams$6 = PathParams$3 & BodyParams$2;
type SuccessResponse$8 = operations[OperationId$8]['responses']['200']['content']['application/json'];
interface UpdateStreamEvmRequest extends Camelize<Omit<RequestParams$6, 'chainIds' | 'triggers'>> {
    chains?: EvmChainish[];
    triggers?: StreamTriggerish[];
}
type UpdateStreamEvmJSONRequest = ReturnType<typeof serializeRequest$6>;
type UpdateStreamEvmJSONResponse = SuccessResponse$8;
type UpdateStreamEvmResponse = ReturnType<typeof deserializeResponse$8>;
interface UpdateStreamEvmResponseAdapter extends ResponseAdapter<UpdateStreamEvmResponse, UpdateStreamEvmJSONResponse> {
}
declare const updateStreamEvmOperation: Operation<UpdateStreamEvmRequest, UpdateStreamEvmJSONRequest, UpdateStreamEvmResponse, UpdateStreamEvmJSONResponse>;
declare function deserializeResponse$8(jsonResponse: UpdateStreamEvmJSONResponse): EvmStream;
declare function serializeRequest$6(request: UpdateStreamEvmRequest): {
    id: string;
    webhookUrl: string | undefined;
    description: string | undefined;
    tag: string | undefined;
    topic0: string[] | null | undefined;
    allAddresses: boolean | undefined;
    includeNativeTxs: boolean | undefined;
    includeContractLogs: boolean | undefined;
    includeInternalTxs: boolean | undefined;
    includeAllTxLogs: boolean | undefined;
    chainIds: ("0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa")[] | undefined;
    abi: {
        anonymous?: boolean | undefined;
        constant?: boolean | undefined;
        inputs?: {
            name: string;
            type: string;
            indexed?: boolean | undefined;
            components?: any[] | undefined;
            internalType?: string | undefined;
        }[] | undefined;
        name?: string | undefined;
        outputs?: {
            name: string;
            type: string;
            components?: any[] | undefined;
            internalType?: string | undefined;
        }[] | undefined;
        payable?: boolean | undefined;
        stateMutability?: string | undefined;
        type: string;
        gas?: number | undefined;
    }[] | null | undefined;
    advancedOptions: {
        topic0: string;
        filter?: {
            [key: string]: unknown;
        } | undefined;
        includeNativeTxs?: boolean | undefined;
    }[] | null | undefined;
    demo: boolean | undefined;
    triggers: StreamTriggerJSON[] | undefined;
};

type OperationId$7 = 'UpdateStreamStatus';
type PathParams$2 = operations[OperationId$7]['parameters']['path'];
type BodyParams$1 = operations[OperationId$7]['requestBody']['content']['application/json'];
type RequestParams$5 = PathParams$2 & BodyParams$1;
type SuccessResponse$7 = operations[OperationId$7]['responses']['200']['content']['application/json'];
interface UpdateStreamStatusEvmRequest extends Camelize<RequestParams$5> {
}
type UpdateStreamStatusEvmJSONRequest = ReturnType<typeof serializeRequest$5>;
type UpdateStreamStatusEvmJSONResponse = SuccessResponse$7;
type UpdateStreamStatusEvmResponse = ReturnType<typeof deserializeResponse$7>;
interface UpdateStreamStatusEvmResponseAdapter extends ResponseAdapter<UpdateStreamStatusEvmResponse, UpdateStreamStatusEvmJSONResponse> {
}
declare const updateStreamStatusEvmOperation: Operation<UpdateStreamStatusEvmRequest, UpdateStreamStatusEvmJSONRequest, UpdateStreamStatusEvmResponse, UpdateStreamStatusEvmJSONResponse>;
declare function deserializeResponse$7(jsonResponse: UpdateStreamStatusEvmJSONResponse): {
    webhookUrl: string;
    description: string;
    tag: string;
    topic0?: string[] | null | undefined;
    allAddresses?: boolean | undefined;
    includeNativeTxs?: boolean | undefined;
    includeContractLogs?: boolean | undefined;
    includeInternalTxs?: boolean | undefined;
    includeAllTxLogs?: boolean | undefined;
    getNativeBalances?: {
        selectors: string[];
        type: "tx" | "log" | "erc20transfer" | "erc20approval" | "nfttransfer" | "internalTx";
    }[] | undefined;
    abi?: {
        anonymous?: boolean | undefined;
        constant?: boolean | undefined;
        inputs?: {
            name: string;
            type: string;
            indexed?: boolean | undefined;
            components?: any[] | undefined;
            internalType?: string | undefined;
        }[] | undefined;
        name?: string | undefined;
        outputs?: {
            name: string;
            type: string;
            components?: any[] | undefined;
            internalType?: string | undefined;
        }[] | undefined;
        payable?: boolean | undefined;
        stateMutability?: string | undefined;
        type: string;
        gas?: number | undefined;
    }[] | null | undefined;
    advancedOptions?: {
        topic0: string;
        filter?: {
            [key: string]: unknown;
        } | undefined;
        includeNativeTxs?: boolean | undefined;
    }[] | null | undefined;
    chainIds: string[];
    demo?: boolean | undefined;
    triggers?: {
        type: "tx" | "log" | "erc20transfer" | "erc20approval" | "nfttransfer";
        contractAddress: string;
        inputs?: (string & unknown[])[] | undefined;
        functionAbi: {
            anonymous?: boolean | undefined;
            constant?: boolean | undefined;
            inputs?: {
                name: string;
                type: string;
                indexed?: boolean | undefined;
                components?: any[] | undefined;
                internalType?: string | undefined;
            }[] | undefined;
            name?: string | undefined;
            outputs?: {
                name: string;
                type: string;
                components?: any[] | undefined;
                internalType?: string | undefined;
            }[] | undefined;
            payable?: boolean | undefined;
            stateMutability?: string | undefined;
            type: string;
            gas?: number | undefined;
        };
        topic0?: string | undefined;
        callFrom?: string | undefined;
    }[] | null | undefined;
    id: string;
    status: "active" | "paused" | "error" | "terminated";
    statusMessage: string;
};
declare function serializeRequest$5(request: UpdateStreamStatusEvmRequest): {
    id: string;
    status: Camelize<"active" | "paused" | "error" | "terminated">;
};

type OperationId$6 = 'GetHistory';
type QueryParams$1 = operations[OperationId$6]['parameters']['query'];
type RequestParams$4 = QueryParams$1;
type SuccessResponse$6 = operations[OperationId$6]['responses']['200']['content']['application/json'];
interface GetHistoryRequest extends Camelize<RequestParams$4> {
}
type GetHistoryJSONRequest = ReturnType<typeof serializeRequest$4>;
type GetHistoryJSONResponse = SuccessResponse$6;
type GetHistoryResponse = ReturnType<typeof deserializeResponse$6>;
declare const getHistoryOperation: PaginatedOperation<GetHistoryRequest, GetHistoryJSONRequest, GetHistoryResponse, GetHistoryJSONResponse['result']>;
declare function deserializeResponse$6(jsonResponse: GetHistoryJSONResponse): {
    id: string;
    date: string;
    payload?: (Partial<{
        block: {
            number: string;
            hash: string;
            timestamp: string;
        };
        chainId: string;
        logs: {
            triggers?: {
                value: unknown;
                name: string;
            }[] | undefined;
            logIndex: string;
            transactionHash: string;
            address: string;
            data: string;
            topic0: string | null;
            topic1: string | null;
            topic2: string | null;
            topic3: string | null;
        }[];
        txs: {
            triggers?: {
                value: unknown;
                name: string;
            }[] | undefined;
            hash: string;
            gas: string | null;
            gasPrice: string | null;
            nonce: string | null;
            input: string | null;
            transactionIndex: string;
            fromAddress: string;
            toAddress: string | null;
            value: string | null;
            type: string | null;
            v: string | null;
            r: string | null;
            s: string | null;
            receiptCumulativeGasUsed: string | null;
            receiptGasUsed: string | null;
            receiptContractAddress: string | null;
            receiptRoot: string | null;
            receiptStatus: string | null;
        }[];
        txsInternal: {
            from: string | null;
            to: string | null;
            value: string | null;
            transactionHash: string;
            gas: string | null;
        }[];
        abi: {
            anonymous?: boolean | undefined;
            constant?: boolean | undefined;
            inputs?: {
                name: string;
                type: string;
                indexed?: boolean | undefined;
                components?: any[] | undefined;
                internalType?: string | undefined;
            }[] | undefined;
            name?: string | undefined;
            outputs?: {
                name: string;
                type: string;
                components?: any[] | undefined;
                internalType?: string | undefined;
            }[] | undefined;
            payable?: boolean | undefined;
            stateMutability?: string | undefined;
            type: string;
            gas?: number | undefined;
        }[];
        retries: number;
        confirmed: boolean;
        tag: string;
        streamId: string;
    }> & Partial<{
        block: {
            lastVersion: string;
            firstVersion: string;
            hash: string;
            timestamp: string;
            number: string;
        };
        changes: ({
            txHash: string;
        } & {
            [key: string]: unknown;
        })[];
        coinDeposits: {
            txHash: string;
            sequenceNumber: string;
            valueWithDecimals: string;
            coin: {
                symbol: string;
                decimals: number;
                name: string;
            };
            address: string;
            value: string;
        }[];
        coinTransfers: {
            txHash: string;
            transaction: string;
            valueWithDecimals: number;
            from: string;
            value: string;
            to: string;
            coin: {
                symbol: string;
                decimals: number;
                name: string;
            };
        }[];
        coinWithdrawals: {
            txHash: string;
            sequenceNumber: string;
            valueWithDecimals: string;
            coin: {
                symbol: string;
                decimals: number;
                name: string;
            };
            address: string;
            value: string;
        }[];
        events: ({
            txHash: string;
        } & {
            [key: string]: unknown;
        })[];
        network: "mainnet" | "testnet";
        payloads: ({
            txHash: string;
        } & {
            [key: string]: unknown;
        })[];
        retries: number;
        streamId: string;
        tag: string;
        transactions: {
            gasUnitPrice: string;
            type: string;
            gasUsed: string;
            eventChangeHash: string;
            stateChangeHash: string;
            gasLimit: string;
            sender: string;
            success: boolean;
            hash: string;
        }[];
    }>) | undefined;
    tinyPayload: {
        chainId: string;
        confirmed: boolean;
        block: string;
        records: number;
        retries: number;
    };
    errorMessage: string;
    webhookUrl: string;
    streamId: string;
    tag: string;
}[];
declare function serializeRequest$4(request: GetHistoryRequest): GetHistoryRequest;

type OperationId$5 = 'ReplayHistory';
type PathParams$1 = operations[OperationId$5]['parameters']['path'];
type RequestParams$3 = PathParams$1;
type SuccessResponse$5 = operations[OperationId$5]['responses']['200']['content']['application/json'];
interface ReplayHistoryRequest extends Camelize<RequestParams$3> {
}
type ReplayHistoryJSONRequest = ReturnType<typeof serializeRequest$3>;
type ReplayHistoryJSONResponse = SuccessResponse$5;
type ReplayHistoryResponse = ReturnType<typeof deserializeResponse$5>;
declare const replayHistoryOperation: Operation<ReplayHistoryRequest, ReplayHistoryJSONRequest, ReplayHistoryResponse, ReplayHistoryJSONResponse>;
declare function deserializeResponse$5(jsonResponse: ReplayHistoryJSONResponse): {
    id: string;
    date: string;
    payload?: (Partial<{
        block: {
            number: string;
            hash: string;
            timestamp: string;
        };
        chainId: string;
        logs: {
            triggers?: {
                value: unknown;
                name: string;
            }[] | undefined;
            logIndex: string;
            transactionHash: string;
            address: string;
            data: string;
            topic0: string | null;
            topic1: string | null;
            topic2: string | null;
            topic3: string | null;
        }[];
        txs: {
            triggers?: {
                value: unknown;
                name: string;
            }[] | undefined;
            hash: string;
            gas: string | null;
            gasPrice: string | null;
            nonce: string | null;
            input: string | null;
            transactionIndex: string;
            fromAddress: string;
            toAddress: string | null;
            value: string | null;
            type: string | null;
            v: string | null;
            r: string | null;
            s: string | null;
            receiptCumulativeGasUsed: string | null;
            receiptGasUsed: string | null;
            receiptContractAddress: string | null;
            receiptRoot: string | null;
            receiptStatus: string | null;
        }[];
        txsInternal: {
            from: string | null;
            to: string | null;
            value: string | null;
            transactionHash: string;
            gas: string | null;
        }[];
        abi: {
            anonymous?: boolean | undefined;
            constant?: boolean | undefined;
            inputs?: {
                name: string;
                type: string;
                indexed?: boolean | undefined;
                components?: any[] | undefined;
                internalType?: string | undefined;
            }[] | undefined;
            name?: string | undefined;
            outputs?: {
                name: string;
                type: string;
                components?: any[] | undefined;
                internalType?: string | undefined;
            }[] | undefined;
            payable?: boolean | undefined;
            stateMutability?: string | undefined;
            type: string;
            gas?: number | undefined;
        }[];
        retries: number;
        confirmed: boolean;
        tag: string;
        streamId: string;
    }> & Partial<{
        block: {
            lastVersion: string;
            firstVersion: string;
            hash: string;
            timestamp: string;
            number: string;
        };
        changes: ({
            txHash: string;
        } & {
            [key: string]: unknown;
        })[];
        coinDeposits: {
            txHash: string;
            sequenceNumber: string;
            valueWithDecimals: string;
            coin: {
                symbol: string;
                decimals: number;
                name: string;
            };
            address: string;
            value: string;
        }[];
        coinTransfers: {
            txHash: string;
            transaction: string;
            valueWithDecimals: number;
            from: string;
            value: string;
            to: string;
            coin: {
                symbol: string;
                decimals: number;
                name: string;
            };
        }[];
        coinWithdrawals: {
            txHash: string;
            sequenceNumber: string;
            valueWithDecimals: string;
            coin: {
                symbol: string;
                decimals: number;
                name: string;
            };
            address: string;
            value: string;
        }[];
        events: ({
            txHash: string;
        } & {
            [key: string]: unknown;
        })[];
        network: "mainnet" | "testnet";
        payloads: ({
            txHash: string;
        } & {
            [key: string]: unknown;
        })[];
        retries: number;
        streamId: string;
        tag: string;
        transactions: {
            gasUnitPrice: string;
            type: string;
            gasUsed: string;
            eventChangeHash: string;
            stateChangeHash: string;
            gasLimit: string;
            sender: string;
            success: boolean;
            hash: string;
        }[];
    }>) | undefined;
    tinyPayload: {
        chainId: string;
        confirmed: boolean;
        block: string;
        records: number;
        retries: number;
    };
    errorMessage: string;
    webhookUrl: string;
    streamId: string;
    tag: string;
};
declare function serializeRequest$3(request: ReplayHistoryRequest): {
    streamId: string;
    id: string;
};

type OperationId$4 = 'GetLogs';
type QueryParams = operations[OperationId$4]['parameters']['query'];
type RequestParams$2 = QueryParams;
type SuccessResponse$4 = operations[OperationId$4]['responses']['200']['content']['application/json'];
interface GetLogsRequest extends Camelize<RequestParams$2> {
}
type GetLogsJSONRequest = ReturnType<typeof serializeRequest$2>;
type GetLogsJSONResponse = SuccessResponse$4;
type GetLogsResponse = ReturnType<typeof deserializeResponse$4>;
declare const getLogsOperation: PaginatedOperation<GetLogsRequest, GetLogsJSONRequest, GetLogsResponse, GetLogsJSONResponse['result']>;
declare function deserializeResponse$4(jsonResponse: GetLogsJSONResponse): {
    chain: EvmChain;
    id: string;
    streamId: string;
    webhookUrl: string;
    tag: string;
    retries: number;
    deliveryStatus: "failed" | "success";
    blockNumber: number;
    errorMessage: string;
    type: "evm" | "aptos";
    createdAt: string;
}[];
declare function serializeRequest$2(request: GetLogsRequest): GetLogsRequest;

type OperationId$3 = 'GetSettings';
type SuccessResponse$3 = operations[OperationId$3]['responses']['200']['content']['application/json'];
interface GetSettingsRequest {
}
type GetSettingsJSONRequest = undefined;
type GetSettingsJSONResponse = SuccessResponse$3;
type GetSettingsResponse = ReturnType<typeof deserializeResponse$3>;
declare const getSettingsOperation: Operation<GetSettingsRequest, GetSettingsJSONRequest, GetSettingsResponse, GetSettingsJSONResponse>;
declare function deserializeResponse$3(jsonResponse: GetSettingsJSONResponse): {
    region?: "us-east-1" | "us-west-2" | "eu-central-1" | "ap-southeast-1" | undefined;
};

type OperationId$2 = 'SetSettings';
type BodyParams = operations[OperationId$2]['requestBody']['content']['application/json'];
type RequestParams$1 = BodyParams;
type SuccessResponse$2 = operations[OperationId$2]['responses']['200']['content']['application/json'];
interface SetSettingsRequest extends Camelize<RequestParams$1> {
}
type SetSettingsJSONRequest = ReturnType<typeof serializeRequest$1>;
type SetSettingsJSONResponse = SuccessResponse$2;
type SetSettingsResponse = ReturnType<typeof deserializeResponse$2>;
declare const setSettingsOperation: Operation<SetSettingsRequest, SetSettingsJSONRequest, SetSettingsResponse, SetSettingsJSONResponse>;
declare function deserializeResponse$2(jsonResponse: SetSettingsJSONResponse): {
    region?: "us-east-1" | "us-west-2" | "eu-central-1" | "ap-southeast-1" | undefined;
};
declare function serializeRequest$1(request: SetSettingsRequest): {
    region: "us-east-1" | "us-west-2" | "eu-central-1" | "ap-southeast-1" | undefined;
};

type OperationId$1 = 'GetStats';
type SuccessResponse$1 = operations[OperationId$1]['responses']['200']['content']['application/json'];
interface GetStatsRequest {
}
type GetStatsJSONRequest = undefined;
type GetStatsJSONResponse = SuccessResponse$1;
type GetStatsResponse = ReturnType<typeof deserializeResponse$1>;
declare const getStatsOperation: Operation<GetStatsRequest, GetStatsJSONRequest, GetStatsResponse, GetStatsJSONResponse>;
declare function deserializeResponse$1(jsonResponse: GetStatsJSONResponse): {
    totalWebhooksDelivered: number;
    totalWebhooksFailed: number;
    totalLogsProcessed: number;
    totalTxsProcessed: number;
    totalTxsInternalProcessed: number;
    streams?: {
        totalWebhooksDelivered: number;
        totalWebhooksFailed: number;
        totalLogsProcessed: number;
        totalTxsProcessed: number;
        totalTxsInternalProcessed: number;
        streamId: string;
    }[] | undefined;
    createdAt?: string | undefined;
    updatedAt?: string | undefined;
};

type OperationId = 'GetStatsByStreamId';
type PathParams = operations[OperationId]['parameters']['path'];
type RequestParams = PathParams;
type SuccessResponse = operations[OperationId]['responses']['200']['content']['application/json'];
interface GetStatsByIdRequest extends Camelize<RequestParams> {
}
type GetStatsByIdJSONRequest = ReturnType<typeof serializeRequest>;
type GetStatsByIdJSONResponse = SuccessResponse;
type GetStatsByIdResponse = ReturnType<typeof deserializeResponse>;
declare const getStatsByIdOperation: Operation<GetStatsByIdRequest, GetStatsByIdJSONRequest, GetStatsByIdResponse, GetStatsByIdJSONResponse>;
declare function deserializeResponse(jsonResponse: GetStatsByIdJSONResponse): {
    totalWebhooksDelivered: number;
    totalWebhooksFailed: number;
    totalLogsProcessed: number;
    totalTxsProcessed: number;
    totalTxsInternalProcessed: number;
    streams?: {
        totalWebhooksDelivered: number;
        totalWebhooksFailed: number;
        totalLogsProcessed: number;
        totalTxsProcessed: number;
        totalTxsInternalProcessed: number;
        streamId: string;
    }[] | undefined;
    createdAt?: string | undefined;
    updatedAt?: string | undefined;
};
declare function serializeRequest(request: GetStatsByIdRequest): GetStatsByIdRequest;

export { AddAddressAptosJSONRequest, AddAddressAptosJSONResponse, AddAddressAptosRequest, AddAddressAptosResponse, AddAddressAptosResponseAdapter, AddAddressEvmJSONRequest, AddAddressEvmJSONResponse, AddAddressEvmRequest, AddAddressEvmResponse, AddAddressEvmResponseAdapter, AptosStream, AptosStreamData, AptosStreamInput, AptosStreamJSON, AptosStreamish, CreateStreamAptosJSONRequest, CreateStreamAptosJSONResponse, CreateStreamAptosRequest, CreateStreamAptosResponse, CreateStreamAptosResponseAdapter, CreateStreamEvmJSONRequest, CreateStreamEvmJSONResponse, CreateStreamEvmRequest, CreateStreamEvmResponse, CreateStreamEvmResponseAdapter, DeleteAddressAptosJSONRequest, DeleteAddressAptosJSONResponse, DeleteAddressAptosRequest, DeleteAddressAptosResponse, DeleteAddressAptosResponseAdapter, DeleteAddressEvmJSONRequest, DeleteAddressEvmJSONResponse, DeleteAddressEvmRequest, DeleteAddressEvmResponse, DeleteAddressEvmResponseAdapter, DeleteStreamAptosJSONRequest, DeleteStreamAptosJSONResponse, DeleteStreamAptosRequest, DeleteStreamAptosResponse, DeleteStreamAptosResponseAdapter, DeleteStreamEvmJSONRequest, DeleteStreamEvmJSONResponse, DeleteStreamEvmRequest, DeleteStreamEvmResponse, DeleteStreamEvmResponseAdapter, EvmAbi, EvmStream, EvmStreamAdvancedOptions, EvmStreamData, EvmStreamInput, EvmStreamJSON, EvmStreamResult, EvmStreamResultData, EvmStreamResultInput, EvmStreamResultish, EvmStreamish, GetAddressesAptosJSONRequest, GetAddressesAptosJSONResponse, GetAddressesAptosRequest, GetAddressesAptosResponse, GetAddressesAptosResponseAdapter, GetAddressesEvmJSONRequest, GetAddressesEvmJSONResponse, GetAddressesEvmRequest, GetAddressesEvmResponse, GetAddressesEvmResponseAdapter, GetHistoryJSONRequest, GetHistoryJSONResponse, GetHistoryRequest, GetHistoryResponse, GetLogsJSONRequest, GetLogsJSONResponse, GetLogsRequest, GetLogsResponse, GetNativeBalanceType, GetSettingsJSONRequest, GetSettingsJSONResponse, GetSettingsRequest, GetSettingsResponse, GetStatsByIdJSONRequest, GetStatsByIdJSONResponse, GetStatsByIdRequest, GetStatsByIdResponse, GetStatsJSONRequest, GetStatsJSONResponse, GetStatsRequest, GetStatsResponse, GetStreamAptosJSONRequest, GetStreamAptosJSONResponse, GetStreamAptosRequest, GetStreamAptosResponse, GetStreamAptosResponseAdapter, GetStreamEvmJSONRequest, GetStreamEvmJSONResponse, GetStreamEvmRequest, GetStreamEvmResponse, GetStreamEvmResponseAdapter, GetStreamsAptosJSONRequest, GetStreamsAptosJSONResponse, GetStreamsAptosRequest, GetStreamsAptosResponse, GetStreamsAptosResponseAdapter, GetStreamsEvmJSONRequest, GetStreamsEvmJSONResponse, GetStreamsEvmRequest, GetStreamsEvmResponse, GetStreamsEvmResponseAdapter, ReplayHistoryJSONRequest, ReplayHistoryJSONResponse, ReplayHistoryRequest, ReplayHistoryResponse, SetSettingsJSONRequest, SetSettingsJSONResponse, SetSettingsRequest, SetSettingsResponse, StreamErc1155Approval, StreamErc1155ApprovalData, StreamErc1155ApprovalInput, StreamErc1155ApprovalJSON, StreamErc1155Approvalish, StreamErc20Approval, StreamErc20ApprovalData, StreamErc20ApprovalInput, StreamErc20ApprovalJSON, StreamErc20Approvalish, StreamErc20Transfer, StreamErc20TransferData, StreamErc20TransferInput, StreamErc20TransferJSON, StreamErc20Transferish, StreamErc721Approval, StreamErc721ApprovalData, StreamErc721ApprovalInput, StreamErc721ApprovalJSON, StreamErc721Approvalish, StreamEvmInternalTransaction, StreamEvmInternalTransactionData, StreamEvmInternalTransactionInput, StreamEvmInternalTransactionJSON, StreamEvmInternalTransactionish, StreamEvmNftTokenApproval, StreamEvmNftTokenApprovalData, StreamEvmNftTokenApprovalish, StreamEvmNftTransfer, StreamEvmNftTransferData, StreamEvmNftTransferInput, StreamEvmNftTransferJSON, StreamEvmTransaction, StreamEvmTransactionData, StreamEvmTransactionInput, StreamEvmTransactionJSON, StreamEvmTransactionLog, StreamEvmTransactionLogData, StreamEvmTransactionLogInput, StreamEvmTransactionLogJSON, StreamStatus, StreamTrigger, StreamTriggerData, StreamTriggerInput, StreamTriggerJSON, StreamTriggerOutput, StreamTriggerOutputData, StreamTriggerOutputInput, StreamTriggerOutputJSON, StreamTriggerOutputish, StreamTriggerish, UpdateStreamAptosJSONRequest, UpdateStreamAptosJSONResponse, UpdateStreamAptosRequest, UpdateStreamAptosResponse, UpdateStreamAptosResponseAdapter, UpdateStreamEvmJSONRequest, UpdateStreamEvmJSONResponse, UpdateStreamEvmRequest, UpdateStreamEvmResponse, UpdateStreamEvmResponseAdapter, UpdateStreamStatusAptosJSONRequest, UpdateStreamStatusAptosJSONResponse, UpdateStreamStatusAptosRequest, UpdateStreamStatusAptosResponse, UpdateStreamStatusAptosResponseAdapter, UpdateStreamStatusEvmJSONRequest, UpdateStreamStatusEvmJSONResponse, UpdateStreamStatusEvmRequest, UpdateStreamStatusEvmResponse, UpdateStreamStatusEvmResponseAdapter, addAddressAptosOperation, addAddressEvmOperation, createStreamAptosOperation, createStreamEvmOperation, deleteAddressAptosOperation, deleteAddressEvmOperation, deleteStreamAptosOperation, deleteStreamEvmOperation, getAddressesAptosOperation, getAddressesEvmOperation, getHistoryOperation, getLogsOperation, getSettingsOperation, getStatsByIdOperation, getStatsOperation, getStreamAptosOperation, getStreamEvmOperation, getStreamsAptosOperation, getStreamsEvmOperation, replayHistoryOperation, setSettingsOperation, updateStreamAptosOperation, updateStreamEvmOperation, updateStreamStatusAptosOperation, updateStreamStatusEvmOperation };
