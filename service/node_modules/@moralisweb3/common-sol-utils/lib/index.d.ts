import * as _moralisweb3_common_core from '@moralisweb3/common-core';
import { MoralisData, MoralisDataFormatted, BigNumberish, BigNumber, Module, Core, Camelize, ResponseAdapter, Operation, Config, ConfigKey } from '@moralisweb3/common-core';

/**
 * Valid input for a new SolAddress instance.
 * This can be an existing SolAddress or a valid address string.
 *
 * @example "9WzDXwBbmkg8ZTbNMqUxvQRAyrZzDsGYdLVL9zYtAWWM"
 * @example SolAddress.create("9WzDXwBbmkg8ZTbNMqUxvQRAyrZzDsGYdLVL9zYtAWWM")
 */
type SolAddressish = SolAddressInput;
type SolAddressInput = SolAddress | string;
type SolAddressJSON = string;
/**
 * A representation of an address on the Solana network.
 *
 * Use this class any time you work with an address.
 *
 * @category DataType
 */
declare class SolAddress implements MoralisData {
    readonly address: string;
    /**
     * Create a new instance of SolAddress from any valid address input.
     *
     * @example `const address = SolAddress.create("9WzDXwBbmkg8ZTbNMqUxvQRAyrZzDsGYdLVL9zYtAWWM")`
     * @throws an error when a passed address is invalid.
     */
    static create(address: SolAddressInput): SolAddress;
    static fromJSON(address: SolAddressJSON): SolAddress;
    private static parse;
    constructor(address: string);
    /**
     * @deprecated This method will be removed soon. To format the value, use one of the properties.
     */
    format(): MoralisDataFormatted;
    /**
     * Checks the equality of the current address with another Solana address.
     * @example `address.equals("9WzDXwBbmkg8ZTbNMqUxvQRAyrZzDsGYdLVL9zYtAWWM")`
     * @example `address.equals(SolAddress.create("9WzDXwBbmkg8ZTbNMqUxvQRAyrZzDsGYdLVL9zYtAWWM"))`
     */
    equals(address: SolAddressish): boolean;
    /**
     * @returns a string representing the address.
     * @example address.toString(); // "9WzDXwBbmkg8ZTbNMqUxvQRAyrZzDsGYdLVL9zYtAWWM"
     */
    toString(): string;
    /**
     * @returns a string representing the address.
     * @example address.toJSON(); // "9WzDXwBbmkg8ZTbNMqUxvQRAyrZzDsGYdLVL9zYtAWWM"
     */
    toJSON(): SolAddressJSON;
}

declare const solNetworkNames: readonly ["mainnet", "devnet"];
/**
 * A name of Solana network.
 *
 * @example "mainnet"
 * @example "devnet"
 */
type SolNetworkName = typeof solNetworkNames[number];
type SolNetworkInput = SolNetwork | SolNetworkName | string;
type SolNetworkJSON = string;
/**
 * Valid input for a new SolNetwork instance.
 * This can be an existing SolNetwork or a valid network name.
 *
 * @example "mainnet"
 * @example "devnet"
 * @example SolNetwork.create("mainnet")
 */
type SolNetworkish = SolNetworkInput;
/**
 * A representation of a Solana network.
 *
 * @category DataType
 */
declare class SolNetwork implements MoralisData {
    readonly network: SolNetworkName;
    /**
     * Returns MAINNET network
     *
     * @example SolNetwork.MAINNET
     */
    static get MAINNET(): SolNetwork;
    /**
     * Returns DEVNET network
     *
     * @example SolNetwork.MAINNET
     */
    static get DEVNET(): SolNetwork;
    /**
     * Create a new instance of SolNetwork from any valid network input.
     *
     * @example `const network = SolNetwork.create("mainnet")`
     * @throws an error when a passed network is invalid.
     */
    static create(network: SolNetworkish): SolNetwork;
    static fromJSON(network: SolNetworkJSON): SolNetwork;
    private static parse;
    private constructor();
    /**
     * @deprecated This method will be removed soon. To format the value, use one of the properties.
     */
    format(): MoralisDataFormatted;
    /**
     * Checks the equality of the current network with another Solana network.
     * @example `network.equals("mainnet")`
     * @example `network.equals(SolNetwork.create("mainnet"))`
     */
    equals(network: SolNetworkish): boolean;
    /**
     * @returns a string representing the network.
     * @example network.toJSON(); // "mainnet"
     */
    toJSON(): SolNetworkJSON;
    /**
     * @returns a string representing the network.
     * @example network.toString(); // "mainnet"
     */
    toString(): string;
}

/**
 * Type containing valid Solana native units
 */
type SolNativeUnit = 'solana' | 'lamports' | number;
/**
 * Valid input for a new SolNative instance.
 * This can be an existing {@link SolNative} or a valid {@link @moralisweb3/common-core!BigNumberish} type
 */
type SolNativeish = SolNativeInput;
type SolNativeInput = SolNative | BigNumberish;
type SolNativeJSON = string;
/**
 * The SolNative class is a MoralisData that references to the value of Solana native currency SOL
 *
 * @category DataType
 */
declare class SolNative implements MoralisData {
    private readonly rawValue;
    /**
     * Create a new instance of SolNative from any valid {@link SolNativeish} value.
     * @param value - the value to create the SolNative from
     * @param unit - the unit of the value (optional), defaults to `solana`
     * @returns a new instance of SolNative
     * @example
     * ```ts
     * const native = SolNative.create(2, 'lamports');
     * const native = SolNative.create(2);
     *```
     */
    static create(value: SolNativeish, unit?: SolNativeUnit): SolNative;
    static fromJSON(json: SolNativeJSON): SolNative;
    private static parse;
    private constructor();
    /**
     * Compares two SolNativeish values.
     * @param valueA - the first value to compare
     * @param valueB - the second value to compare
     * @returns true if the values are equal
     * @example
     * ```ts
     * SolNative.equals(SolNative.create(1), SolNative.create(1)); // true
     * ```
     */
    static equals(valueA: SolNativeish, valueB: SolNativeish): boolean;
    /**
     * Compares SolNative with current instance.
     * @param value - the value to compare with
     * @returns true if the values are equal
     * @example
     * ```ts
     * const native = SolNative.create(2, 'lamports');
     * native.equals(SolNative.create(1)); // false
     * ```
     */
    equals(value: SolNative): boolean;
    /**
     * @deprecated This method will be removed soon. To format the value, use one of the properties.
     */
    format(): MoralisDataFormatted;
    /**
     * Converts the SolNative to a string.
     * @returns the value of the SolNative as a string
     * @example `native.toJSON()`
     */
    toJSON(): SolNativeJSON;
    /**
     * Converts the SolNative to a string.
     * @returns the value of the SolNative as a string
     * @example `native.toString()`
     */
    toString(): string;
    /**
     * @returns the value of the SolNative as a BigNumber
     * @example `native.value`
     */
    get value(): BigNumber;
    /**
     * Converts the SolNative to a solana unit.
     * @returns the value of the SolNative as a solana string
     * @example `native.solana`
     */
    get solana(): string;
    /**
     * Converts the SolNative to a string.
     * @returns the value of the SolNative as a string
     * @example `native.lamports`
     */
    get lamports(): string;
}

interface SolSPLNativePriceJSON {
    readonly value: string;
    readonly decimals: number;
    readonly name: string;
    readonly symbol: string;
}
interface SolSPLNativePriceInput {
    readonly value: string;
    readonly decimals: number;
    readonly name: string;
    readonly symbol: string;
}
declare class SolSPLNativePrice {
    static create(input: SolSPLNativePriceInput | SolSPLNativePrice): SolSPLNativePrice;
    static fromJSON(json: SolSPLNativePriceJSON): SolSPLNativePrice;
    readonly value: string;
    readonly decimals: number;
    readonly name: string;
    readonly symbol: string;
    private constructor();
    toJSON(): SolSPLNativePriceJSON;
}

interface SolSPLTokenPriceJSON {
    readonly nativePrice?: SolSPLNativePriceJSON;
    readonly usdPrice: number;
    readonly exchangeAddress: SolAddressJSON;
    readonly exchangeName: string;
}
interface SolSPLTokenPriceInput {
    readonly nativePrice?: SolSPLNativePriceInput | SolSPLNativePrice;
    readonly usdPrice: number;
    readonly exchangeAddress: SolAddressInput | SolAddress;
    readonly exchangeName: string;
}
declare class SolSPLTokenPrice {
    static create(input: SolSPLTokenPriceInput | SolSPLTokenPrice): SolSPLTokenPrice;
    static fromJSON(json: SolSPLTokenPriceJSON): SolSPLTokenPrice;
    readonly nativePrice?: SolSPLNativePrice;
    readonly usdPrice: number;
    readonly exchangeAddress: SolAddress;
    readonly exchangeName: string;
    private constructor();
    toJSON(): SolSPLTokenPriceJSON;
}

interface GetTokenPriceOperationRequest {
    /**
     * @description The network to query
     */
    readonly network: SolNetworkInput | SolNetwork;
    /**
     * @description The address of the token contract
     */
    readonly address: SolAddressInput | SolAddress;
}
interface GetTokenPriceOperationRequestJSON {
    readonly network: SolNetworkJSON;
    readonly address: SolAddressJSON;
}
type GetTokenPriceOperationResponse = SolSPLTokenPrice;
type GetTokenPriceOperationResponseJSON = SolSPLTokenPriceJSON;
declare const GetTokenPriceOperation: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: SolSPLTokenPriceJSON): SolSPLTokenPrice;
    serializeRequest(request: GetTokenPriceOperationRequest): GetTokenPriceOperationRequestJSON;
};

declare const operations$1: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: SolSPLTokenPriceJSON): SolSPLTokenPrice;
    serializeRequest(request: GetTokenPriceOperationRequest): GetTokenPriceOperationRequestJSON;
}[];

type SolGetTokenPriceNetworkEnumJSON = "mainnet";
type SolGetTokenPriceNetworkEnumInput = "mainnet";
type SolGetTokenPriceNetworkEnumValue = "mainnet";
declare abstract class SolGetTokenPriceNetworkEnum {
    static create(input: SolGetTokenPriceNetworkEnumInput | SolGetTokenPriceNetworkEnumValue): SolGetTokenPriceNetworkEnumValue;
    static fromJSON(json: SolGetTokenPriceNetworkEnumJSON): SolGetTokenPriceNetworkEnumValue;
}

declare class CommonSolUtils extends Module {
    static readonly moduleName = "solUtils";
    static create(core?: Core): CommonSolUtils;
    private constructor();
    setup(): void;
    start(): void;
    get SolAddress(): typeof SolAddress;
    get SolNative(): typeof SolNative;
    get SolNetwork(): typeof SolNetwork;
}

interface components {
    schemas: {
        NativeBalance: {
            solana: string;
            lamports: string;
        };
        SPLTokenBalance: {
            associatedTokenAddress: string;
            mint: string;
            name: string;
            symbol: string;
            amount: string;
            amountRaw: string;
            decimals: number;
        };
        SPLNFT: {
            associatedTokenAddress: string;
            mint: string;
            name: string;
            symbol: string;
        };
        Portfolio: {
            nativeBalance: components["schemas"]["NativeBalance"];
            nfts: components["schemas"]["SPLNFT"][];
            tokens: components["schemas"]["SPLTokenBalance"][];
        };
        MetaplexNFT: {
            metadataUri: string;
            masterEdition: boolean;
            isMutable: boolean;
            primarySaleHappened: boolean;
            sellerFeeBasisPoints: number;
            updateAuthority: string;
        };
        NFTMetadata: {
            mint: string;
            standard: string;
            name: string;
            symbol: string;
            metaplex: components["schemas"]["MetaplexNFT"];
        };
        SPLNativePrice: {
            value: string;
            decimals: number;
            name: string;
            symbol: string;
        };
        SPLTokenPrice: {
            nativePrice?: components["schemas"]["SPLNativePrice"];
            usdPrice: number;
            exchangeAddress: string;
            exchangeName: string;
        };
    };
}
interface operations {
    /** Gets the native balance owned by a given network and address. */
    balance: {
        parameters: {
            path: {
                /** The network to query */
                network: "mainnet" | "devnet";
                /** The address for which the native balance will be checked */
                address: string;
            };
        };
        responses: {
            200: {
                content: {
                    "application/json": components["schemas"]["NativeBalance"];
                };
            };
            400: {
                content: {
                    "application/json": string;
                };
            };
        };
    };
    /** Gets the token balances owned by a given network and address. */
    getSPL: {
        parameters: {
            path: {
                /** The network to query */
                network: "mainnet" | "devnet";
                /** The address for which token balances will be checked */
                address: string;
            };
        };
        responses: {
            200: {
                content: {
                    "application/json": components["schemas"]["SPLTokenBalance"][];
                };
            };
            400: {
                content: {
                    "application/json": string;
                };
            };
        };
    };
    /** Gets NFTs owned by a given network and address. */
    getNFTs: {
        parameters: {
            path: {
                /** The network to query */
                network: "mainnet" | "devnet";
                /** The address of the contract */
                address: string;
            };
        };
        responses: {
            200: {
                content: {
                    "application/json": components["schemas"]["SPLNFT"][];
                };
            };
            400: {
                content: {
                    "application/json": string;
                };
            };
        };
    };
    /** Gets the portfolio for a given network and address. */
    getPortfolio: {
        parameters: {
            path: {
                /** The network to query */
                network: "mainnet" | "devnet";
                /** The address of the token contract */
                address: string;
            };
        };
        responses: {
            200: {
                content: {
                    "application/json": components["schemas"]["Portfolio"];
                };
            };
            400: {
                content: {
                    "application/json": string;
                };
            };
        };
    };
    /** Get the global NFT metadata for a given network and contract (mint, standard, name, symbol, metaplex). */
    getNFTMetadata: {
        parameters: {
            path: {
                /** The network to query */
                network: "mainnet" | "devnet";
                /** The address of the contract */
                address: string;
            };
        };
        responses: {
            200: {
                content: {
                    "application/json": components["schemas"]["NFTMetadata"];
                };
            };
            400: {
                content: {
                    "application/json": string;
                };
            };
        };
    };
    /** Gets the token price (usd and native) for a given contract address and network. */
    getTokenPrice: {
        parameters: {
            path: {
                /** The network to query */
                network: "mainnet";
                /** The address of the token contract */
                address: string;
            };
        };
        responses: {
            200: {
                content: {
                    "application/json": components["schemas"]["SPLTokenPrice"];
                };
            };
            400: {
                content: {
                    "application/json": string;
                };
            };
        };
    };
}

type OperationId$5 = 'balance';
type PathParams$5 = operations[OperationId$5]['parameters']['path'];
type SuccessResponse$5 = operations[OperationId$5]['responses']['200']['content']['application/json'];
interface GetBalanceRequest extends Camelize<Omit<PathParams$5, 'network' | 'address'>> {
    network?: SolNetworkish;
    address: SolAddressish;
}
type GetBalanceJSONRequest = ReturnType<typeof serializeRequest$5>;
interface GetBalanceJSONResponse extends SuccessResponse$5 {
}
type GetBalanceResponse = ReturnType<typeof deserializeResponse$5>;
interface GetBalanceResponseAdapter extends ResponseAdapter<GetBalanceResponse, GetBalanceJSONResponse> {
}
/** Gets native balance owned by the given network and address */
declare const getBalanceOperation: Operation<GetBalanceRequest, GetBalanceJSONRequest, GetBalanceResponse, GetBalanceJSONResponse>;
declare function deserializeResponse$5(jsonResponse: GetBalanceJSONResponse): SolNative;
declare function serializeRequest$5(request: GetBalanceRequest, core: Core): {
    address: string;
    network: "mainnet" | "devnet";
};

type OperationId$4 = 'getNFTs';
type PathParams$4 = operations[OperationId$4]['parameters']['path'];
type SuccessResponse$4 = operations[OperationId$4]['responses']['200']['content']['application/json'];
interface GetNFTsRequest extends Camelize<Omit<PathParams$4, 'network' | 'address'>> {
    network?: SolNetworkish;
    address: SolAddressish;
}
type GetNFTsJSONRequest = ReturnType<typeof serializeRequest$4>;
interface GetNFTsJSONResponse extends SuccessResponse$4 {
}
type GetNFTsResponse = ReturnType<typeof deserializeResponse$4>;
interface GetNFTsResponseAdapter extends ResponseAdapter<GetNFTsResponse, GetNFTsJSONResponse> {
}
/** Gets NFTs owned by the given network and address */
declare const getNFTsOperation: Operation<GetNFTsRequest, GetNFTsJSONRequest, GetNFTsResponse, GetNFTsJSONResponse>;
declare function deserializeResponse$4(jsonResponse: GetNFTsJSONResponse): {
    associatedTokenAddress: SolAddress;
    mint: SolAddress;
    name: string;
    symbol: string;
}[];
declare function serializeRequest$4(request: GetNFTsRequest, core: Core): {
    address: string;
    network: "mainnet" | "devnet";
};

type OperationId$3 = 'getPortfolio';
type PathParams$3 = operations[OperationId$3]['parameters']['path'];
type SuccessResponse$3 = operations[OperationId$3]['responses']['200']['content']['application/json'];
interface GetPortfolioRequest extends Camelize<Omit<PathParams$3, 'network' | 'address'>> {
    network?: SolNetworkish;
    address: SolAddressish;
}
type GetPortfolioJSONRequest = ReturnType<typeof serializeRequest$3>;
interface GetPortfolioJSONResponse extends SuccessResponse$3 {
}
type GetPortfolioResponse = ReturnType<typeof deserializeResponse$3>;
interface GetPortfolioResponseAdapter extends ResponseAdapter<GetPortfolioResponse, GetPortfolioJSONResponse> {
}
/** Gets the portfolio of the given network and address */
declare const getPortfolioOperation: Operation<GetPortfolioRequest, GetPortfolioJSONRequest, GetPortfolioResponse, GetPortfolioJSONResponse>;
declare function deserializeResponse$3(jsonResponse: GetPortfolioJSONResponse): {
    nativeBalance: SolNative;
    nfts: {
        associatedTokenAddress: SolAddress;
        mint: SolAddress;
        name: string;
        symbol: string;
    }[];
    tokens: {
        associatedTokenAddress: SolAddress;
        mint: SolAddress;
        amount: SolNative;
        name: string;
        symbol: string;
    }[];
};
declare function serializeRequest$3(request: GetPortfolioRequest, core: Core): {
    address: string;
    network: "mainnet" | "devnet";
};

type OperationId$2 = 'getSPL';
type PathParams$2 = operations[OperationId$2]['parameters']['path'];
type SuccessResponse$2 = operations[OperationId$2]['responses']['200']['content']['application/json'];
interface GetSPLRequest extends Camelize<Omit<PathParams$2, 'network' | 'address'>> {
    network?: SolNetworkish;
    address: SolAddressish;
}
type GetSPLJSONRequest = ReturnType<typeof serializeRequest$2>;
interface GetSPLJSONResponse extends SuccessResponse$2 {
}
type GetSPLResponse = ReturnType<typeof deserializeResponse$2>;
interface GetSPLResponseAdapter extends ResponseAdapter<GetSPLResponse, GetSPLJSONResponse> {
}
/** Gets token balances owned by the given network and address */
declare const getSPLOperation: Operation<GetSPLRequest, GetSPLJSONRequest, GetSPLResponse, GetSPLJSONResponse>;
declare function deserializeResponse$2(jsonResponse: GetSPLJSONResponse): {
    associatedTokenAddress: SolAddress;
    mint: SolAddress;
    amount: SolNative;
    name: string;
    symbol: string;
}[];
declare function serializeRequest$2(request: GetSPLRequest, core: Core): {
    address: string;
    network: "mainnet" | "devnet";
};

type OperationId$1 = 'getNFTMetadata';
type PathParams$1 = operations[OperationId$1]['parameters']['path'];
type SuccessResponse$1 = operations[OperationId$1]['responses']['200']['content']['application/json'];
interface GetNFTMetadataRequest extends Camelize<Omit<PathParams$1, 'network' | 'address'>> {
    network?: SolNetworkish;
    address: SolAddressish;
}
type GetNFTMetadataJSONRequest = ReturnType<typeof serializeRequest$1>;
interface GetNFTMetadataJSONResponse extends SuccessResponse$1 {
}
type GetNFTMetadataResponse = ReturnType<typeof deserializeResponse$1>;
interface GetNFTMetadataResponseAdapter extends ResponseAdapter<GetNFTMetadataResponse, GetNFTMetadataJSONResponse> {
}
/** Gets the contract level metadata (mint, standard, name, symbol, metaplex) for the given network and contract */
declare const getNFTMetadataOperation: Operation<GetNFTMetadataRequest, GetNFTMetadataJSONRequest, GetNFTMetadataResponse, GetNFTMetadataJSONResponse>;
declare function deserializeResponse$1(jsonResponse: GetNFTMetadataJSONResponse): {
    mint: SolAddress;
    standard: string;
    name: string;
    symbol: string;
    metaplex: {
        metadataUri: string;
        updateAuthority: SolAddress;
        sellerFeeBasisPoints: number;
        primarySaleHappened: boolean;
        isMutable: boolean;
        masterEdition: boolean;
    };
};
declare function serializeRequest$1(request: GetNFTMetadataRequest, core: Core): {
    address: string;
    network: "mainnet" | "devnet";
};

type OperationId = 'getTokenPrice';
type PathParams = operations[OperationId]['parameters']['path'];
type SuccessResponse = operations[OperationId]['responses']['200']['content']['application/json'];
interface GetTokenPriceRequest extends Camelize<Omit<PathParams, 'network' | 'address'>> {
    network?: SolNetworkish;
    address: SolAddressish;
}
type GetTokenPriceJSONRequest = ReturnType<typeof serializeRequest>;
interface GetTokenPriceJSONResponse extends SuccessResponse {
}
type GetTokenPriceResponse = ReturnType<typeof deserializeResponse>;
interface GetTokenPriceResponseAdapter extends ResponseAdapter<GetTokenPriceResponse, GetTokenPriceJSONResponse> {
}
/** Gets the token price (usd and native) for a given contract address and network */
declare const getTokenPriceOperation: Operation<GetTokenPriceRequest, GetTokenPriceJSONRequest, GetTokenPriceResponse, GetTokenPriceJSONResponse>;
declare function deserializeResponse(jsonResponse: GetTokenPriceJSONResponse): SolSPLTokenPrice;
declare function serializeRequest(request: GetTokenPriceRequest, core: Core): {
    address: string;
    network: "mainnet" | "devnet";
};

declare const operationsV2: (_moralisweb3_common_core.Operation<GetBalanceRequest, {
    address: string;
    network: "mainnet" | "devnet";
}, SolNative, GetBalanceJSONResponse> | _moralisweb3_common_core.Operation<GetNFTsRequest, {
    address: string;
    network: "mainnet" | "devnet";
}, {
    associatedTokenAddress: SolAddress;
    mint: SolAddress;
    name: string;
    symbol: string;
}[], GetNFTsJSONResponse> | _moralisweb3_common_core.Operation<GetPortfolioRequest, {
    address: string;
    network: "mainnet" | "devnet";
}, {
    nativeBalance: SolNative;
    nfts: {
        associatedTokenAddress: SolAddress;
        mint: SolAddress;
        name: string;
        symbol: string;
    }[];
    tokens: {
        associatedTokenAddress: SolAddress;
        mint: SolAddress;
        amount: SolNative;
        name: string;
        symbol: string;
    }[];
}, GetPortfolioJSONResponse> | _moralisweb3_common_core.Operation<GetNFTMetadataRequest, {
    address: string;
    network: "mainnet" | "devnet";
}, {
    mint: SolAddress;
    standard: string;
    name: string;
    symbol: string;
    metaplex: {
        metadataUri: string;
        updateAuthority: SolAddress;
        sellerFeeBasisPoints: number;
        primarySaleHappened: boolean;
        isMutable: boolean;
        masterEdition: boolean;
    };
}, GetNFTMetadataJSONResponse>)[];
/**
 * @deprecated This list includes upgraded operations to the hybrid approach in the old format.
 */
declare const operationsV2All: (_moralisweb3_common_core.Operation<GetBalanceRequest, {
    address: string;
    network: "mainnet" | "devnet";
}, SolNative, GetBalanceJSONResponse> | _moralisweb3_common_core.Operation<GetNFTsRequest, {
    address: string;
    network: "mainnet" | "devnet";
}, {
    associatedTokenAddress: SolAddress;
    mint: SolAddress;
    name: string;
    symbol: string;
}[], GetNFTsJSONResponse> | _moralisweb3_common_core.Operation<GetPortfolioRequest, {
    address: string;
    network: "mainnet" | "devnet";
}, {
    nativeBalance: SolNative;
    nfts: {
        associatedTokenAddress: SolAddress;
        mint: SolAddress;
        name: string;
        symbol: string;
    }[];
    tokens: {
        associatedTokenAddress: SolAddress;
        mint: SolAddress;
        amount: SolNative;
        name: string;
        symbol: string;
    }[];
}, GetPortfolioJSONResponse> | _moralisweb3_common_core.Operation<GetNFTMetadataRequest, {
    address: string;
    network: "mainnet" | "devnet";
}, {
    mint: SolAddress;
    standard: string;
    name: string;
    symbol: string;
    metaplex: {
        metadataUri: string;
        updateAuthority: SolAddress;
        sellerFeeBasisPoints: number;
        primarySaleHappened: boolean;
        isMutable: boolean;
        masterEdition: boolean;
    };
}, GetNFTMetadataJSONResponse> | _moralisweb3_common_core.Operation<GetTokenPriceRequest, {
    address: string;
    network: "mainnet" | "devnet";
}, SolSPLTokenPrice, GetTokenPriceJSONResponse>)[];

declare class CommonSolUtilsConfigSetup {
    static register(config: Config): void;
}

declare const CommonSolUtilsConfig: {
    defaultSolNetwork: ConfigKey<SolNetworkInput>;
};

declare class SolNetworkResolver {
    static resolve(network: SolNetworkish | undefined, core: Core): SolNetworkName;
}

export { CommonSolUtils, CommonSolUtilsConfig, CommonSolUtilsConfigSetup, GetBalanceJSONRequest, GetBalanceJSONResponse, GetBalanceRequest, GetBalanceResponse, GetBalanceResponseAdapter, GetNFTMetadataJSONRequest, GetNFTMetadataJSONResponse, GetNFTMetadataRequest, GetNFTMetadataResponse, GetNFTMetadataResponseAdapter, GetNFTsJSONRequest, GetNFTsJSONResponse, GetNFTsRequest, GetNFTsResponse, GetNFTsResponseAdapter, GetPortfolioJSONRequest, GetPortfolioJSONResponse, GetPortfolioRequest, GetPortfolioResponse, GetPortfolioResponseAdapter, GetSPLJSONRequest, GetSPLJSONResponse, GetSPLRequest, GetSPLResponse, GetSPLResponseAdapter, GetTokenPriceJSONRequest, GetTokenPriceJSONResponse, GetTokenPriceOperation, GetTokenPriceOperationRequest, GetTokenPriceOperationRequestJSON, GetTokenPriceOperationResponse, GetTokenPriceOperationResponseJSON, GetTokenPriceRequest, GetTokenPriceResponse, GetTokenPriceResponseAdapter, SolAddress, SolAddressInput, SolAddressJSON, SolAddressish, SolGetTokenPriceNetworkEnum, SolGetTokenPriceNetworkEnumInput, SolGetTokenPriceNetworkEnumJSON, SolGetTokenPriceNetworkEnumValue, SolNative, SolNativeInput, SolNativeJSON, SolNativeUnit, SolNativeish, SolNetwork, SolNetworkInput, SolNetworkJSON, SolNetworkName, SolNetworkResolver, SolNetworkish, SolSPLNativePrice, SolSPLNativePriceInput, SolSPLNativePriceJSON, SolSPLTokenPrice, SolSPLTokenPriceInput, SolSPLTokenPriceJSON, getBalanceOperation, getNFTMetadataOperation, getNFTsOperation, getPortfolioOperation, getSPLOperation, getTokenPriceOperation, operations$1 as operations, operationsV2, operationsV2All };
