import * as _moralisweb3_common_core from '@moralisweb3/common-core';
import { EvmChainable, MoralisDataObject, BigNumberish, DateInput, BigNumber, MoralisData, MoralisDataObjectValue, BigNumberJSON, BigNumberInput, Module, Core, Camelize, ResponseAdapter, Operation, PaginatedResponseAdapter, PaginatedOperation, ConfigKey, Config } from '@moralisweb3/common-core';
import { Signature } from '@ethersproject/bytes';

type EvmChainListJSON = "eth" | "0x1" | "goerli" | "0x5" | "sepolia" | "0xaa36a7" | "polygon" | "0x89" | "mumbai" | "0x13881" | "bsc" | "0x38" | "bsc testnet" | "0x61" | "avalanche" | "0xa86a" | "fantom" | "0xfa" | "palm" | "0x2a15c308d" | "cronos" | "0x19" | "arbitrum" | "0xa4b1";
type EvmChainListInput = "eth" | "0x1" | "goerli" | "0x5" | "sepolia" | "0xaa36a7" | "polygon" | "0x89" | "mumbai" | "0x13881" | "bsc" | "0x38" | "bsc testnet" | "0x61" | "avalanche" | "0xa86a" | "fantom" | "0xfa" | "palm" | "0x2a15c308d" | "cronos" | "0x19" | "arbitrum" | "0xa4b1";
type EvmChainListValue = "eth" | "0x1" | "goerli" | "0x5" | "sepolia" | "0xaa36a7" | "polygon" | "0x89" | "mumbai" | "0x13881" | "bsc" | "0x38" | "bsc testnet" | "0x61" | "avalanche" | "0xa86a" | "fantom" | "0xfa" | "palm" | "0x2a15c308d" | "cronos" | "0x19" | "arbitrum" | "0xa4b1";
declare abstract class EvmChainList {
    static create(input: EvmChainListInput | EvmChainListValue): EvmChainListValue;
    static fromJSON(json: EvmChainListJSON): EvmChainListValue;
}

type EvmGetNFTTradesMarketplaceEnumJSON = "opensea";
type EvmGetNFTTradesMarketplaceEnumInput = "opensea";
type EvmGetNFTTradesMarketplaceEnumValue = "opensea";
declare abstract class EvmGetNFTTradesMarketplaceEnum {
    static create(input: EvmGetNFTTradesMarketplaceEnumInput | EvmGetNFTTradesMarketplaceEnumValue): EvmGetNFTTradesMarketplaceEnumValue;
    static fromJSON(json: EvmGetNFTTradesMarketplaceEnumJSON): EvmGetNFTTradesMarketplaceEnumValue;
}

type EvmContractsReviewItemReportTypeEnumJSON = "spam" | "not_spam";
type EvmContractsReviewItemReportTypeEnumInput = "spam" | "not_spam";
type EvmContractsReviewItemReportTypeEnumValue = "spam" | "not_spam";
declare abstract class EvmContractsReviewItemReportTypeEnum {
    static create(input: EvmContractsReviewItemReportTypeEnumInput | EvmContractsReviewItemReportTypeEnumValue): EvmContractsReviewItemReportTypeEnumValue;
    static fromJSON(json: EvmContractsReviewItemReportTypeEnumJSON): EvmContractsReviewItemReportTypeEnumValue;
}

type EvmContractsReviewItemContractTypeEnumJSON = "ERC20" | "NFT";
type EvmContractsReviewItemContractTypeEnumInput = "ERC20" | "NFT";
type EvmContractsReviewItemContractTypeEnumValue = "ERC20" | "NFT";
declare abstract class EvmContractsReviewItemContractTypeEnum {
    static create(input: EvmContractsReviewItemContractTypeEnumInput | EvmContractsReviewItemContractTypeEnumValue): EvmContractsReviewItemContractTypeEnumValue;
    static fromJSON(json: EvmContractsReviewItemContractTypeEnumJSON): EvmContractsReviewItemContractTypeEnumValue;
}

/**
 * This can be any valid EVM address, formatted as lowercase or checksum.
 * @example "0xfb6916095ca1df60bb79ce92ce3ea74c37c5d359"
 * @example "0xfB6916095ca1df60bB79Ce92cE3Ea74c37c5d359"
 */
type EvmAddressInput = EvmAddress | string;
type EvmAddressJSON = string;
/**
 * Valid input for a new EvmAddress instance.
 * This can be an existing EvmAddress or a valid address string as lowercase, or checksum format.
 */
type EvmAddressish = EvmAddressInput;
/**
 * A representation of an address on the EVM network.
 *
 * Use this class any time you work with an address, as it will provide utilities to validate the address,
 * and format it to lowercase and checksum format.
 *
 * @category DataType
 */
declare class EvmAddress {
    /**
     * @returns EvmAddress instance of the zero address: "0x0000000000000000000000000000000000000000"
     * @example `EvmAddress.ZERO_ADDRESS`
     */
    static get ZERO_ADDRESS(): EvmAddress;
    /**
     * Create a new instance of EvmAddress from any valid address input
     *
     * @example
     * ```
     * const address = EvmAddress.create("0xfb6916095ca1df60bb79ce92ce3ea74c37c5d359")
     * const address = EvmAddress.create("0xfB6916095ca1df60bB79Ce92cE3Ea74c37c5d359")
     * const address = EvmAddress.ZERO_ADDRESS
     * ```
     */
    static create(address: EvmAddressInput): EvmAddress;
    static fromJSON(address: string): EvmAddress;
    /**
     * Internal reference of the address in checksum format
     */
    private _value;
    private constructor();
    private static parse;
    /**
     * Check the equality between two Evm addresses
     * @example `EvmAddress.equals("0xfB6916095ca1df60bB79Ce92cE3Ea74c37c5d359", "0xfb6916095ca1df60bb79ce92ce3ea74c37c5d359")`
     */
    static equals(addressA: EvmAddressInput, addressB: EvmAddressInput): boolean;
    /**
     * Checks the equality of the current address with another evm address
     * @example `address.equals("0xfb6916095ca1df60bb79ce92ce3ea74c37c5d359")`
     */
    equals(address: EvmAddressInput): boolean;
    /**
     * @returns the address value in checksum (EIP-55) format (see https://eips.ethereum.org/EIPS/eip-55)
     * @example `address.checksum // "0xfB6916095ca1df60bB79Ce92cE3Ea74c37c5d359"`
     */
    get checksum(): string;
    /**
     * @returns the address value in lowercase format
     * @example `address.lowercase // "0xfb6916095ca1df60bb79ce92ce3ea74c37c5d359"`
     */
    get lowercase(): string;
    /**
     * Returns a JSON representation of the address.
     * @returns an address.
     */
    toJSON(): EvmAddressJSON;
}

/**
 * Moralis representation of a native chain currency.
 */
interface EvmNativeCurrency {
    name: string;
    symbol: string;
    decimals: number;
}
interface EvmChainListDataEntry {
    name: string;
    title?: string;
    chain: string;
    icon?: string;
    rpc: string[];
    faucets: string[];
    nativeCurrency: EvmNativeCurrency;
    infoURL: string;
    shortName: string;
    chainId: number;
    network?: string;
    networkId: number;
    slip44?: number;
    ens?: {
        registry: string;
    };
    explorers?: {
        name: string;
        url: string;
        standard: 'EIP3091' | 'none';
        icon?: string;
    }[];
    parent?: {
        type: 'L2' | 'shard';
        chain: 'eip155-3' | 'eip155-4' | 'eip155-5' | 'eip155-90' | 'eip155-100' | 'eip155-1' | 'eip155-100' | 'eip155-250' | 'eip155-248' | 'eip155-43114' | 'eip155-900' | 'eip155-43113' | 'eip155-100000' | 'eip155-110000' | 'eip155-2099156' | 'eip155-16658437';
        bridges?: {
            url: string;
        }[];
    };
    status?: 'deprecated' | 'incubating' | 'active';
    features?: EvmChainFeature[];
    redFlags?: string[];
}
interface EvmChainFeature {
    name: string;
}

/**
 * This can be an hex-string, ChainName or a number
 */
type InputChainId = string | number;
/**
 * This can be any valid {@link EvmChain} or {@link InputChainId}.
 */
type EvmChainish = EvmChain | InputChainId;

type EvmChainInput = string;
type EvmChainJSON = string;
/**
 * The EvmChain class is a MoralisData that references to a EVM chain
 * @category DataType
 */
declare class EvmChain implements EvmChainable {
    /**
     * Returns ETHEREUM chain
     *
     * @example EvmChain.ETHEREUM
     */
    static get ETHEREUM(): EvmChain;
    /**
     * Returns GOERLI chain
     *
     * @example EvmChain.GOERLI
     */
    static get GOERLI(): EvmChain;
    /**
     * Returns SEPOLIA chain
     *
     * @example EvmChain.SEPOLIA
     */
    static get SEPOLIA(): EvmChain;
    /**
     * Returns POLYGON chain
     *
     * @example EvmChain.POLYGON
     */
    static get POLYGON(): EvmChain;
    /**
     * Returns MUMBAI chain
     *
     * @example EvmChain.MUMBAI
     */
    static get MUMBAI(): EvmChain;
    /**
     * Returns BSC chain
     *
     * @example EvmChain.BSC
     */
    static get BSC(): EvmChain;
    /**
     * Returns BSC_TESTNET chain
     *
     * @example EvmChain.BSC_TESTNET
     */
    static get BSC_TESTNET(): EvmChain;
    /**
     * Returns AVALANCHE chain
     *
     * @example EvmChain.AVALANCHE
     */
    static get AVALANCHE(): EvmChain;
    /**
     * Returns AVALANCHE_TESTNET chain
     *
     * @example EvmChain.AVALANCHE_TESTNET
     */
    static get AVALANCHE_TESTNET(): EvmChain;
    /**
     * Returns FANTOM chain
     *
     * @example EvmChain.FANTOM
     */
    static get FANTOM(): EvmChain;
    /**
     * Returns FANTOM_TESTNET chain
     *
     * @example EvmChain.FANTOM_TESTNET
     */
    static get FANTOM_TESTNET(): EvmChain;
    /**
     * Returns CRONOS chain
     *
     * @example EvmChain.CRONOS
     */
    static get CRONOS(): EvmChain;
    /**
     * Returns PALM chain
     *
     * @example EvmChain.PALM
     */
    static get PALM(): EvmChain;
    /**
     * Returns ARBITRUM chain
     *
     * @example EvmChain.ARBITRUM
     */
    static get ARBITRUM(): EvmChain;
    /**
     * Returns ARBITRUM_TESTNET chain
     *
     * @example EvmChain.ARBITRUM_TESTNET
     */
    static get ARBITRUM_TESTNET(): EvmChain;
    /**
     * Returns RONIN chain
     *
     * @example EvmChain.RONIN
     */
    static get RONIN(): EvmChain;
    /**
     * Returns OPTIMISM chain
     *
     * @example EvmChain.OPTIMISM
     */
    static get OPTIMISM(): EvmChain;
    /**
     * Create a new instance of EvmChain from any valid address input.
     *
     * @example
     * ```ts
     * const chain = EvmChain.create(1)
     * const chain = EvmChain.create("0x3")
     * ```
     */
    static create(chain: EvmChainish): EvmChain;
    private _value;
    private _chainlistData;
    private constructor();
    private _getChainlistData;
    /**
     * Compares if 2 chains are equal, based on the chainId
     *
     * @param chainA - The first chain to compare
     * @param chainB - The second chain to compare
     *
     * @returns true if the chains are equal, false otherwise
     * @example
     * ```ts
     * EvmChain.equals("1", "0x1")
     * ```
     */
    static equals(chainA: EvmChainish, chainB: EvmChainish): boolean;
    /**
     * @returns all the available chains
     */
    static values(): EvmChain[];
    /**
     * Compares if the current chain is equal to the provided chain, based on the chainId
     * @param chain - The chain to compare to
     * @returns true if the chains are equal, false otherwise
     * @example
     * ```ts
     * chain.equals(EvmChain.ETHEREUM)
     * ```
     */
    equals(chain: EvmChainish): boolean;
    /**
     * Displays the chain hex-string representation of the chain and also the chain name if not null
     *
     * @example chain.display() // "Ethereum (0x1)" | "0x1"
     */
    display(): string;
    /**
     * This function returns the explorer url of a block, transaction, account or token.
     *
     * @param value - An object containing the `block`, `transaction`, `account` or `erc20` to get the explorer url for.
     *
     * @example chain.getExplorerUrl({ block: 'block_here' }) // "https://etherscan.io/block/block_here"
     * @example chain.getExplorerUrl({ transaction: 'some_transaction' }) // "https://etherscan.io/tx/some_transaction"
     * @example chain.getExplorerUrl({ account: 'accoun_here' }) // "https://etherscan.io/address/accoun_here"
     * @example chain.getExplorerUrl({ erc20: 'token_here' }) // "https://etherscan.io/token/token_here"
     */
    getExplorerPath(value: {
        block: string;
    } | {
        transaction: string;
    } | {
        account: string;
    } | {
        erc20: string;
    }): string | null;
    /**
     * Returns the decimal representation of the chain
     * @example chain.decimal // 1
     */
    get decimal(): number;
    /**
     * Returns the hex-string representation of the chain
     * @example chain.hex // "0x1"
     */
    get hex(): string;
    /**
     * Validate and cast to api compatible hex
     *
     * @example chain.apiHex // "0x1"
     */
    get apiHex(): "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    /**
     * Returns the name of the chain
     * @example chain.name // "Ethereum"
     */
    get name(): string | undefined;
    /**
     * Returns the currency of the chain
     * @returns The cuurrency of the chain or undefined if not found
     *
     * @example chain.currency // EvmNativeCurrency
     */
    get currency(): EvmNativeCurrency | undefined;
    /**
     * Returns the rpc Urls of the chain
     *
     * @example chain.rpcUrls // ["https://mainnet.infura.io/v3/<infura-key>"]
     */
    get rpcUrls(): string[] | undefined;
    /**
     * Returns the explorer Urls of the chain
     *
     * @example chain.explorerUrls // ["https://etherscan.io/"]
     */
    get explorer(): {
        name: string;
        url: string;
        standard: "EIP3091" | "none";
        icon?: string | undefined;
    } | null;
    /**
     * Returns the chain as a string.
     * @returns The chain.
     */
    toJSON(): EvmChainJSON;
}

declare class EvmChainParser {
    static parse(chain: InputChainId): string;
}

/**
 * Valid ERC20 token input
 *
 * @example
 * ```ts
 * const input = {
 * contractAddress: "0x0a385f86059e0b2a048171d78afd1f38558121f3",
 * name: "USD Coin on BSC",
 * symbol: "USDC",
 * logo: null,
 * logoHash: null,
 * thumbnail: null,
 * decimals: "6",
 * chain: 1,
 * possibleSpam: false,
 * }
 * ```
 */
interface Erc20Input {
    decimals: number | string;
    name: string;
    symbol: string;
    contractAddress: EvmAddressish;
    chain: EvmChainish;
    logo?: string | null;
    logoHash?: string | null;
    thumbnail?: string | null;
    possibleSpam?: boolean;
}
/**
 * This is the return type of the processed ERC20 token
 */
interface Erc20Data {
    decimals: number;
    name: string;
    symbol: string;
    contractAddress: EvmAddress;
    chain: EvmChain;
    logo?: string | null;
    logoHash?: string | null;
    thumbnail?: string | null;
    possibleSpam?: boolean;
}

/**
 * This can be any valid {@link Erc20Input} or {@link Erc20Token}.
 */
type Erc20Tokenish = Erc20Input | Erc20Token;
/**
 * The Erc20Token class is a MoralisData that references to a Erc20 Token
 * It holds data about the data and metadata of an Erc20 token
 *
 * @category DataType
 */
declare class Erc20Token implements MoralisDataObject {
    /**
     *  Create a new instance of Erc20Token from any valid Erc20Token input
     *
     * @param value - the Erc20Tokenish type
     * @example
     * ```ts
     * const token = Erc20Token.create(value);
     * ```
     */
    static create(value: Erc20Tokenish): Erc20Token;
    private readonly _value;
    private constructor();
    static parse: (value: Erc20Input) => Erc20Data;
    /**
     * Compares two Erc20Token instances. This checks if the chain and contractAddress of both tokens are equal.
     *
     * @param valueA - the first Erc20Token to compare
     * @param valueB - the second Erc20Token to compare
     * @returns true if the two Erc20Tokens are equal
     * @example
     * ```ts
     * Erc20Token.equals(valueA, valueB);
     * ```
     */
    static equals(valueA: Erc20Tokenish, valueB: Erc20Tokenish): boolean;
    /**
     * Compares Erc20Token instance to current instance
     *
     * @param value - the Erc20Tokenish to compare
     * @returns true if the Erc20Token is equals given token
     * @example
     * ```ts
     * token.equals(value);
     * ```
     */
    equals(value: Erc20Tokenish): boolean;
    /**
     * Returns the token as JSON
     *
     * @returns the Erc20Token as a JSON object
     * @example
     * ```ts
     * token.toJSON();
     * ```
     */
    toJSON(): {
        contractAddress: string;
        chain: string;
        decimals: number;
        name: string;
        symbol: string;
        logo?: string | null | undefined;
        logoHash?: string | null | undefined;
        thumbnail?: string | null | undefined;
        possibleSpam?: boolean | undefined;
    };
    /**
     * @deprecated This method will be removed soon. To format the value, use one of the properties.
     */
    format(): {
        contractAddress: string;
        chain: string;
        decimals: number;
        name: string;
        symbol: string;
        logo?: string | null | undefined;
        logoHash?: string | null | undefined;
        thumbnail?: string | null | undefined;
        possibleSpam?: boolean | undefined;
    };
    /**
     * Returns the processed Erc20Token.
     *
     * @returns the Erc20Token value
     * @example
     * ```ts
     * token.result;
     *  ```
     */
    get result(): Erc20Data;
    /**
     * @returns the decimals of the token.
     *
     * @example
     * ```ts
     * token.decimals;
     * ```
     */
    get decimals(): number;
    /**
     * @returns The name of the token.
     *
     * @example
     * ```ts
     * token.name;
     * ```
     */
    get name(): string;
    /**
     * @returns The symbol of the token.
     *
     * @example
     * ```ts
     * token.symbol;
     * ```
     */
    get symbol(): string;
    /**
     * @returns The contract address of the token.
     *
     * @example
     * ```ts
     * token.contractAddress;
     * ```
     */
    get contractAddress(): EvmAddress;
    /**
     * @returns The chain of the token.
     *
     * @example
     * ```ts
     * token.chain;
     * ```
     */
    get chain(): EvmChain;
    /**
     * @returns The logo of the token.
     *
     * @example
     * ```ts
     * token.logo;
     * ```
     */
    get logo(): string | null | undefined;
    /**
     * @returns The logo hash of the token.
     *
     * @example
     * ```ts
     * token.logoHash;
     * ```
     */
    get logoHash(): string | null | undefined;
    /**
     * @returns The thumbnail of the token.
     *
     * @example
     * ```ts
     * token.thumbnail;
     * ```
     */
    get thumbnail(): string | null | undefined;
    /**
     * @returns possibility of the token being a spam token
     * @example transfer.possibleSpam // true
     */
    get possibleSpam(): boolean | undefined;
}

/**
 * This can be any object with valid erc20 approval data.
 * @example
 * ```
 * const input = {
 *   chain: 1,
 *   toWallet: "0x09f4fc6081026c85070886599e83f599ecf82405",
 *   contractAddress: "0xa0e8fed3426391fdb446516799c4d6248e2b2860",
 *   blockHash: "0xa5f87d4341642b89e3ccb81449e3083032c36fface2c2042941b8bd9afe83f79",
 *   blockNumber: "16868690",
 *   blockTimestamp: "2023-03-20T11:48:59.000Z",
 *   transactionHash: "0xb7b4d321e2ab26c1cde1a2ef49413e21b65dcc663d6de8f75ddbdd868b98b4bf",
 *   transactionIndex: "4",
 *   logIndex: "25",
 *   possibleSpam: false,
 *   value: "100000000000000000000000000000",
 *   tokenName: 'Test Token',
 *   tokenSymbol: 'TST',
 *   tokenLogo: 'https://example.com/logo.png',
 *   tokenDecimals: 18
 * }
 * ```
 */
interface Erc20ApprovalInput {
    chain: EvmChainish;
    fromWallet: EvmAddressish;
    toWallet: EvmAddressish;
    contractAddress: EvmAddressish;
    blockHash: string;
    blockNumber: BigNumberish;
    blockTimestamp: DateInput;
    transactionHash: string;
    transactionIndex: number;
    logIndex: number;
    value: BigNumberish;
    possibleSpam: boolean;
    tokenName: string;
    tokenSymbol: string;
    tokenLogo?: string;
    tokenDecimals: number;
}
/**
 * This is the return type of Erc20Approval
 */
interface Erc20ApprovalData {
    chain: EvmChain;
    fromWallet: EvmAddress;
    toWallet: EvmAddress;
    contractAddress: EvmAddress;
    blockHash: string;
    blockNumber: BigNumber;
    blockTimestamp: Date;
    transactionHash: string;
    transactionIndex: number;
    logIndex: number;
    value: BigNumber;
    possibleSpam: boolean;
    tokenName: string;
    tokenSymbol: string;
    tokenLogo?: string;
    tokenDecimals: number;
}

/**
 * The Erc20Approval is a representation of an Erc20 token approval.
 *
 * @category DataType
 */
declare class Erc20Approval implements MoralisDataObject {
    /**
     * Create a new instance of Erc20Approval from any valid input
     * @param data -  Erc20Approval instance or valid Erc20ApprovalInput
     * @example
     * ```
     * const approval = Erc20Approval.create(data);
     *```
     */
    static create(data: Erc20Approval | Erc20ApprovalInput): Erc20Approval;
    private _data;
    constructor(data: Erc20ApprovalInput);
    static parse: (data: Erc20ApprovalInput) => Erc20ApprovalData;
    /**
     * Check the equality between two Erc20 approvals
     * @param dataA - The first approval to compare
     * @param dataB - The second approval to compare
     * @example Erc20Approval.equals(dataA, dataB)
     * @returns true if the approvals are equal, false otherwise
     */
    static equals(dataA: Erc20Approval | Erc20ApprovalInput, dataB: Erc20Approval | Erc20ApprovalInput): boolean;
    /**
     * Checks the equality of the current approval with another erc20 approval
     * @param data - the approval to compare with
     * @example approval.equals(data)
     * @returns true if the approvals are equal, false otherwise
     */
    equals(data: Erc20Approval | Erc20ApprovalInput): boolean;
    /**
     * @returns a JSON representation of the approval.
     * @example approval.toJSON()
     */
    toJSON(): {
        chain: string;
        contractAddress: string;
        blockNumber: string;
        toWallet: string;
        fromWallet: string;
        value: string;
        blockHash: string;
        blockTimestamp: Date;
        transactionHash: string;
        transactionIndex: number;
        logIndex: number;
        possibleSpam: boolean;
        tokenName: string;
        tokenSymbol: string;
        tokenLogo?: string | undefined;
        tokenDecimals: number;
    };
    /**
     * @deprecated This method will be removed soon. To format the value, use one of the properties.
     */
    format(): {
        chain: string;
        contractAddress: string;
        blockNumber: string;
        toWallet: string;
        fromWallet: string;
        value: string;
        blockHash: string;
        blockTimestamp: Date;
        transactionHash: string;
        transactionIndex: number;
        logIndex: number;
        possibleSpam: boolean;
        tokenName: string;
        tokenSymbol: string;
        tokenLogo?: string | undefined;
        tokenDecimals: number;
    };
    /**
     * @returns all the data without casting it to JSON.
     * @example approval.result
     */
    get result(): Erc20ApprovalData;
    /**
     * @returns the toWallet of the approval
     * @example approval.toWallet // EvmAddress
     */
    get toWallet(): EvmAddress;
    /**
     * @returns the fromWallet of the approval
     * @example approval.fromWallet // EvmAddress
     */
    get fromWallet(): EvmAddress;
    /**
     * @returns the contractAddress of the approval
     * @example approval.contractAddress // EvmAddress
     */
    get contractAddress(): EvmAddress;
    /**
     * @returns the block hash of the approval
     * @example approval.blockHash // "0x0372c302e3c52e8f2e15d155e2c545e6d802e479236564af052759253b20fd86"
     */
    get blockHash(): string;
    /**
     * @returns the block number of the approval
     * @example approval.blockNumber // BigNumber
     */
    get blockNumber(): BigNumber;
    /**
     * @returns the block timestamp of the approval
     * @example approval.blockTimestamp // Date
     */
    get blockTimestamp(): Date;
    /**
     * @returns the chain of the approval
     * @example approval.chain // EvmChain
     */
    get chain(): EvmChain;
    /**
     * @returns the transaction hash of the approval
     * @example approval.transactionHash // "0x0372c302e3c52e8f2e15d155e2c545e6d802e479236564af052759253b20fd86"
     */
    get transactionHash(): string;
    /**
     * @returns the value of the approval
     * @example approval.value // BigNumber
     */
    get value(): BigNumber;
    /**
     * @returns the transactionIndex of the approval
     * @example approval.transactionIndex // 3
     */
    get transactionIndex(): number;
    /**
     * @returns the logIndex of the approval
     * @example approval.logIndex // 2
     */
    get logIndex(): number;
    /**
     * @returns possibility of the token being a spam token
     * @example transfer.possibleSpam // true
     */
    get possibleSpam(): boolean;
    /**
     * @returns The name of the token.
     * @example burn.tokenName // "Kylin Network"
     */
    get tokenName(): string;
    /**
     * @returns The logo of the token
     * @example burn.tokenLogo // "https://cdn.moralis.io/eth/0x67b6d479c7bb412c54e03dca8e1bc6740ce6b99c.png"
     */
    get tokenLogo(): string | undefined;
    /**
     * @returns The symbol of the token.
     * @example burn.tokenSymbol // "KYL"
     */
    get tokenSymbol(): string;
    /**
     * @returns The decimals of the token.
     * @example burn.tokenDecimals // 18
     */
    get tokenDecimals(): number;
}

/**
 * This can be any object with valid erc20 mint data.
 * @example
 * ```
 * const input = {
 *   chain: 1,
 *   fromWallet: "0x09f4fc6081026c85070886599e83f599ecf82405",
 *   contractAddress: "0xa0e8fed3426391fdb446516799c4d6248e2b2860",
 *   blockHash: "0xa5f87d4341642b89e3ccb81449e3083032c36fface2c2042941b8bd9afe83f79",
 *   blockNumber: "16868690",
 *   blockTimestamp: "2023-03-20T11:48:59.000Z",
 *   transactionHash: "0xb7b4d321e2ab26c1cde1a2ef49413e21b65dcc663d6de8f75ddbdd868b98b4bf",
 *   transactionIndex: "4",
 *   logIndex: "25",
 *   value: "100000000000000000000000000000",
 *   tokenName: 'Test Token',
 *   tokenSymbol: 'TST',
 *   tokenLogo: 'https://example.com/logo.png',
 *   tokenDecimals: 18
 * }
 * ```
 */
interface Erc20BurnInput {
    chain: EvmChainish;
    fromWallet: EvmAddressish;
    contractAddress: EvmAddressish;
    blockHash: string;
    blockNumber: BigNumberish;
    blockTimestamp: DateInput;
    transactionHash: string;
    transactionIndex: number;
    logIndex: number;
    value: BigNumberish;
    tokenName: string;
    tokenSymbol: string;
    tokenLogo?: string;
    tokenDecimals: number;
}
/**
 * This is the return type of Erc20Mint
 */
interface Erc20BurnData {
    chain: EvmChain;
    fromWallet: EvmAddress;
    contractAddress: EvmAddress;
    blockHash: string;
    blockNumber: BigNumber;
    blockTimestamp: Date;
    transactionHash: string;
    transactionIndex: number;
    logIndex: number;
    value: BigNumber;
    tokenName: string;
    tokenSymbol: string;
    tokenLogo?: string;
    tokenDecimals: number;
}

/**
 * The Erc20Burn is a representation of an Erc20 token burn.
 *
 * @category DataType
 */
declare class Erc20Burn implements MoralisDataObject {
    /**
     * Create a new instance of Erc20Burn from any valid input
     * @param data -  Erc20Burn instance or valid Erc20BurnInput
     * @example
     * ```
     * const burn = Erc20Burn.create(data);
     *```
     */
    static create(data: Erc20Burn | Erc20BurnInput): Erc20Burn;
    private _data;
    constructor(data: Erc20BurnInput);
    static parse: (data: Erc20BurnInput) => Erc20BurnData;
    /**
     * Check the equality between two Erc20 burns
     * @param dataA - The first burn to compare
     * @param dataB - The second burn to compare
     * @example Erc20Burn.equals(dataA, dataB)
     * @returns true if the burns are equal, false otherwise
     */
    static equals(dataA: Erc20Burn | Erc20BurnInput, dataB: Erc20Burn | Erc20BurnInput): boolean;
    /**
     * Checks the equality of the current burn with another erc20 burn
     * @param data - the burn to compare with
     * @example burn.equals(data)
     * @returns true if the burns are equal, false otherwise
     */
    equals(data: Erc20Burn | Erc20BurnInput): boolean;
    /**
     * @returns a JSON representation of the burn.
     * @example burn.toJSON()
     */
    toJSON(): {
        chain: string;
        contractAddress: string;
        blockNumber: string;
        fromWallet: string;
        value: string;
        blockHash: string;
        blockTimestamp: Date;
        transactionHash: string;
        transactionIndex: number;
        logIndex: number;
        tokenName: string;
        tokenSymbol: string;
        tokenLogo?: string | undefined;
        tokenDecimals: number;
    };
    /**
     * @deprecated This method will be removed soon. To format the value, use one of the properties.
     */
    format(): {
        chain: string;
        contractAddress: string;
        blockNumber: string;
        fromWallet: string;
        value: string;
        blockHash: string;
        blockTimestamp: Date;
        transactionHash: string;
        transactionIndex: number;
        logIndex: number;
        tokenName: string;
        tokenSymbol: string;
        tokenLogo?: string | undefined;
        tokenDecimals: number;
    };
    /**
     * @returns all the data without casting it to JSON.
     * @example burn.result
     */
    get result(): Erc20BurnData;
    /**
     * @returns the fromWallet of the burn
     * @example burn.fromWallet // EvmAddress
     */
    get fromWallet(): EvmAddress;
    /**
     * @returns the contractAddress of the burn
     * @example burn.contractAddress // EvmAddress
     */
    get contractAddress(): EvmAddress;
    /**
     * @returns the block hash of the burn
     * @example burn.blockHash // "0x0372c302e3c52e8f2e15d155e2c545e6d802e479236564af052759253b20fd86"
     */
    get blockHash(): string;
    /**
     * @returns the block number of the burn
     * @example burn.blockNumber // BigNumber
     */
    get blockNumber(): BigNumber;
    /**
     * @returns the block timestamp of the burn
     * @example burn.blockTimestamp // Date
     */
    get blockTimestamp(): Date;
    /**
     * @returns the chain of the burn
     * @example burn.chain // EvmChain
     */
    get chain(): EvmChain;
    /**
     * @returns the transaction hash of the burn
     * @example burn.transactionHash // "0x0372c302e3c52e8f2e15d155e2c545e6d802e479236564af052759253b20fd86"
     */
    get transactionHash(): string;
    /**
     * @returns the value of the burn
     * @example burn.value // BigNumber
     */
    get value(): BigNumber;
    /**
     * @returns the transactionIndex of the burn
     * @example burn.transactionIndex // 3
     */
    get transactionIndex(): number;
    /**
     * @returns the logIndex of the burn
     * @example burn.logIndex // 2
     */
    get logIndex(): number;
    /**
     * @returns The name of the token.
     * @example burn.tokenName // "Kylin Network"
     */
    get tokenName(): string;
    /**
     * @returns The logo of the token
     * @example burn.tokenLogo // "https://cdn.moralis.io/eth/0x67b6d479c7bb412c54e03dca8e1bc6740ce6b99c.png"
     */
    get tokenLogo(): string | undefined;
    /**
     * @returns The symbol of the token.
     * @example burn.tokenSymbol // "KYL"
     */
    get tokenSymbol(): string;
    /**
     * @returns The decimals of the token.
     * @example burn.tokenDecimals // 18
     */
    get tokenDecimals(): number;
}

/**
 * This can be any object with valid erc20 mint data.
 * @example
 * ```
 * const input = {
 *   chain: 1,
 *   toWallet: "0x09f4fc6081026c85070886599e83f599ecf82405",
 *   contractAddress: "0xa0e8fed3426391fdb446516799c4d6248e2b2860",
 *   blockHash: "0xa5f87d4341642b89e3ccb81449e3083032c36fface2c2042941b8bd9afe83f79",
 *   blockNumber: "16868690",
 *   blockTimestamp: "2023-03-20T11:48:59.000Z",
 *   transactionHash: "0xb7b4d321e2ab26c1cde1a2ef49413e21b65dcc663d6de8f75ddbdd868b98b4bf",
 *   transactionIndex: "4",
 *   logIndex: "25",
 *   value: "100000000000000000000000000000",
 *   tokenName: 'Test Token',
 *   tokenSymbol: 'TST',
 *   tokenLogo: 'https://example.com/logo.png',
 *   tokenDecimals: 18
 * }
 * ```
 */
interface Erc20MintInput {
    chain: EvmChainish;
    toWallet: EvmAddressish;
    contractAddress: EvmAddressish;
    blockHash: string;
    blockNumber: BigNumberish;
    blockTimestamp: DateInput;
    transactionHash: string;
    transactionIndex: number;
    logIndex: number;
    value: BigNumberish;
    tokenName: string;
    tokenSymbol: string;
    tokenLogo?: string;
    tokenDecimals: number;
}
/**
 * This is the return type of Erc20Mint
 */
interface Erc20MintData {
    chain: EvmChain;
    toWallet: EvmAddress;
    contractAddress: EvmAddress;
    blockHash: string;
    blockNumber: BigNumber;
    blockTimestamp: Date;
    transactionHash: string;
    transactionIndex: number;
    logIndex: number;
    value: BigNumber;
    tokenName: string;
    tokenSymbol: string;
    tokenLogo?: string;
    tokenDecimals: number;
}

/**
 * The Erc20Mint is a representation of an Erc20 token mint.
 *
 * @category DataType
 */
declare class Erc20Mint implements MoralisDataObject {
    /**
     * Create a new instance of Erc20Mint from any valid input
     * @param data -  Erc20Mint instance or valid Erc20MintInput
     * @example
     * ```
     * const mint = Erc20Mint.create(data);
     *```
     */
    static create(data: Erc20Mint | Erc20MintInput): Erc20Mint;
    private _data;
    constructor(data: Erc20MintInput);
    static parse: (data: Erc20MintInput) => Erc20MintData;
    /**
     * Check the equality between two Erc20 mints
     * @param dataA - The first mint to compare
     * @param dataB - The second mint to compare
     * @example Erc20Mint.equals(dataA, dataB)
     * @returns true if the mints are equal, false otherwise
     */
    static equals(dataA: Erc20Mint | Erc20MintInput, dataB: Erc20Mint | Erc20MintInput): boolean;
    /**
     * Checks the equality of the current mint with another erc20 mint
     * @param data - the mint to compare with
     * @example mint.equals(data)
     * @returns true if the mints are equal, false otherwise
     */
    equals(data: Erc20Mint | Erc20MintInput): boolean;
    /**
     * @returns a JSON representation of the mint.
     * @example mint.toJSON()
     */
    toJSON(): {
        chain: string;
        contractAddress: string;
        blockNumber: string;
        toWallet: string;
        value: string;
        blockHash: string;
        blockTimestamp: Date;
        transactionHash: string;
        transactionIndex: number;
        logIndex: number;
        tokenName: string;
        tokenSymbol: string;
        tokenLogo?: string | undefined;
        tokenDecimals: number;
    };
    /**
     * @deprecated This method will be removed soon. To format the value, use one of the properties.
     */
    format(): {
        chain: string;
        contractAddress: string;
        blockNumber: string;
        toWallet: string;
        value: string;
        blockHash: string;
        blockTimestamp: Date;
        transactionHash: string;
        transactionIndex: number;
        logIndex: number;
        tokenName: string;
        tokenSymbol: string;
        tokenLogo?: string | undefined;
        tokenDecimals: number;
    };
    /**
     * @returns all the data without casting it to JSON.
     * @example mint.result
     */
    get result(): Erc20MintData;
    /**
     * @returns the toWallet of the mint
     * @example mint.toWallet // EvmAddress
     */
    get toWallet(): EvmAddress;
    /**
     * @returns the contractAddress of the mint
     * @example mint.contractAddress // EvmAddress
     */
    get contractAddress(): EvmAddress;
    /**
     * @returns the block hash of the mint
     * @example mint.blockHash // "0x0372c302e3c52e8f2e15d155e2c545e6d802e479236564af052759253b20fd86"
     */
    get blockHash(): string;
    /**
     * @returns the block number of the mint
     * @example mint.blockNumber // BigNumber
     */
    get blockNumber(): BigNumber;
    /**
     * @returns the block timestamp of the mint
     * @example mint.blockTimestamp // Date
     */
    get blockTimestamp(): Date;
    /**
     * @returns the chain of the mint
     * @example mint.chain // EvmChain
     */
    get chain(): EvmChain;
    /**
     * @returns the transaction hash of the mint
     * @example mint.transactionHash // "0x0372c302e3c52e8f2e15d155e2c545e6d802e479236564af052759253b20fd86"
     */
    get transactionHash(): string;
    /**
     * @returns the value of the mint
     * @example mint.value // BigNumber
     */
    get value(): BigNumber;
    /**
     * @returns the transactionIndex of the mint
     * @example mint.transactionIndex // 3
     */
    get transactionIndex(): number;
    /**
     * @returns the logIndex of the mint
     * @example mint.logIndex // 2
     */
    get logIndex(): number;
    /**
     * @returns The name of the token.
     * @example burn.tokenName // "Kylin Network"
     */
    get tokenName(): string;
    /**
     * @returns The logo of the token
     * @example burn.tokenLogo // "https://cdn.moralis.io/eth/0x67b6d479c7bb412c54e03dca8e1bc6740ce6b99c.png"
     */
    get tokenLogo(): string | undefined;
    /**
     * @returns The symbol of the token.
     * @example burn.tokenSymbol // "KYL"
     */
    get tokenSymbol(): string;
    /**
     * @returns The decimals of the token.
     * @example burn.tokenDecimals // 18
     */
    get tokenDecimals(): number;
}

/**
 * This can be any object with valid erc20 transfer data.
 * @example
 * ```
 * const input = {
 *  chain: 1,
 *  address: "0x057Ec652A4F150f7FF94f089A38008f49a0DF88e",
 *  toAddress: "0x62AED87d21Ad0F3cdE4D147Fdcc9245401Af0044",
 *  fromAddress: "0xd4a3BebD824189481FC45363602b83C9c7e9cbDf",
 *  value: "650000000000000000",
 *  blockTimestamp: "2021-04-02T10:07:54.000Z",
 *  blockHash: "0x0372c302e3c52e8f2e15d155e2c545e6d802e479236564af052759253b20fd86",
 *  blockNumber: "12526958",
 *  transactionHash: "0x2d30ca6f024dbc1307ac8a1a44ca27de6f797ec22ef20627a1307243b0ab7d09",
 *  transactionIndex: 3,
 *  possibleSpam: false,
 *  logIndex: 2
 * }
 * ```
 */
interface Erc20TransactionInput {
    chain: EvmChainish;
    transactionHash: string;
    address: EvmAddressish;
    blockTimestamp: DateInput;
    blockNumber: BigNumberish;
    blockHash: string;
    toAddress: EvmAddressish;
    fromAddress: EvmAddressish;
    value: BigNumberish;
    transactionIndex: number;
    logIndex: number;
    possibleSpam: boolean;
}
/**
 * This is the return type of Erc20Transfer
 */
interface Erc20TransactionData {
    chain: EvmChain;
    transactionHash: string;
    address: EvmAddress;
    blockTimestamp: Date;
    blockNumber: BigNumber;
    blockHash: string;
    toAddress: EvmAddress;
    fromAddress: EvmAddress;
    value: BigNumber;
    transactionIndex: number;
    logIndex: number;
    possibleSpam: boolean;
}

/**
 * @deprecated Use {@link Erc20Transaction} instead.
 */
type Erc20Transfer = Erc20Transaction;
/**
 * @deprecated Use {@link Erc20Transactionish} instead.
 */
type Erc20Transferish = Erc20Transactionish;
/**
 * @deprecated Use {@link Erc20TransactionInput} instead.
 */
type Erc20TransferInput = Erc20TransactionInput;
/**
 * Valid input for a new Erc20Transaction instance.
 * This can be an existing {@link Erc20Transaction} or a valid {@link Erc20TransactionInput} object
 */
type Erc20Transactionish = Erc20TransactionInput | Erc20Transaction;
/**
 * The Erc20Transaction is a representation of an Erc20 token transaction.
 *
 * @category DataType
 */
declare class Erc20Transaction implements MoralisDataObject {
    /**
     * Create a new instance of Erc20Transaction from any valid input
     * @param data - the Erc20Transactionish type
     * @example
     * ```
     * const transfer = Erc20Transaction.create(data);
     *```
     */
    static create(data: Erc20Transactionish): Erc20Transaction;
    private _data;
    constructor(data: Erc20TransactionInput);
    static parse: (data: Erc20TransactionInput) => Erc20TransactionData;
    /**
     * Check the equality between two Erc20 transfers
     * @param dataA - The first transfer to compare
     * @param dataB - The second transfer to compare
     * @example Erc20Transaction.equals(dataA, dataB)
     * @returns true if the transfers are equal, false otherwise
     */
    static equals(dataA: Erc20Transactionish, dataB: Erc20Transactionish): boolean;
    /**
     * Checks the equality of the current trnasfer with another erc20 trnasfer
     * @param data - the transfer to compare with
     * @example transfer.equals(data)
     * @returns true if the transfers are equal, false otherwise
     */
    equals(data: Erc20Transactionish): boolean;
    /**
     * @returns a JSON represention of the transfer.
     * @example transfer.toJSON()
     */
    toJSON(): {
        chain: string;
        address: string;
        blockNumber: string;
        toAddress: string;
        fromAddress: string;
        value: string;
        transactionHash: string;
        blockTimestamp: Date;
        blockHash: string;
        transactionIndex: number;
        logIndex: number;
        possibleSpam: boolean;
    };
    /**
     * @deprecated This method will be removed soon. To format the value, use one of the properties.
     */
    format(): {
        chain: string;
        address: string;
        blockNumber: string;
        toAddress: string;
        fromAddress: string;
        value: string;
        transactionHash: string;
        blockTimestamp: Date;
        blockHash: string;
        transactionIndex: number;
        logIndex: number;
        possibleSpam: boolean;
    };
    /**
     * @returns all the data without casting it to JSON.
     * @example transfer.result
     */
    get result(): Erc20TransactionData;
    /**
     * @returns the contract address of the transfer
     * @example transfer.address // EvmAddress
     */
    get address(): EvmAddress;
    /**
     * @returns the contract address of the transfer
     * @example transfer.contractAddress // EvmAddress
     */
    get contractAddress(): EvmAddress;
    /**
     * @returns the block hash of the transfer
     * @example transfer.blockHash // "0x0372c302e3c52e8f2e15d155e2c545e6d802e479236564af052759253b20fd86"
     */
    get blockHash(): string;
    /**
     * @returns the block number of the transfer
     * @example transfer.blockNumber // BigNumber
     */
    get blockNumber(): BigNumber;
    /**
     * @returns the block timestamp of the transfer
     * @example transfer.blockTimestamp // Date
     */
    get blockTimestamp(): Date;
    /**
     * @returns the chain of the transfer
     * @example transfer.chain // EvmChain
     */
    get chain(): EvmChain;
    /**
     * @returns the from address of the transfer
     * @example transfer.fromAddress // EvmAddress
     */
    get fromAddress(): EvmAddress;
    /**
     * @returns the from address of the transfer
     * @example transfer.fromWallet // EvmAddress
     */
    get fromWallet(): EvmAddress;
    /**
     * @returns the to address of the transfer
     * @example transfer.toAddress // EvmAddress
     */
    get toAddress(): EvmAddress;
    /**
     * @returns the to address of the transfer
     * @example transfer.toWallet // EvmAddress
     */
    get toWallet(): EvmAddress;
    /**
     * @returns the transaction hash of the transfer
     * @example transfer.transactionHash // "0x0372c302e3c52e8f2e15d155e2c545e6d802e479236564af052759253b20fd86"
     */
    get transactionHash(): string;
    /**
     * @returns the value of the transfer
     * @example transfer.value // BigNumber
     */
    get value(): BigNumber;
    /**
     * @returns the transactionIndex of the transfer
     * @example transfer.transactionIndex // 3
     */
    get transactionIndex(): number;
    /**
     * @returns the logIndex of the transfer
     * @example transfer.logIndex // 2
     */
    get logIndex(): number;
    /**
     * @returns possibility of the token being a spam token
     * @example transfer.possibleSpam // true
     */
    get possibleSpam(): boolean;
}

/**
 * {@link @moralisweb3/common-core!BigNumberish} type for the amount of tokens
 */
type Erc20ValueInputAmount = BigNumberish;
/**
 * This is a number or a string that represents the decimals of tokens
 */
type Erc20ValueInputDecimals = number | string;
/**
 * Valid input for a new Erc20Value instance.
 * This can be an existing {@link Erc20Value} or a valid {@link Erc20ValueInputAmount} object
 */
type Erc20Valueish = Erc20ValueInputAmount | Erc20Value;
/**
 * This is the return type of the processed Erc20Value
 */
type Erc20ValueData = {
    amount: BigNumber;
    decimals: number;
};
/**
 * The options for the Erc20Value class
 */
type Erc20Options = {
    decimals?: Erc20ValueInputDecimals;
    token?: Erc20Tokenish;
};
/**
 * The Erc20Value class is a MoralisData that references to a the value of an Erc20Token
 * It holds data about the data about the amount of tokens and the number of decimals.
 *
 * @category DataType
 */
declare class Erc20Value implements MoralisData {
    /**
     * Create a new instance of Erc20Value from any valid input
     * @param value - The value to create
     * @param options - The options for the token
     * @example Erc20Value.create(1000, { decimals: 3 });
     * @returns The created value
     * @throws CoreError if the value is invalid
     */
    static create(value: Erc20Valueish, options?: Erc20Options): Erc20Value;
    private _value;
    private _token?;
    constructor(amount: Erc20ValueInputAmount, options?: Erc20Options);
    static parse: ({ amount, decimals, token, }: {
        amount: Erc20ValueInputAmount;
        decimals: Erc20ValueInputDecimals;
        token?: Erc20Tokenish | undefined;
    }) => Erc20ValueData;
    /**
     * Compares two Erc20Valueish instances.
     * @param valueA - The first value to compare
     * @param valueB - The second value to compare
     * @returns True if the values are equal
     * @example
     * ```ts
     * const valueA = Erc20Value.create(1000, { decimals: 3 });
     * const valueB = Erc20Value.create(10000, { decimals: 4 });
     * Erc20Value.equals(valueA, valueB); // true
     * ```
     */
    static equals(valueA: Erc20Valueish, valueB: Erc20Valueish): boolean;
    /**
     * Compares Erc20Value with current instance.
     * @param value - The value to compare
     * @returns True if the values are equal
     * @example value.equals(valueA);
     */
    equals(value: Erc20Valueish): boolean;
    /**
     * Convert the value to a number
     * @returns the value in number format
     * @example value.toNumber();
     */
    toNumber(): number;
    /**
     * Convert the value to a string
     * @returns the value in string format
     * @example value.toString();
     */
    toString(): string;
    /**
     * Displays the token in text format
     * @returns the value and also the token symbol if available
     * @example value.display();
     */
    display: () => string;
    /**
     * @deprecated This method will be removed soon. To format the value, use one of the properties.
     */
    format(): string;
    /**
     * Displays the token in JSON format
     * @returns the value and also the token if available
     * @example value.toJSON();
     */
    toJSON(): {
        value: string;
        token: {
            contractAddress: string;
            chain: string;
            decimals: number;
            name: string;
            symbol: string;
            logo?: string | null | undefined;
            logoHash?: string | null | undefined;
            thumbnail?: string | null | undefined;
            possibleSpam?: boolean | undefined;
        };
    } | {
        value: string;
        token?: undefined;
    };
    /**
     * @returns the token decimals
     * @example value.decimals; // 15
     */
    get decimals(): number;
    /**
     * @returns the token amount
     * @example value.amount; // BigNumber
     */
    get amount(): BigNumber;
    /**
     * @returns the token value
     * @example value.value; // "1000"
     */
    get value(): string;
    /**
     * @returns the token
     * @example value.token; // Erc20Token
     */
    get token(): Erc20Token | null;
}

interface EvmAbiItem {
    name?: string;
    type?: string;
    anonymous?: boolean;
    payable?: boolean;
    constant?: boolean;
    stateMutability?: string;
    inputs?: EvmAbiItemVariable[];
    outputs?: EvmAbiItemVariable[];
    gas?: number;
}
interface EvmAbiItemVariable {
    name?: string;
    indexed?: boolean;
    type?: string;
    internalType?: string;
    components?: EvmAbiItemVariable[];
}

/**
 * Type containing valid EVM native units
 */
type EvmNativeUnit = 'ether' | 'finney' | 'szabo' | 'gwei' | 'mwei' | 'kwei' | 'wei';
/**
 * A valid {@link EvmNativeUnit} or a number type
 */
type UnitOrDecimals = EvmNativeUnit | number;
/**
 * This is any valid {@link @moralisweb3/common-core!BigNumberish} value
 */
type InputEvmNative = BigNumberish;
/**
 * Valid input for a new EvmNative instance.
 * This can be an existing {@link EvmNative} or a valid {@link InputEvmNative} type
 */
type EvmNativeish = EvmNativeInput;
type EvmNativeInput = InputEvmNative | EvmNative;
type EvmNativeJSON = string;
/**
 * The EvmNative class is a MoralisData that references to the value of an EVM native currency (like ETH, BNB etc.)
 *
 * @category DataType
 */
declare class EvmNative implements MoralisData {
    private readonly rawValue;
    /**
     * Returns value of one ether.
     *
     * @example EvmNative.ONE_ETH
     */
    static get ONE_ETH(): EvmNative;
    /**
     * Returns value of one gwei.
     *
     * @example EvmNative.ONE_GWEI
     */
    static get ONE_GWEI(): EvmNative;
    /**
     * Returns value of one wei.
     *
     * @example EvmNative.ONE_WEI
     */
    static get ONE_WEI(): EvmNative;
    /**
     * Create a new instance of EvmNative from any valid {@link EvmNativeish} value.
     * @param native - the value to create the EvmNative from
     * @param unit - the unit of the value (optional), defaults to `ether`
     * @returns a new instance of EvmNative
     * @example
     * ```ts
     * const native = EvmNative.create(2, 'gwei');
     * const native = EvmNative.create(2);
     * const native = EvmNative.create(2, 'wei');
     *```
     */
    static create(native: EvmNativeish, unit?: UnitOrDecimals): EvmNative;
    static fromJSON(json: EvmNativeJSON): EvmNative;
    private constructor();
    private static parse;
    /**
     * Compares two EvmNative values.
     * @param valueA - the first value to compare
     * @param valueB - the second value to compare
     * @returns true if the values are equal
     * @example
     * ```ts
     * EvmNative.equals(EvmNative.create(1, 'ether'), EvmNative.create(1, 'ether')); // true
     * ```
     */
    static equals(valueA: EvmNativeish, valueB: EvmNativeish): boolean;
    /**
     * Compares EvmNative with current instance.
     * @param value - the value to compare with
     * @returns true if the values are equal
     * @example
     * ```ts
     * const native = EvmNative.create(1, 'gwei');
     * native.equals(EvmNative.create(1, 'ether')); // false
     * ```
     */
    equals(value: EvmNative): boolean;
    /**
     * Converts the EvmNative to a string.
     * @returns the value of the EvmNative as a string
     * @example `native.toString()`
     */
    toString(): string;
    /**
     * @deprecated This method will be removed soon. To format the value, use one of the properties.
     */
    format(): string;
    /**
     * @returns the value of the EvmNative as a BigNumber
     * @example `native.value`
     */
    get value(): BigNumber;
    /**
     * Converts the EvmNative to a string representation of the value in wei.
     * @returns the value of the EvmNative as a string
     * @example `native.wei`
     */
    get wei(): string;
    /**
     * Converts the EvmNative to a string representation of the value in gwei.
     * @returns the value of the EvmNative as a string
     * @example `native.gwei`
     */
    get gwei(): string;
    /**
     * Converts the EvmNative to a string representation of the value in ether.
     * @returns the value of the EvmNative as a string
     * @example `native.ether`
     */
    get ether(): string;
    toJSON(): EvmNativeJSON;
}

/**
 * Valid EvmTransactionLog input.
 *
 * @example
 * ```ts
 * const input = {
 *  address: "0x3105d328c66d8d55092358cf595d54608178e9b5",
 *  data: "0x00000000000000000000000000000000000000000000000de05239bccd4d537400000000000000000000000000024dbc80a9f80e3d5fc0a0ee30e2693781a443",
 *  topics: ["0x2caecd17d02f56fa897705dcc740da2d237c373f70686f4e0d9bd3bf0400ea7a", "0x000000000000000000000000031002d15b0d0cd7c9129d6f644446368deae391", null, null],
 *  transactionHash: "0xdd9006489e46670e0e85d1fb88823099e7f596b08aeaac023e9da0851f26fdd5",
 *  logIndex: "273",
 *  transactionIndex: "204",\
 *  blockHash: "0x9b559aef7ea858608c2e554246fe4a24287e7aeeb976848df2b9a2531f4b9171",
 *  blockNumber: "12386788",
 *  blockTimestamp: "2021-05-07T11:08:35.000Z",
 *  transactionIndex: "204",
 *  chain: "1"
 * }
 * ```
 */
interface EvmTransactionLogInput {
    logIndex?: string | number;
    transactionHash: string;
    transactionIndex?: number;
    address: EvmAddressish;
    data: string;
    topics: (string | null)[];
    blockHash: string;
    blockNumber: number;
    blockTimestamp?: string;
    chain: EvmChainish;
}
/**
 * Represents a processed transaction log.
 */
interface EvmTransactionLogData {
    logIndex?: number;
    transactionHash: string;
    transactionIndex?: number;
    address: EvmAddress;
    data: string;
    topics: (string | null)[];
    blockHash: string;
    blockNumber: number;
    blockTimestamp?: string;
    chain: EvmChain;
}

/**
 * This can be any valid {@link EvmTransactionLogInput} or {@link EvmTransactionLog}.
 */
type EvmTransactionLogish = EvmTransactionLogInput | EvmTransactionLog;
type LogTopic = string | null;
/**
 * The EvmTransactionLog class is a MoralisData that references an EVM transaction log.
 *
 * @category DataType
 */
declare class EvmTransactionLog implements MoralisDataObject {
    /**
     * Create a new instance of EvmTransactionLog from any valid address input
     *
     * @example
     * ```
     * const log = EvmTransactionLog.create(value, core);
     * ```
     * @param value - A valid EvmTransactionLogish
     * @param core - The Core instance
     */
    static create(value: EvmTransactionLogish): EvmTransactionLog;
    protected _value: EvmTransactionLogData;
    constructor(value: EvmTransactionLogInput);
    static parse(value: EvmTransactionLogInput): EvmTransactionLogData;
    /**
     * Compares the log to another log for equality.
     *
     * @param value - The value to compare with
     * @returns true if the logs are equal, otherwise false
     * @example
     * ```ts
     * log.equals(log);
     * ```
     */
    equals(value: this): boolean;
    /**
     * Converts the log to a JSON object.
     *
     * @returns the EvmTransactionLog as a JSON object
     * @example
     * ```ts
     * log.toJSON();
     * ```
     */
    toJSON(): {
        address: string;
        chain: string;
        logIndex?: number | undefined;
        transactionHash: string;
        transactionIndex?: number | undefined;
        data: string;
        topics: (string | null)[];
        blockHash: string;
        blockNumber: number;
        blockTimestamp?: string | undefined;
    };
    /**
     * @deprecated This method will be removed soon. To format the value, use one of the properties.
     */
    format(): {
        address: string;
        chain: string;
        logIndex?: number | undefined;
        transactionHash: string;
        transactionIndex?: number | undefined;
        data: string;
        topics: (string | null)[];
        blockHash: string;
        blockNumber: number;
        blockTimestamp?: string | undefined;
    };
    /**
     * Returns the processed Erc20Token.
     *
     * @returns the EvmTransactionLog value
     * @example
     * ```ts
     * log.result;
     *  ```
     */
    get result(): EvmTransactionLogData;
    /**
     * @returns the transaction hash of the log.
     *
     * @example
     * ```ts
     * log.transactionHash; // "0xdd9006489e46670e0e85d1fb88823099e7f596b08aeaac023e9da0851f26fdd5"
     * ```
     */
    get transactionHash(): string;
    /**
     * Returns the address of the log.
     *
     * @example
     * ```ts
     * log.address; // EvmAddress
     * ```
     */
    get address(): EvmAddress;
    /**
     * Returns the chain of the log.
     *
     * @example
     * ```ts
     * log.chain; // EvmChain
     * ```
     */
    get chain(): EvmChain;
    /**
     * @returns the log index of the log.
     *
     * @example
     * ```ts
     * log.logIndex; // 273
     * ```
     */
    get logIndex(): number | undefined;
    /**
     * @returns the data of the log.
     *
     * @example
     * ```ts
     * log.data; // "0x00000000000000000000000000000000000000000000000de05239bccd4d537400000000000000000000000000024dbc80a9f80e3d5fc0a0ee30e2693781a443"
     * ```
     */
    get data(): string;
    /**
     * @returns the topics of the log.
     *
     * @example
     * ```ts
     * log.topic0; // ["0x0000000000000000000000000000000000000000000000000000000000000001", "0x0000000000000000000000000000000000000000000000000000000000000002"]
     * ```
     */
    get topics(): (string | null)[];
    /**
     * @returns the block hash of the log.
     *
     * @example
     * ```ts
     * log.blockHash; // "0x9b559aef7ea858608c2e554246fe4a24287e7aeeb976848df2b9a2531f4b9171"
     * ```
     */
    get blockHash(): string;
    /**
     * @returns the block number of the log.
     *
     * @example
     * ```ts
     * log.blockNumber; // 12386788
     * ```
     */
    get blockNumber(): number;
    /**
     * @returns the block timestamp of the log.
     *
     * @example
     * ```ts
     * log.blockTimestamp; // "2021-05-07T11:08:35.000Z"
     * ```
     */
    get blockTimestamp(): string | undefined;
}

type EvmSignatureInputRSV = {
    r: string;
    s: string;
    v: number | string;
};
type EvmSignatureInput = EvmSignatureInputRSV | string;

type EvmSignatureData = Signature;
type EvmSignatureish = EvmSignatureInput | EvmSignature;
/**
 * Represents of a signed EVM signature
 * Can be created with a valid r,s,v signature or a hex string
 */
declare class EvmSignature implements MoralisDataObject {
    static create(data: EvmSignatureish): EvmSignature;
    private _data;
    constructor(data: EvmSignatureInput);
    static parse: (data: EvmSignatureInput) => EvmSignatureData;
    static equals(dataA: EvmSignatureish, dataB: EvmSignatureish): boolean;
    /**
     * Checks the equality of the current transfer instance with another nft transfer
     * @param data - the transfer to compare with
     * @example transaction.equals(data)
     * @returns true if the transfers are equal, false otherwise
     */
    equals(data: EvmSignatureish): boolean;
    get r(): string;
    get s(): string;
    get v(): number;
    get serialized(): string;
    toJSON(): MoralisDataObjectValue;
    /**
     * @deprecated This method will be removed soon. To format the value, use one of the properties.
     */
    format(): string;
}

/**
 * Valid EvmInternalTransactionLog input.
 *
 * @example
 * ```ts
 * const input = {
 *   "chain": "0x1",
 *   "transactionHash": "0x2ac6283fb30fe33499416b0388ff27145a0eeb6aa8b37bca40af87d7f1c74e2d",
 *   "block_number": 16876143,
 *   "block_hash": "0xc8d7592122307a771c5172af09699b5a2d36fa540d0fbc656f3d52c619c7536e",
 *   "type": "STATICCALL",
 *   "from": "0x283af0b28c62c092c9727f1ee09c02ca627eb7f5",
 *   "to": "0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85",
 *   "value": "0",
 *   "gas": "263200",
 *   "gas_used": "2569",
 *   "input": "0x96e494e8d40a37cd10c71cb3896d1b05b6c707e29cb5aeff0278c6fc7e5e5b31623a1baa",
 *   "output": "0x0000000000000000000000000000000000000000000000000000000000000001"
 * }
 * ```
 */
interface EvmInternalTransactionInput {
    chain: EvmChainish;
    transactionHash: string;
    blockNumber: BigNumberish;
    blockHash: string;
    type: string;
    from: EvmAddressish;
    to: EvmAddressish;
    value: BigNumberish;
    gas: BigNumberish;
    gasUsed: BigNumberish;
    input: string;
    output: string;
}
/**
 * Represents a processed internal transaction log.
 */
interface EvmInternalTransactionData {
    chain: EvmChain;
    transactionHash: string;
    blockNumber: BigNumber;
    blockHash: string;
    type: string;
    from: EvmAddress;
    to: EvmAddress;
    value: BigNumber;
    gas: BigNumber;
    gasUsed: BigNumber;
    input: string;
    output: string;
}

/**
 * Valid input for a new EvmInternalTransaction instance.
 * This can be an existing {@link EvmInternalTransaction} or a valid {@link EvmInternalTransactionInput} object
 */
type EvmInternalTransactionish = EvmInternalTransactionInput | EvmInternalTransaction;
/**
 * The EvmTranaction is a representation of a published transaction.
 *
 * Use this class any time you work with a transaction.
 *
 * @category DataType
 */
declare class EvmInternalTransaction implements MoralisDataObject {
    /**
     * Create a new instance of EvmInternalTransaction from any valid transaction input
     * @param data - the EvmInternalTransactionish type
     * @example
     * ```
     * const transaction = EvmInternalTransaction.create(data);
     *```
     */
    static create(data: EvmInternalTransactionish): EvmInternalTransaction;
    private _data;
    constructor(data: EvmInternalTransactionInput);
    static parse: (data: EvmInternalTransactionInput) => EvmInternalTransactionData;
    /**
     * Check the equality between two Evm internal transactions
     * @param dataA - The first transaction
     * @param dataB - The second transaction
     * @example
     * ```ts
     * EvmInternalTransaction.equals(dataA, dataB)
     * ```
     */
    static equals(dataA: EvmInternalTransactionish, dataB: EvmInternalTransactionish): boolean;
    /**
     * Checks the equality of the current transaction with another evm transaction
     * @param data - the transaction to compare with
     * @example
     * ```ts
     * transaction.equals(data)
     * ```
     */
    equals(data: EvmInternalTransactionish): boolean;
    toJSON(): {
        to: string;
        from: string;
        gas: string;
        gasUsed: string;
        value: string;
        chain: string;
        blockNumber: string;
        transactionHash: string;
        blockHash: string;
        type: string;
        input: string;
        output: string;
    };
    /**
     * @deprecated This method will be removed soon. To format the value, use one of the properties.
     */
    format(): {
        to: string;
        from: string;
        gas: string;
        gasUsed: string;
        value: string;
        chain: string;
        blockNumber: string;
        transactionHash: string;
        blockHash: string;
        type: string;
        input: string;
        output: string;
    };
    get result(): EvmInternalTransactionData;
    get chain(): EvmChain;
    get transactionHash(): string;
    get blockNumber(): BigNumber;
    get blockHash(): string;
    get type(): string;
    get from(): EvmAddress;
    get to(): EvmAddress;
    get value(): BigNumber;
    get gas(): BigNumber;
    get gasUsed(): BigNumber;
    get input(): string;
    get output(): string;
}

/**
 * This can be any object with valid transaction data.
 * @example
 * ```
 * const transactionInput = {
          cumulativeGasUsed: "1340925",
          gasPrice: "20000000000",
          gasUsed: "1340925",
          index: "25",
          contractAddress: "0x1d6a4cf64b52f6c73f201839aded7379ce58059c",
          receiptRoot: "string",
          receiptStatus: "1",
          chain: "1",
          data: "0x000000000000000000000000000000000000000000000000000000000000002",
          from: "0xd4a3BebD824189481FC45363602b83C9c7e9cbDf",
          hash: "0x057Ec652A4F150f7FF94f089A38008f49a0DF88e",
          nonce: "326595425",
          value: "650000000000000000",
          blockHash: "0x0372c302e3c52e8f2e15d155e2c545e6d802e479236564af052759253b20fd86",
          blockNumber: "12526958",
          blockTimestamp: new Date("2021-04-02T10:07:54.000Z"),
          gas: "6721975",
          to: "0xa71db868318f0a0bae9411347cd4a6fa23d8d4ef",
          transferIndex: "0",
          signature: {
            v: 28,
            r: "0xda4429a9e8e6b54cb101b2df002039f2879ab4ca0e8fae64134942cb81f3e581",
            s: "0x3b90a37dc078a82dfc418695b1d4473661aa4d24dd874ac68678894ff44a6b27",
          }
        }
 * ```
 */
interface EvmTransactionInput {
    chain: EvmChainish;
    from: EvmAddressish;
    to?: null | EvmAddressish;
    nonce?: null | BigNumberish;
    data?: null | string;
    value?: null | EvmNativeish;
    hash: string;
    gas?: null | BigNumberish;
    gasPrice: BigNumberish;
    index: number | string;
    blockNumber: BigNumberish;
    blockHash: string;
    blockTimestamp: DateInput;
    cumulativeGasUsed: BigNumberish;
    gasUsed: BigNumberish;
    contractAddress?: null | EvmAddressish;
    receiptRoot?: null | string;
    receiptStatus?: null | string | number;
    logs?: EvmTransactionLogish[];
    internalTransactions?: EvmInternalTransactionish[];
    signature?: EvmSignatureish;
}
/**
 * This is the return type of the processed EVM transaction
 */
interface EvmTransactionData {
    chain: EvmChain;
    from: EvmAddress;
    to?: EvmAddress;
    nonce?: BigNumber;
    data?: string;
    value?: EvmNative;
    hash: string;
    gas?: BigNumber;
    gasPrice: BigNumber;
    index: number | string;
    blockNumber: BigNumber;
    blockHash: string;
    blockTimestamp: Date;
    cumulativeGasUsed: BigNumber;
    gasUsed: BigNumber;
    contractAddress?: EvmAddress;
    receiptRoot?: string;
    receiptStatus?: number;
    logs: EvmTransactionLog[];
    internalTransactions: EvmInternalTransaction[];
    signature?: EvmSignature;
}

/**
 * Valid input for a new EvmTransaction instance.
 * This can be an existing {@link EvmTransaction} or a valid {@link EvmTransactionInput} object
 */
type EvmTransactionish = EvmTransactionInput | EvmTransaction;
/**
 * The EvmTransaction is a representation of a published transaction.
 *
 * Use this class any time you work with a transaction.
 *
 * @category DataType
 */
declare class EvmTransaction implements MoralisDataObject {
    /**
     * Create a new instance of EvmTransaction from any valid transaction input
     * @param data - the EvmTransactionish type
     * @example
     * ```
     * const transaction = EvmTransaction.create(data);
     *```
     */
    static create(data: EvmTransactionish): EvmTransaction;
    protected _data: EvmTransactionData;
    constructor(data: EvmTransactionInput);
    static parse(data: EvmTransactionInput): EvmTransactionData;
    /**
     * Check the equality between two Evm transactions
     * @param dataA - The first transaction
     * @param dataB - The second transaction
     * @example
     * ```ts
     * EvmTransaction.equals(dataA, dataB)
     * ```
     */
    static equals(dataA: EvmTransactionish, dataB: EvmTransactionish): boolean;
    /**
     * Checks the equality of the current transaction with another evm transaction
     * @param data - the transaction to compare with
     * @example
     * ```ts
     * transaction.equals(data)
     * ```
     */
    equals(data: EvmTransactionish): boolean;
    toJSON(): {
        to: string | undefined;
        from: string;
        nonce: string | undefined;
        gas: string | undefined;
        gasPrice: string;
        gasUsed: string;
        cumulativeGasUsed: string;
        value: string | undefined;
        chain: string;
        contractAddress: string | undefined;
        logs: {
            address: string;
            chain: string;
            logIndex?: number | undefined;
            transactionHash: string;
            transactionIndex?: number | undefined;
            data: string;
            topics: (string | null)[];
            blockHash: string;
            blockNumber: number;
            blockTimestamp?: string | undefined;
        }[];
        internalTransactions: {
            to: string;
            from: string;
            gas: string;
            gasUsed: string;
            value: string;
            chain: string;
            blockNumber: string;
            transactionHash: string;
            blockHash: string;
            type: string;
            input: string;
            output: string;
        }[];
        signature: _moralisweb3_common_core.MoralisDataObjectValue | undefined;
        blockNumber: string;
        blockTimestamp: string;
        data?: string | undefined;
        hash: string;
        index: string | number;
        blockHash: string;
        receiptRoot?: string | undefined;
        receiptStatus?: number | undefined;
    };
    /**
     * @deprecated This method will be removed soon. To format the value, use one of the properties.
     */
    format(): {
        to: string | undefined;
        from: string;
        nonce: string | undefined;
        gas: string | undefined;
        gasPrice: string;
        gasUsed: string;
        cumulativeGasUsed: string;
        value: string | undefined;
        chain: string;
        contractAddress: string | undefined;
        logs: {
            address: string;
            chain: string;
            logIndex?: number | undefined;
            transactionHash: string;
            transactionIndex?: number | undefined;
            data: string;
            topics: (string | null)[];
            blockHash: string;
            blockNumber: number;
            blockTimestamp?: string | undefined;
        }[];
        internalTransactions: {
            to: string;
            from: string;
            gas: string;
            gasUsed: string;
            value: string;
            chain: string;
            blockNumber: string;
            transactionHash: string;
            blockHash: string;
            type: string;
            input: string;
            output: string;
        }[];
        signature: _moralisweb3_common_core.MoralisDataObjectValue | undefined;
        blockNumber: string;
        blockTimestamp: string;
        data?: string | undefined;
        hash: string;
        index: string | number;
        blockHash: string;
        receiptRoot?: string | undefined;
        receiptStatus?: number | undefined;
    };
    /**
     * @returns the transaction
     * @example
     * ```
     * transaction.result
     * ```
     */
    get result(): EvmTransactionData;
    /**
     * @returns the transaction to address
     * @example
     * ```
     * transaction.to // EvmAddress
     * ```
     */
    get to(): EvmAddress | undefined;
    /**
     * @returns the transaction from address
     * @example
     * ```
     * transaction.address // EvmAddress
     * ```
     */
    get from(): EvmAddress;
    /**
     * @returns the transaction nonce
     * @example
     * ```
     * transaction.nonce // 326595425
     * ```
     */
    get nonce(): BigNumber | undefined;
    /**
     * @returns the transaction gas
     * @example
     * ```
     * transaction.gas // 6721975
     * ```
     */
    get gas(): BigNumber | undefined;
    /**
     * @returns the transaction gas price
     * @example
     * ```
     * transaction.gasPrice // 20000000000
     * ```
     */
    get gasPrice(): BigNumber;
    /**
     * @returns the transaction gas used
     * @example
     * ```
     * transaction.gasUsed // 1340925
     * ```
     */
    get gasUsed(): BigNumber;
    /**
     * @returns the transaction cumulative gas used
     * @example
     * ```
     * transaction.cumulativeGasUsed // 1340925
     * ```
     */
    get cumulativeGasUsed(): BigNumber;
    /**
     * @returns the transaction block number
     * @example
     * ```
     * transaction.blockNumber // 12526958
     * ```
     */
    get blockNumber(): BigNumber;
    /**
     * @returns the transaction value
     * @example
     * ```
     * transaction.value // EvmNative
     * ```
     */
    get value(): EvmNative | undefined;
    /**
     * @returns the transaction chain
     * @example
     * ```
     * transaction.chain // EvmChain
     * ```
     */
    get chain(): EvmChain;
    /**
     * @returns the transaction contract address
     * @example
     * ```
     * transaction.contractAddress // EvmAddress
     * ```
     */
    get contractAddress(): EvmAddress | undefined;
    /**
     * @returns the internal transactions
     * @example
     * ```
     * transaction.logs // EvmInternalTransaction[]
     * ```
     */
    get internalTransactions(): EvmInternalTransaction[];
    /**
     * @returns the transaction logs
     * @example
     * ```
     * transaction.logs // EvmTransactionLog[]
     * ```
     */
    get logs(): EvmTransactionLog[];
    /**
     * @returns the transaction receipt root
     * @example
     * ```
     * transaction.receiptRoot // string
     * ```
     */
    get receiptRoot(): string | undefined;
    /**
     * @returns the transaction receipt status
     * @example
     * ```
     * transaction.receiptStatus // 1
     * ```
     */
    get receiptStatus(): number | undefined;
    /**
     * @returns the transaction data
     * @example
     * ```
     * transaction.data // 0x000000000000000000000000000000000000000000000000000000000000002
     * ```
     */
    get data(): string | undefined;
    /**
     * @returns the transaction hash
     * @example
     * ```
     * transaction.hash // 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
     * ```
     */
    get hash(): string;
    /**
     * @returns the transaction black hash
     * @example
     * ```
     * transaction.blockHash // 0x0372c302e3c52e8f2e15d155e2c545e6d802e479236564af052759253b20fd86
     * ```
     */
    get blockHash(): string;
    /**
     * @returns the transaction block timestamp
     * @example
     * ```
     * transaction.blockTimestamp // Date
     * ```
     */
    get blockTimestamp(): Date;
    /**
     * @returns the signature (if available)
     * @example
     * ```
     * transaction.signature // EvmSignature
     * ```
     */
    get signature(): EvmSignature | undefined;
    /**
     * @returns the index
     * @example
     * ```
     * transaction.index // 1
     * ```
     */
    get index(): string | number;
    get v(): number | undefined;
    get r(): string | undefined;
    get s(): string | undefined;
}

/**
 * This can be any object with valid block data.
 * @example
 * ```
 * const input = {
 *    chain: 1,
 *    hash: '0x9b559aef7ea858608c2e554246fe4a24287e7aeeb976848df2b9a2531f4b9171',
 *    number: '12386788',
 *    timestamp: '2021-05-07T11:08:35.000Z',
 *  }
 * ```
 */
interface EvmSimpleBlockInput {
    timestamp: DateInput;
    number: BigNumberish;
    hash: string;
    chain: EvmChainish;
}
/**
 * This is the return type of the processed EVM Block
 */
interface EvmSimpleBlockData {
    timestamp: Date;
    number: BigNumber;
    hash: string;
    chain: EvmChain;
}
/**
 * This can be any object with valid block data.
 * @example
 * ```
 * const input = {
 *    chain: 1,
 *    hash: '0x9b559aef7ea858608c2e554246fe4a24287e7aeeb976848df2b9a2531f4b9171',
 *    difficulty: '7253857437305950',
 *    extraData: '0xd883010a01846765746888676f312e31352e31856c696e7578',
 *    gasLimit: '14977947',
 *    gasUsed: '14964688',
 *    logsBloom:
        '0xdde5fc46c5d8bcbd58207bc9f267bf43298e23791a326ff02661e99790da9996b3e0dd912c0b8202d389d282c56e4d11eb2dec4898a32b6b165f1f4cae6aa0079498eab50293f3b8defbf6af11bb75f0408a563ddfc26a3323d1ff5f9849e95d5f034d88a757ddea032c75c00708c9ff34d2207f997cc7d93fd1fa160a6bfaf62a54e31f9fe67ab95752106ba9d185bfdc9b6dc3e17427f844ee74e5c09b17b83ad6e8fc7360f5c7c3e4e1939e77a6374bee57d1fa6b2322b11ad56ad0398302de9b26d6fbfe414aa416bff141fad9d4af6aea19322e47595e342cd377403f417dfd396ab5f151095a5535f51cbc34a40ce9648927b7d1d72ab9daf253e31daf',
 *    miner: '0xea674fdde714fd979de3edf0f56aa9716b898ec8',
 *    nonce: '0xedeb2d8fd2b2bdec',
 *    number: '12386788',
 *    parentHash: '0x011d1fc45839de975cc55d758943f9f1d204f80a90eb631f3bf064b80d53e045',
 *    receiptsRoot: '0x7cf43d7e837284f036cf92c56973f5e27bdd253ca46168fa195a6b07fa719f23',
 *    sha3Uncles: '0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347',
 *    size: '61271',
 *    stateRoot: '0x49e3bfe7b618e27fde8fa08884803a8458b502c6534af69873a3cc926a7c724b',
 *    timestamp: '2021-05-07T11:08:35.000Z',
 *    totalDifficulty: '7253857437305950',
 *    transactionsRoot: '0xe4c7bf3aff7ad07f9e80d57f7189f0252592fee6321c2a9bd9b09b6ce0690d27',
 *    transactionCount: '252',
 *    transactions: [],
 *  }
 * ```
 */
interface EvmBlockInput extends EvmSimpleBlockInput {
    parentHash: string;
    nonce: string;
    sha3Uncles: string;
    logsBloom: string;
    transactionsRoot: string;
    stateRoot: string;
    receiptsRoot: string;
    miner: EvmAddressish;
    difficulty: BigNumberish;
    totalDifficulty: BigNumberish;
    size: BigNumberish;
    extraData: string;
    gasLimit: BigNumberish;
    gasUsed: BigNumberish;
    transactionCount: number | string;
    transactions: EvmTransactionish[];
}
/**
 * This is the return type of the processed EVM transaction
 */
interface EvmBlockData extends EvmSimpleBlockData {
    parentHash: string;
    nonce: string;
    sha3Uncles: string;
    logsBloom: string;
    transactionsRoot: string;
    stateRoot: string;
    receiptsRoot: string;
    miner: EvmAddress;
    difficulty: BigNumber;
    totalDifficulty: BigNumber;
    size: BigNumber;
    extraData: string;
    gasLimit: BigNumber;
    gasUsed: BigNumber;
    transactionCount: number;
    transactions: EvmTransaction[];
}

/**
 * Valid input for a new EvmSimpleBlock instance.
 * This can be an existing {@link EvmSimpleBlock} or a valid {@link EvmSimpleBlockInput} object
 */
type EvmSimpleBlockish = EvmSimpleBlockInput | EvmSimpleBlock;
/**
 * The EvmSimpleBlock is a representation of a block.
 *
 * @category DataType
 */
declare class EvmSimpleBlock implements MoralisDataObject {
    /**
     * Create a new instance of EvmSimpleBlock from any valid transaction input
     * @param data - the EvmSimpleBlockish type
     * @example const transaction = EvmSimpleBlock.create(data);
     */
    static create(data: EvmSimpleBlockish): EvmSimpleBlock;
    private _data;
    constructor(data: EvmSimpleBlockInput);
    static parse: (data: EvmSimpleBlockInput) => EvmSimpleBlockData;
    /**
     * Check the equality between two Evm blocks. It compares their hashes and blocks.
     * @param dataA - The first block to compare
     * @param dataB - The second block to compare
     * @example EvmSimpleBlock.equals(dataA, dataB)
     */
    static equals(dataA: EvmSimpleBlockish | EvmBlockish, dataB: EvmSimpleBlockish | EvmBlockish): boolean;
    /**
     * Checks the equality of the current block with another evm block
     * @param data - the block to compare with
     * @example
     * ```ts
     * block.equals(data)
     * ```
     */
    equals(data: EvmSimpleBlockish): boolean;
    /**
     * @returns a JSON represention of the block.
     * @example
     * ```
     * block.toJSON()
     * ```
     */
    toJSON(): {
        number: string;
        chain: string;
        timestamp: Date;
        hash: string;
    };
    /**
     * @deprecated This method will be removed soon. To format the value, use one of the properties.
     */
    format(): {
        number: string;
        chain: string;
        timestamp: Date;
        hash: string;
    };
    /**
     * @returns all the data without casting it to JSON.
     * @example block.result
     */
    get result(): EvmSimpleBlockData;
    /**
     * @returns the block number.
     * @example block.number // BigNumber
     */
    get number(): BigNumber;
    /**
     * @returns the block hash.
     * @example block.hash // "0x9b559aef7ea858608c2e554246fe4a24287e7aeeb976848df2b9a2531f4b9171"
     */
    get hash(): string;
    /**
     * @returns the block timestamp.
     * @example block.timestamp // Date
     */
    get timestamp(): Date;
    /**
     * @returns the block chain.
     * @example block.chain // EvmChain
     */
    get chain(): EvmChain;
}

/**
 * Valid input for a new EvmBlock instance.
 * This can be an existing {@link EvmBlock} or a valid {@link EvmBlockInput} object
 */
type EvmBlockish = EvmBlockInput | EvmBlock;
/**
 * The EvmBlock is a representation of a block.
 *
 * @category DataType
 */
declare class EvmBlock implements MoralisDataObject {
    /**
     * Create a new instance of EvmBlock from any valid transaction input
     * @param data - the EvmBlockish type
     * @example const transaction = EvmTransaction.create(data);
     */
    static create(data: EvmBlockish): EvmBlock;
    private _data;
    constructor(data: EvmBlockInput);
    static parse: (data: EvmBlockInput) => EvmBlockData;
    /**
     * Check the equality between two Evm blocks. It compares their hashes and blocks.
     * @param dataA - The first block to compare
     * @param dataB - The second block to compare
     * @example EvmTransaction.equals(dataA, dataB)
     */
    static equals(dataA: EvmSimpleBlockish | EvmBlockish, dataB: EvmSimpleBlockish | EvmBlockish): boolean;
    /**
     * Checks the equality of the current block with another evm block
     * @param data - the block to compare with
     * @example
     * ```ts
     * block.equals(data)
     * ```
     */
    equals(data: EvmBlockish): boolean;
    /**
     * @returns a JSON represention of the block.
     * @example
     * ```
     * block.toJSON()
     * ```
     */
    toJSON(): {
        number: string;
        difficulty: string;
        totalDifficulty: string;
        size: string;
        gasLimit: string;
        gasUsed: string;
        chain: string;
        miner: string;
        transactions: {
            to: string | undefined;
            from: string;
            nonce: string | undefined;
            gas: string | undefined;
            gasPrice: string;
            gasUsed: string;
            cumulativeGasUsed: string; /**
             * @returns the block miner.
             * @example block.miner // EvmAddress
             */
            value: string | undefined;
            chain: string;
            contractAddress: string | undefined;
            logs: {
                address: string;
                chain: string;
                logIndex?: number | undefined;
                transactionHash: string;
                transactionIndex?: number | undefined;
                data: string;
                topics: (string | null)[];
                blockHash: string;
                blockNumber: number;
                blockTimestamp?: string | undefined;
            }[];
            internalTransactions: {
                to: string;
                from: string;
                gas: string;
                gasUsed: string;
                value: string;
                chain: string;
                blockNumber: string;
                transactionHash: string;
                blockHash: string;
                type: string;
                input: string;
                output: string;
            }[];
            signature: _moralisweb3_common_core.MoralisDataObjectValue | undefined;
            blockNumber: string;
            blockTimestamp: string;
            data?: string | undefined;
            hash: string;
            index: string | number;
            blockHash: string;
            receiptRoot?: string | undefined;
            receiptStatus?: number | undefined;
        }[];
        parentHash: string;
        nonce: string;
        sha3Uncles: string;
        logsBloom: string;
        transactionsRoot: string;
        stateRoot: string;
        receiptsRoot: string;
        extraData: string;
        transactionCount: number;
        timestamp: Date;
        hash: string;
    };
    /**
     * @deprecated This method will be removed soon. To format the value, use one of the properties.
     */
    format(): {
        number: string;
        difficulty: string;
        totalDifficulty: string;
        size: string;
        gasLimit: string;
        gasUsed: string;
        chain: string;
        miner: string;
        transactions: {
            to: string | undefined;
            from: string;
            nonce: string | undefined;
            gas: string | undefined;
            gasPrice: string;
            gasUsed: string;
            cumulativeGasUsed: string; /**
             * @returns the block miner.
             * @example block.miner // EvmAddress
             */
            value: string | undefined;
            chain: string;
            contractAddress: string | undefined;
            logs: {
                address: string;
                chain: string;
                logIndex?: number | undefined;
                transactionHash: string;
                transactionIndex?: number | undefined;
                data: string;
                topics: (string | null)[];
                blockHash: string;
                blockNumber: number;
                blockTimestamp?: string | undefined;
            }[];
            internalTransactions: {
                to: string;
                from: string;
                gas: string;
                gasUsed: string;
                value: string;
                chain: string;
                blockNumber: string;
                transactionHash: string;
                blockHash: string;
                type: string;
                input: string;
                output: string;
            }[];
            signature: _moralisweb3_common_core.MoralisDataObjectValue | undefined;
            blockNumber: string;
            blockTimestamp: string;
            data?: string | undefined;
            hash: string;
            index: string | number;
            blockHash: string;
            receiptRoot?: string | undefined;
            receiptStatus?: number | undefined;
        }[];
        parentHash: string;
        nonce: string;
        sha3Uncles: string;
        logsBloom: string;
        transactionsRoot: string;
        stateRoot: string;
        receiptsRoot: string;
        extraData: string;
        transactionCount: number;
        timestamp: Date;
        hash: string;
    };
    /**
     * @returns all the data without casting it to JSON.
     * @example block.result
     */
    get result(): EvmBlockData;
    /**
     * @returns the block number.
     * @example block.number // BigNumber
     */
    get number(): BigNumber;
    /**
     * @returns the block hash.
     * @example block.hash // "0x9b559aef7ea858608c2e554246fe4a24287e7aeeb976848df2b9a2531f4b9171"
     */
    get hash(): string;
    /**
     * @returns the block timestamp.
     * @example block.timestamp // Date
     */
    get timestamp(): Date;
    /**
     * @returns the block miner.
     * @example block.miner // EvmAddress
     */
    get miner(): EvmAddress;
    /**
     * @returns the block difficulty.
     * @example block.difficulty // BigNumber
     */
    get difficulty(): BigNumber;
    /**
     * @returns the block total difficulty.
     * @example block.totalDifficulty // BigNumber
     */
    get totalDifficulty(): BigNumber;
    /**
     * @returns the block size.
     * @example block.size // BigNumber
     */
    get size(): BigNumber;
    /**
     * @returns the block gas limit.
     * @example block.gasLimit // BigNumber
     */
    get gasLimit(): BigNumber;
    /**
     * @returns the block gas used.
     * @example block.gasUsed // BigNumber
     */
    get gasUsed(): BigNumber;
    /**
     * @returns the block transactions.
     * @example block.transactions // EvmTransaction[]
     */
    get transactions(): EvmTransaction[];
    /**
     * @returns the block chain.
     * @example block.chain // EvmChain
     */
    get chain(): EvmChain;
    /**
     * @returns the block transaction count.
     * @example block.transactionCount // 252
     */
    get transactionCount(): number;
    /**
     * @returns the block transactions root.
     * @example block.transactionsRoot // "0xe4c7bf3aff7ad07f9e80d57f7189f0252592fee6321c2a9bd9b09b6ce0690d27"
     */
    get transactionsRoot(): string;
    /**
     * @returns the block state root.
     * @example block.stateRoot // "0x49e3bfe7b618e27fde8fa08884803a8458b502c6534af69873a3cc926a7c724b"
     */
    get stateRoot(): string;
    /**
     * @returns the block receipts root.
     * @example block.receiptsRoot // "0x7cf43d7e837284f036cf92c56973f5e27bdd253ca46168fa195a6b07fa719f23"
     */
    get receiptsRoot(): string;
    /**
     * @returns the block logs bloom.
     * @example block.logsBloom // "0xdde5fc46c5d8bcbd58207bc9f267bf43298e23791a326ff02661e99790da9996b3e0dd912c0b8202d389d282c56e4d11eb2dec4898a32b6b165f1f4cae6aa0079498eab50293f3b8defbf6af11bb75f0408a563ddfc26a3323d1ff5f9849e95d5f034d88a757ddea032c75c00708c9ff34d2207f997cc7d93fd1fa160a6bfaf62a54e31f9fe67ab95752106ba9d185bfdc9b6dc3e17427f844ee74e5c09b17b83ad6e8fc7360f5c7c3e4e1939e77a6374bee57d1fa6b2322b11ad56ad0398302de9b26d6fbfe414aa416bff141fad9d4af6aea19322e47595e342cd377403f417dfd396ab5f151095a5535f51cbc34a40ce9648927b7d1d72ab9daf253e31daf"
     */
    get logsBloom(): string;
    /**
     * @returns the block extra data.
     * @example block.extraData // "0x65746865726d696e652d6575726f70652d7765737433"
     */
    get extraData(): string;
    /**
     * @returns the block parent hash.
     * @example block.parentHash // "0x011d1fc45839de975cc55d758943f9f1d204f80a90eb631f3bf064b80d53e045"
     */
    get parentHash(): string;
    /**
     * @returns the block sha3Uncles.
     * @example block.sha3Uncles // "0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347"
     */
    get sha3Uncles(): string;
    /**
     * @returns the block nonce.
     * @example block.nonce // "0xedeb2d8fd2b2bdec"
     */
    get nonce(): string;
}

interface components {
    schemas: {
        decodedCall: {
            /** @example transfer(address,uint256) */
            signature?: string;
            /** @example transfer */
            label?: string;
            /** @example function */
            type?: string;
            params?: {
                /** @example _to */
                name?: string;
                /** @example 0x1CA455A55108874A95C84620dDA2566c54D17953 */
                value?: string;
                /** @example address */
                type?: string;
            }[];
        };
        decodedEvent: {
            /** @example Transfer(address,address,uint256) */
            signature?: string;
            /** @example Transfer */
            label?: string;
            /** @example event */
            type?: string;
            params?: {
                /** @example from */
                name?: string;
                /** @example 0x26C5011483Add49801eA8E3Ee354fE013895aCe5 */
                value?: string;
                /** @example address */
                type?: string;
            }[];
        };
        logCollection: {
            /**
             * @description The total number of matches for this query
             * @example 100
             */
            total?: number;
            /**
             * @description The current page of the result
             * @example 1
             */
            page?: number;
            /**
             * @description The number of results per page
             * @example 100
             */
            page_size?: number;
            /** @description The cursor to get to the next page */
            cursor?: string;
            result?: components["schemas"]["logEventByAddress"][];
        };
        logEventByAddress: {
            /**
             * @description The transaction hash
             * @example 0x2d30ca6f024dbc1307ac8a1a44ca27de6f797ec22ef20627a1307243b0ab7d09
             */
            transaction_hash: string;
            /**
             * @description The address of the contract
             * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
             */
            address: string;
            /**
             * @description The block timestamp
             * @example 2021-04-02T10:07:54.000Z
             */
            block_timestamp: string;
            /**
             * @description The block number
             * @example 12526958
             */
            block_number: string;
            /**
             * @description The block hash
             * @example 0x0372c302e3c52e8f2e15d155e2c545e6d802e479236564af052759253b20fd86
             */
            block_hash: string;
            /**
             * @description The data of the log
             * @example 0x00000000000000000000000000000000000000000000000de05239bccd4d537400000000000000000000000000024dbc80a9f80e3d5fc0a0ee30e2693781a443
             */
            data: string;
            /** @example 0x2caecd17d02f56fa897705dcc740da2d237c373f70686f4e0d9bd3bf0400ea7a */
            topic0: string;
            /** @example 0x000000000000000000000000031002d15b0d0cd7c9129d6f644446368deae391 */
            topic1: string;
            /** @example 0x000000000000000000000000d25943be09f968ba740e0782a34e710100defae9 */
            topic2: string;
            /** @example null */
            topic3: string;
            /**
             * @description The Transaction index of the log within the block
             * @example 12
             */
            transaction_index: number;
            /**
             * @description The log index of the log within the block
             * @example 15
             */
            log_index: number;
        };
        logEvent: {
            /**
             * @description The transaction hash
             * @example 0x2d30ca6f024dbc1307ac8a1a44ca27de6f797ec22ef20627a1307243b0ab7d09
             */
            transaction_hash: string;
            /**
             * @description The address of the contract
             * @example 0x18F97EF6B2cbac5CA85b375b7093C4A207340d06
             */
            address: string;
            /**
             * @description The block timestamp
             * @example 2021-04-02T10:07:54.000Z
             */
            block_timestamp: string;
            /**
             * @description The block number
             * @example 12526958
             */
            block_number: string;
            /**
             * @description The block hash
             * @example 0x0372c302e3c52e8f2e15d155e2c545e6d802e479236564af052759253b20fd86
             */
            block_hash: string;
            /** @description The content of the event */
            data: {
                /** @example 0x54ff6974c715956a5049a123408bff91fbe29f01 */
                from?: string;
                /** @example 0x74de5d4fcbf63e00296fd95d33236b9794016631 */
                to?: string;
                /** @example 260103496340000000000 */
                value?: string;
            };
        };
        log: {
            /** @example 273 */
            log_index: string;
            /**
             * @description The hash of the transaction
             * @example 0xdd9006489e46670e0e85d1fb88823099e7f596b08aeaac023e9da0851f26fdd5
             */
            transaction_hash: string;
            /** @example 204 */
            transaction_index: string;
            /**
             * @description The address of the contract
             * @example 0x3105d328c66d8d55092358cf595d54608178e9b5
             */
            address: string;
            /**
             * @description The data of the log
             * @example 0x00000000000000000000000000000000000000000000000de05239bccd4d537400000000000000000000000000024dbc80a9f80e3d5fc0a0ee30e2693781a443
             */
            data: string;
            /** @example 0x2caecd17d02f56fa897705dcc740da2d237c373f70686f4e0d9bd3bf0400ea7a */
            topic0: string;
            /** @example 0x000000000000000000000000031002d15b0d0cd7c9129d6f644446368deae391 */
            topic1?: string | unknown;
            /** @example 0x000000000000000000000000d25943be09f968ba740e0782a34e710100defae9 */
            topic2?: string | unknown;
            /** @example null */
            topic3?: string | unknown;
            /**
             * @description The timestamp of the block
             * @example 2021-05-07T11:08:35.000Z
             */
            block_timestamp: string;
            /**
             * @description The block number
             * @example 12386788
             */
            block_number: string;
            /**
             * @description The hash of the block
             * @example 0x9b559aef7ea858608c2e554246fe4a24287e7aeeb976848df2b9a2531f4b9171
             */
            block_hash: string;
        };
        logVerbose: {
            /** @example 273 */
            log_index: string;
            /**
             * @description The hash of the transaction
             * @example 0xdd9006489e46670e0e85d1fb88823099e7f596b08aeaac023e9da0851f26fdd5
             */
            transaction_hash: string;
            /** @example 204 */
            transaction_index: string;
            /**
             * @description The address of the contract
             * @example 0x3105d328c66d8d55092358cf595d54608178e9b5
             */
            address: string;
            /**
             * @description The data of the log
             * @example 0x00000000000000000000000000000000000000000000000de05239bccd4d537400000000000000000000000000024dbc80a9f80e3d5fc0a0ee30e2693781a443
             */
            data: string;
            /** @example 0x2caecd17d02f56fa897705dcc740da2d237c373f70686f4e0d9bd3bf0400ea7a */
            topic0: string;
            /** @example 0x000000000000000000000000031002d15b0d0cd7c9129d6f644446368deae391 */
            topic1?: string;
            /** @example 0x000000000000000000000000d25943be09f968ba740e0782a34e710100defae9 */
            topic2?: string;
            /** @example null */
            topic3?: string;
            /**
             * @description The timestamp of the block
             * @example 2021-05-07T11:08:35.000Z
             */
            block_timestamp: string;
            /**
             * @description The block number
             * @example 12386788
             */
            block_number: string;
            /**
             * @description The hash of the block
             * @example 0x9b559aef7ea858608c2e554246fe4a24287e7aeeb976848df2b9a2531f4b9171
             */
            block_hash: string;
            /** @description The decoded data of the log */
            decoded_event: components["schemas"]["decodedEvent"];
        };
        erc20Transfer: {
            /** @example Tether USD */
            token_name: string;
            /** @example USDT */
            token_symbol: string;
            /** @example https://assets.coingecko.com/coins/images/325/large/Tether-logo.png?1598003707 */
            token_logo?: string;
            /** @example 6 */
            token_decimals: string;
            /** @example 0x3105d328c66d8d55092358cf595d54608178e9b5 */
            contract_address: string;
            /**
             * @description The hash of the transaction
             * @example 0xdd9006489e46670e0e85d1fb88823099e7f596b08aeaac023e9da0851f26fdd5
             */
            transaction_hash: string;
            /** @example 204 */
            transaction_index: string;
            /** @example 204 */
            log_index: string;
            /**
             * @description The timestamp of the block
             * @example 2021-05-07T11:08:35.000Z
             */
            block_timestamp: string;
            /**
             * @description The block number
             * @example 12386788
             */
            block_number: string;
            /**
             * @description The hash of the block
             * @example 0x9b559aef7ea858608c2e554246fe4a24287e7aeeb976848df2b9a2531f4b9171
             */
            block_hash: string;
            /**
             * @description The address of the contract
             * @example 0x3105d328c66d8d55092358cf595d54608178e9b5
             */
            from_wallet: string;
            /**
             * @description The address of the contract
             * @example 0x3105d328c66d8d55092358cf595d54608178e9b5
             */
            to_wallet: string;
            /**
             * @description The value of the transfer
             * @example 57732989482831651
             */
            value: string;
            /**
             * @description The decimal value of the transfer
             * @example 577329894.8283165
             */
            value_decimal: string;
            /**
             * @description Indicates if a contract is possibly a spam contract
             * @example false
             */
            possible_spam: boolean;
        };
        erc20Burn: {
            /** @example Tether USD */
            token_name: string;
            /** @example USDT */
            token_symbol: string;
            /** @example https://assets.coingecko.com/coins/images/325/large/Tether-logo.png?1598003707 */
            token_logo?: string;
            /** @example 6 */
            token_decimals: string;
            /** @example 0x3105d328c66d8d55092358cf595d54608178e9b5 */
            contract_address: string;
            /**
             * @description The hash of the transaction
             * @example 0xdd9006489e46670e0e85d1fb88823099e7f596b08aeaac023e9da0851f26fdd5
             */
            transaction_hash: string;
            /** @example 204 */
            transaction_index: number;
            /** @example 204 */
            log_index: number;
            /**
             * @description The timestamp of the block
             * @example 2021-05-07T11:08:35.000Z
             */
            block_timestamp: string;
            /**
             * @description The block number
             * @example 12386788
             */
            block_number: number;
            /**
             * @description The hash of the block
             * @example 0x9b559aef7ea858608c2e554246fe4a24287e7aeeb976848df2b9a2531f4b9171
             */
            block_hash: string;
            /**
             * @description The address of the contract
             * @example 0x3105d328c66d8d55092358cf595d54608178e9b5
             */
            from_wallet: string;
            /**
             * @description The value of the transfer
             * @example 57732989482831651
             */
            value: string;
            /**
             * @description The decimal value of the transfer
             * @example 577329894.8283165
             */
            value_decimal: string;
            /**
             * @description Indicates if a contract is possibly a spam contract
             * @example false
             */
            possible_spam?: boolean;
        };
        erc20Mint: {
            /** @example Tether USD */
            token_name: string;
            /** @example USDT */
            token_symbol: string;
            /** @example https://assets.coingecko.com/coins/images/325/large/Tether-logo.png?1598003707 */
            token_logo?: string;
            /** @example 6 */
            token_decimals: string;
            /** @example 0x3105d328c66d8d55092358cf595d54608178e9b5 */
            contract_address: string;
            /**
             * @description The hash of the transaction
             * @example 0xdd9006489e46670e0e85d1fb88823099e7f596b08aeaac023e9da0851f26fdd5
             */
            transaction_hash: string;
            /** @example 204 */
            transaction_index: number;
            /** @example 204 */
            log_index: number;
            /**
             * @description The timestamp of the block
             * @example 2021-05-07T11:08:35.000Z
             */
            block_timestamp: string;
            /**
             * @description The block number
             * @example 12386788
             */
            block_number: number;
            /**
             * @description The hash of the block
             * @example 0x9b559aef7ea858608c2e554246fe4a24287e7aeeb976848df2b9a2531f4b9171
             */
            block_hash: string;
            /**
             * @description The address of the contract
             * @example 0x3105d328c66d8d55092358cf595d54608178e9b5
             */
            to_wallet: string;
            /**
             * @description The value of the transfer
             * @example 57732989482831651
             */
            value: string;
            /**
             * @description The decimal value of the transfer
             * @example 577329894.8283165
             */
            value_decimal: string;
            /**
             * @description Indicates if a contract is possibly a spam contract
             * @example false
             */
            possible_spam?: boolean;
        };
        erc20Approval: {
            /** @example Tether USD */
            token_name: string;
            /** @example USDT */
            token_symbol: string;
            /** @example https://assets.coingecko.com/coins/images/325/large/Tether-logo.png?1598003707 */
            token_logo?: string;
            /** @example 6 */
            token_decimals: string;
            /** @example 0x3105d328c66d8d55092358cf595d54608178e9b5 */
            contract_address: string;
            /**
             * @description The hash of the transaction
             * @example 0xdd9006489e46670e0e85d1fb88823099e7f596b08aeaac023e9da0851f26fdd5
             */
            transaction_hash: string;
            /** @example 204 */
            transaction_index: number;
            /** @example 204 */
            log_index: number;
            /**
             * @description The timestamp of the block
             * @example 2021-05-07T11:08:35.000Z
             */
            block_timestamp: string;
            /**
             * @description The block number
             * @example 12386788
             */
            block_number: number;
            /**
             * @description The hash of the block
             * @example 0x9b559aef7ea858608c2e554246fe4a24287e7aeeb976848df2b9a2531f4b9171
             */
            block_hash: string;
            /**
             * @description The address of the contract
             * @example 0x3105d328c66d8d55092358cf595d54608178e9b5
             */
            from_wallet: string;
            /**
             * @description The address of the contract
             * @example 0x3105d328c66d8d55092358cf595d54608178e9b5
             */
            to_wallet: string;
            /**
             * @description The value of the transfer
             * @example 57732989482831651
             */
            value: string;
            /**
             * @description The decimal value of the transfer
             * @example 577329894.8283165
             */
            value_decimal: string;
            /**
             * @description Indicates if a contract is possibly a spam contract
             * @example false
             */
            possible_spam: boolean;
        };
        erc20TransfersResponse: {
            /** @description The cursor to get to the next page */
            cursor?: string;
            result?: components["schemas"]["erc20Transfer"][];
        };
        erc20MintsResponse: {
            /** @description The cursor to get to the next page */
            cursor?: string;
            result?: components["schemas"]["erc20Mint"][];
        };
        erc20BurnsResponse: {
            /** @description The cursor to get to the next page */
            cursor?: string;
            result?: components["schemas"]["erc20Burn"][];
        };
        erc20ApprovalsResponse: {
            /** @description The cursor to get to the next page */
            cursor?: string;
            result?: components["schemas"]["erc20Approval"][];
        };
        logResponse: {
            /** @description The cursor to get to the next page */
            cursor?: string;
            result?: components["schemas"]["log"][];
        };
        blockTransaction: {
            /**
             * @description The hash of the transaction
             * @example 0x1ed85b3757a6d31d01a4d6677fc52fd3911d649a0af21fe5ca3f886b153773ed
             */
            hash: string;
            /**
             * @description The nonce
             * @example 1848059
             */
            nonce: string;
            /** @example 108 */
            transaction_index: string;
            /**
             * @description The from address
             * @example 0x267be1c1d684f78cb4f6a176c4911b741e4ffdc0
             */
            from_address: string;
            /**
             * @description The to address
             * @example 0x003dde3494f30d861d063232c6a8c04394b686ff
             */
            to_address: string | unknown;
            /**
             * @description The value sent
             * @example 115580000000000000
             */
            value: string;
            /** @example 30000 */
            gas?: string;
            /**
             * @description The gas price
             * @example 52500000000
             */
            gas_price: string;
            /** @example 0x */
            input: string;
            /** @example 4923073 */
            receipt_cumulative_gas_used: string;
            /** @example 21000 */
            receipt_gas_used: string;
            /** @example null */
            receipt_contract_address?: string | unknown;
            /** @example null */
            receipt_root?: string | unknown;
            /** @example 1 */
            receipt_status: string;
            /**
             * @description The block timestamp
             * @example 2021-05-07T11:08:35.000Z
             */
            block_timestamp: string;
            /**
             * @description The block number
             * @example 12386788
             */
            block_number: string;
            /**
             * @description The hash of the block
             * @example 0x9b559aef7ea858608c2e554246fe4a24287e7aeeb976848df2b9a2531f4b9171
             */
            block_hash: string;
            /** @description The logs of the transaction */
            logs?: components["schemas"]["log"][];
            /** @description The internal transactions of the transaction */
            internal_transactions?: components["schemas"]["internalTransaction"][];
        };
        blockTransactionDecoded: {
            /**
             * @description The hash of the transaction
             * @example 0x1ed85b3757a6d31d01a4d6677fc52fd3911d649a0af21fe5ca3f886b153773ed
             */
            hash: string;
            /**
             * @description The nonce
             * @example 1848059
             */
            nonce: string;
            /** @example 108 */
            transaction_index: string;
            /**
             * @description The from address
             * @example 0x267be1c1d684f78cb4f6a176c4911b741e4ffdc0
             */
            from_address: string;
            /**
             * @description The to address
             * @example 0x003dde3494f30d861d063232c6a8c04394b686ff
             */
            to_address: string;
            /**
             * @description The value sent
             * @example 115580000000000000
             */
            value: string;
            /** @example 30000 */
            gas?: string;
            /**
             * @description The gas price
             * @example 52500000000
             */
            gas_price: string;
            /** @example 0x */
            input: string;
            /** @example 4923073 */
            receipt_cumulative_gas_used: string;
            /** @example 21000 */
            receipt_gas_used: string;
            /** @example null */
            receipt_contract_address?: string;
            /** @example null */
            receipt_root?: string;
            /** @example 1 */
            receipt_status: string;
            /**
             * @description The block timestamp
             * @example 2021-05-07T11:08:35.000Z
             */
            block_timestamp: string;
            /**
             * @description The block number
             * @example 12386788
             */
            block_number: string;
            /**
             * @description The hash of the block
             * @example 0x9b559aef7ea858608c2e554246fe4a24287e7aeeb976848df2b9a2531f4b9171
             */
            block_hash: string;
            /** @description The logs of the transaction */
            logs: components["schemas"]["logVerbose"][];
            /** @description The decoded data of the transaction */
            decoded_call: components["schemas"]["decodedCall"];
        };
        block: {
            /**
             * @description The block timestamp
             * @example 2021-05-07T11:08:35.000Z
             */
            timestamp: string;
            /**
             * @description The block number
             * @example 12386788
             */
            number: string;
            /**
             * @description The block hash
             * @example 0x9b559aef7ea858608c2e554246fe4a24287e7aeeb976848df2b9a2531f4b9171
             */
            hash: string;
            /**
             * @description The block hash of the parent block
             * @example 0x011d1fc45839de975cc55d758943f9f1d204f80a90eb631f3bf064b80d53e045
             */
            parent_hash: string;
            /**
             * @description The nonce
             * @example 0xedeb2d8fd2b2bdec
             */
            nonce: string;
            /** @example 0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347 */
            sha3_uncles: string;
            /** @example 0xdde5fc46c5d8bcbd58207bc9f267bf43298e23791a326ff02661e99790da9996b3e0dd912c0b8202d389d282c56e4d11eb2dec4898a32b6b165f1f4cae6aa0079498eab50293f3b8defbf6af11bb75f0408a563ddfc26a3323d1ff5f9849e95d5f034d88a757ddea032c75c00708c9ff34d2207f997cc7d93fd1fa160a6bfaf62a54e31f9fe67ab95752106ba9d185bfdc9b6dc3e17427f844ee74e5c09b17b83ad6e8fc7360f5c7c3e4e1939e77a6374bee57d1fa6b2322b11ad56ad0398302de9b26d6fbfe414aa416bff141fad9d4af6aea19322e47595e342cd377403f417dfd396ab5f151095a5535f51cbc34a40ce9648927b7d1d72ab9daf253e31daf */
            logs_bloom: string;
            /** @example 0xe4c7bf3aff7ad07f9e80d57f7189f0252592fee6321c2a9bd9b09b6ce0690d27 */
            transactions_root: string;
            /** @example 0x49e3bfe7b618e27fde8fa08884803a8458b502c6534af69873a3cc926a7c724b */
            state_root: string;
            /** @example 0x7cf43d7e837284f036cf92c56973f5e27bdd253ca46168fa195a6b07fa719f23 */
            receipts_root: string;
            /**
             * @description The address of the miner
             * @example 0xea674fdde714fd979de3edf0f56aa9716b898ec8
             */
            miner: string;
            /**
             * @description The difficulty of the block
             * @example 7253857437305950
             */
            difficulty: string;
            /**
             * @description The total difficulty
             * @example 24325637817906576196890
             */
            total_difficulty: string;
            /**
             * @description The block size
             * @example 61271
             */
            size: string;
            /** @example 0x65746865726d696e652d6575726f70652d7765737433 */
            extra_data: string;
            /**
             * @description The gas limit
             * @example 14977947
             */
            gas_limit: string;
            /**
             * @description The gas used
             * @example 14964688
             */
            gas_used: string;
            /**
             * @description The number of transactions in the block
             * @example 252
             */
            transaction_count: string;
            /** @description The transactions in the block */
            transactions: components["schemas"]["blockTransaction"][];
        };
        blockTransactionVerbose: {
            /**
             * @description The hash of the transaction
             * @example 0x1ed85b3757a6d31d01a4d6677fc52fd3911d649a0af21fe5ca3f886b153773ed
             */
            hash: string;
            /**
             * @description The nonce
             * @example 1848059
             */
            nonce: string;
            /** @example 108 */
            transaction_index: string;
            /**
             * @description The from address
             * @example 0x267be1c1d684f78cb4f6a176c4911b741e4ffdc0
             */
            from_address: string;
            /**
             * @description The to address
             * @example 0x003dde3494f30d861d063232c6a8c04394b686ff
             */
            to_address: string;
            /**
             * @description The value sent
             * @example 115580000000000000
             */
            value: string;
            /** @example 30000 */
            gas?: string;
            /**
             * @description The gas price
             * @example 52500000000
             */
            gas_price: string;
            /** @example 0x */
            input: string;
            /** @example 4923073 */
            receipt_cumulative_gas_used: string;
            /** @example 21000 */
            receipt_gas_used: string;
            /** @example null */
            receipt_contract_address?: string;
            /** @example null */
            receipt_root?: string;
            /** @example 1 */
            receipt_status: string;
            /**
             * @description The block timestamp
             * @example 2021-05-07T11:08:35.000Z
             */
            block_timestamp: string;
            /**
             * @description The block number
             * @example 12386788
             */
            block_number: string;
            /**
             * @description The hash of the block
             * @example 0x9b559aef7ea858608c2e554246fe4a24287e7aeeb976848df2b9a2531f4b9171
             */
            block_hash: string;
            /** @description The logs of the transaction */
            logs: components["schemas"]["logVerbose"][];
            /** @description The decoded data of the transaction */
            decoded_call: components["schemas"]["decodedCall"];
        };
        blockDate: {
            /**
             * @description The date of the block
             * @example 2020-01-01T00:00:00+00:00
             */
            date: string;
            /**
             * @description The block number
             * @example 9193266
             */
            block: number;
            /**
             * @description The timestamp of the block
             * @example 1577836811
             */
            timestamp: number;
            /**
             * @description The timestamp of the block
             * @example 2019-12-31T23:59:45.000Z
             */
            block_timestamp?: string;
            /**
             * @description The block hash
             * @example 0x9b559aef7ea858608c2e554246fe4a24287e7aeeb976848df2b9a2531f4b9171
             */
            hash?: string;
            /**
             * @description The block hash of the parent block
             * @example 0x011d1fc45839de975cc55d758943f9f1d204f80a90eb631f3bf064b80d53e045
             */
            parent_hash?: string;
        };
        RunContractDto: {
            /**
             * @description The contract ABI
             * @example []
             */
            abi: {
                [key: string]: unknown;
            }[];
            /**
             * @description The params for the given function
             * @example {}
             */
            params?: {
                [key: string]: unknown;
            };
        };
        tokenItem: {
            /**
             * @description The contract address
             * @example 0x06012c8cf97bead5deae237070f9587f8e7a266d
             */
            token_address?: string;
            /**
             * @description The id of the token
             * @example 100
             */
            token_id?: string;
        };
        GetMultipleNftsDto: {
            /**
             * @description The tokens to be fetched (max 25 tokens)
             * @example [
             *   {
             *     "token_address": "0xa4991609c508b6d4fb7156426db0bd49fe298bd8",
             *     "token_id": "12"
             *   },
             *   {
             *     "token_address": "0x3c64dc415ebb4690d1df2b6216148c8de6dd29f7",
             *     "token_id": "1"
             *   },
             *   {
             *     "token_address": "0x3c64dc415ebb4690d1df2b6216148c8de6dd29f7",
             *     "token_id": "200"
             *   }
             * ]
             */
            tokens: components["schemas"]["tokenItem"][];
            /**
             * @description Should normalized metadata be returned?
             * @example false
             */
            normalizeMetadata?: boolean;
            /**
             * @description Should preview media data be returned?
             * @example false
             */
            media_items?: boolean;
        };
        transactionCollection: {
            /**
             * @description The total number of matches for this query
             * @example 2000
             */
            total?: number;
            /**
             * @description The current page of the result
             * @example 2
             */
            page?: number;
            /**
             * @description The number of results per page
             * @example 100
             */
            page_size?: number;
            result?: components["schemas"]["transaction"][];
        };
        transactionCollectionVerbose: {
            /**
             * @description The current page of the result
             * @example 2
             */
            page?: number;
            /**
             * @description The number of results per page
             * @example 100
             */
            page_size?: number;
            result?: components["schemas"]["blockTransactionVerbose"][];
        };
        walletNetWorth: {
            /**
             * @description The native balance of the wallet
             * @example 5540003996556578955
             */
            native_balance: string;
            /**
             * @description The native balance of the wallet in decimals
             * @example 5.540003996556578955
             */
            native_balance_decimals: number;
            /**
             * @description The native balance of the wallet in USD
             * @example 10545.313
             */
            native_balance_usd: string;
            /**
             * @description The total networth of the wallet in USD
             * @example 26259173.472450234
             */
            total_networth_usd: string;
        };
        transaction: {
            /**
             * @description The hash of the transaction
             * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
             */
            hash: string;
            /**
             * @description The nonce of the transaction
             * @example 326595425
             */
            nonce: string;
            /**
             * @description The transaction index
             * @example 25
             */
            transaction_index: string;
            /**
             * @description The sender
             * @example 0xd4a3BebD824189481FC45363602b83C9c7e9cbDf
             */
            from_address: string;
            /**
             * @description The recipient
             * @example 0xa71db868318f0a0bae9411347cd4a6fa23d8d4ef
             */
            to_address: string;
            /**
             * @description The value that was transferred (in wei)
             * @example 650000000000000000
             */
            value: string;
            /**
             * @description The gas of the transaction
             * @example 6721975
             */
            gas: string;
            /**
             * @description The gas price
             * @example 20000000000
             */
            gas_price: string;
            /** @description The input */
            input: string;
            /**
             * @description The receipt cumulative gas used
             * @example 1340925
             */
            receipt_cumulative_gas_used: string;
            /**
             * @description The receipt gas used
             * @example 1340925
             */
            receipt_gas_used: string;
            /**
             * @description The receipt contract address
             * @example 0x1d6a4cf64b52f6c73f201839aded7379ce58059c
             */
            receipt_contract_address: string;
            /** @description The receipt root */
            receipt_root: string;
            /**
             * @description The receipt status
             * @example 1
             */
            receipt_status: string;
            /**
             * @description The block timestamp
             * @example 2021-04-02T10:07:54.000Z
             */
            block_timestamp: string;
            /**
             * @description The block number
             * @example 12526958
             */
            block_number: string;
            /**
             * @description The block hash
             * @example 0x0372c302e3c52e8f2e15d155e2c545e6d802e479236564af052759253b20fd86
             */
            block_hash: string;
            /** @description The internal transaction */
            internal_transactions?: components["schemas"]["internalTransaction"][];
        };
        internalTransaction: {
            /**
             * @description The hash of the transaction
             * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
             */
            transaction_hash: string;
            /**
             * @description The block number
             * @example 12526958
             */
            block_number: string;
            /**
             * @description The block hash
             * @example 0x0372c302e3c52e8f2e15d155e2c545e6d802e479236564af052759253b20fd86
             */
            block_hash: string;
            /**
             * @description Call type
             * @example CALL
             */
            type: string;
            /**
             * @description The sender
             * @example 0xd4a3BebD824189481FC45363602b83C9c7e9cbDf
             */
            from: string;
            /**
             * @description The recipient
             * @example 0xa71db868318f0a0bae9411347cd4a6fa23d8d4ef
             */
            to: string;
            /**
             * @description The value that was transfered (in wei)
             * @example 650000000000000000
             */
            value: string;
            /**
             * @description The gas of the transaction
             * @example 6721975
             */
            gas: string;
            /**
             * @description The used gas
             * @example 6721975
             */
            gas_used: string;
            /**
             * @description The input
             * @example 0x
             */
            input: string;
            /**
             * @description The output
             * @example 0x
             */
            output: string;
        };
        erc20Allowance: {
            /** @description The allowance */
            allowance: string;
        };
        erc20TokenBalance: {
            /**
             * @description The address of the token contract
             * @example 0x2d30ca6f024dbc1307ac8a1a44ca27de6f797ec22ef20627a1307243b0ab7d09
             */
            token_address: string;
            /**
             * @description The name of the token contract
             * @example Kylin Network
             */
            name: string;
            /**
             * @description The symbol of the NFT contract
             * @example KYL
             */
            symbol: string;
            /**
             * @description The logo of the token
             * @example https://cdn.moralis.io/eth/0x67b6d479c7bb412c54e03dca8e1bc6740ce6b99c.png
             */
            logo?: string;
            /**
             * @description The thumbnail of the logo
             * @example https://cdn.moralis.io/eth/0x67b6d479c7bb412c54e03dca8e1bc6740ce6b99c_thumb.png
             */
            thumbnail?: string;
            /**
             * @description The number of decimals on the token
             * @example 18
             */
            decimals: number;
            /**
             * @description Timestamp of when the contract was last synced with the node
             * @example 123456789
             */
            balance: string;
            /**
             * @description Indicates if a contract is possibly a spam contract
             * @example false
             */
            possible_spam: boolean;
        };
        nativeBalance: {
            /**
             * @description The balance
             * @example 1234567890
             */
            balance: string;
        };
        trade: {
            /**
             * @description The transaction hash
             * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
             */
            transaction_hash: string;
            /** @description The transaction index */
            transaction_index: string;
            /**
             * @description The token ID(s) traded
             * @example [
             *   "15",
             *   "54"
             * ]
             */
            token_ids: string[];
            /**
             * @description The address that sold the NFT
             * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
             */
            seller_address: string;
            /**
             * @description The address that bought the NFT
             * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
             */
            buyer_address: string;
            /**
             * @description The address of the NFT contract
             * @example 0x4ad3785ec7eed7589fa86538244a4530f962434f
             */
            token_address: string;
            /**
             * @description The address of the contract that traded the NFT
             * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
             */
            marketplace_address: string;
            /**
             * @description The address of the token used to pay for the NFT
             * @example 0x60e4d786628fea6478f785a6d7e704777c86a7c6
             */
            price_token_address?: string;
            /**
             * @description The value that was sent in the transaction (ETH/BNB/etc..)
             * @example 1000000000000000
             */
            price: string;
            /**
             * @description The block timestamp
             * @example 2021-06-04T16:00:15
             */
            block_timestamp: string;
            /**
             * @description The block number of the transaction
             * @example 13680123
             */
            block_number: string;
            /**
             * @description The block hash
             * @example 0x4a7c916ca4a970358b9df90051008f729685ff05e9724a9dddba32630c37cb96
             */
            block_hash: string;
        };
        tradeCollection: {
            /**
             * @description The total number of matches for this query
             * @example 2000
             */
            total?: number;
            /**
             * @description The current page of the result
             * @example 2
             */
            page?: number;
            /**
             * @description The number of results per page
             * @example 100
             */
            page_size?: number;
            /** @description The cursor to get to the next page */
            cursor?: string;
            result?: components["schemas"]["trade"][];
        };
        /**
         * @default
         * @example
         * @enum {string}
         */
        includeList: "internal_transactions";
        /**
         * @default eth
         * @example eth
         * @enum {string}
         */
        chainList: "eth" | "0x1" | "goerli" | "0x5" | "sepolia" | "0xaa36a7" | "polygon" | "0x89" | "mumbai" | "0x13881" | "bsc" | "0x38" | "bsc testnet" | "0x61" | "avalanche" | "0xa86a" | "fantom" | "0xfa" | "palm" | "0x2a15c308d" | "cronos" | "0x19" | "arbitrum" | "0xa4b1";
        nft: {
            /**
             * @description The address of the NFT contract
             * @example 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB
             */
            token_address: string;
            /**
             * @description The token ID of the NFT
             * @example 15
             */
            token_id: string;
            /**
             * @description The wallet address of the owner of the NFT
             * @example 0x9c83ff0f1c8924da96cb2fcb7e093f78eb2e316b
             */
            owner_of?: string;
            /**
             * @description The token hash
             * @example 502cee781b0fb40ea02508b21d319ced
             */
            token_hash?: string;
            /**
             * @description The block number when the amount or owner changed
             * @example 88256
             */
            block_number?: string;
            /**
             * @description The block number when the NFT was minted
             * @example 88256
             */
            block_number_minted?: string;
            /**
             * @description The type of NFT contract standard
             * @example ERC721
             */
            contract_type: string;
            /** @description The URI to the metadata of the token */
            token_uri?: string;
            /** @description The metadata of the token */
            metadata?: string;
            /** @description A normalized metadata version of the NFT's metadata. */
            normalized_metadata?: components["schemas"]["normalizedMetadata"];
            /** @description A set of links to 'thumbnail / preview' media files */
            media?: components["schemas"]["media"];
            /**
             * @description The address that minted the NFT
             * @example 0x9c83ff0f1c8924da96cb2fcb7e093f78eb2e316b
             */
            minter_address?: string;
            /** @description When the token_uri was last updated */
            last_token_uri_sync?: string;
            /** @description When the metadata was last updated */
            last_metadata_sync?: string;
            /**
             * @description The quantity of this item that the user owns (used by ERC1155)
             * @example 1
             */
            amount?: string;
            /**
             * @description The name of the NFT contract
             * @example CryptoKitties
             */
            name: string;
            /**
             * @description The symbol of the NFT contract
             * @example RARI
             */
            symbol: string;
            /**
             * @description Indicates if a contract is possibly a spam contract
             * @example false
             */
            possible_spam: boolean;
        };
        nftMetadata: {
            /**
             * @description The token ID of the NFT
             * @example 889
             */
            token_id: string;
            /**
             * @description The address of the NFT contract
             * @example 0x8ce66ff0865570d1ff0bb0098fa41b4dc61e02e6
             */
            token_address: string;
            /**
             * @description The URI to the metadata of the token
             * @example https://ipfs.moralis.io:2053/ipfs/QmZZbo8u8zEWg7wtmZhJS2W718WL6FA95T4XdgmCcLp1SJ/889.json
             */
            token_uri: string;
            /**
             * @description The metadata of the token
             * @example {"name":"Bape #889","description":"The #1 metavestor clan (NFT/DAO) by a team with multi billion dollar company experience.","image":"https://bapesclan.mypinata.cloud/ipfs/QmTSUD5JA6qHaC5t25mcXySfz19AV9u4Mb6Na7ntQ6tEwf/889.jpg","attributes":[{"trait_type":"Background","value":"Black"},{"trait_type":"Body","value":"Man"},{"trait_type":"Dress","value":"Suit Tie Blue"},{"trait_type":"Face","value":"Pipe"},{"trait_type":"Eye","value":"Eye"}]}
             */
            metadata: string;
            /** @example 1 */
            is_valid: number;
            /** @example 2 */
            syncing: number;
            /** @example 0 */
            frozen: number;
            /** @example 0 */
            resyncing: number;
            /**
             * @description The type of NFT contract standard
             * @example ERC721
             */
            contract_type: string;
            /** @example fffa3102469ce77f569893d16d5884f9 */
            token_hash: string;
            /** @example fd995c8a-f8b2-40cb-a407-f43e552638b4 */
            batch_id: string;
            /** @example Bape #889 */
            metadata_name: string;
            /** @example The #1 metavestor clan (NFT/DAO) by a team with multi billion dollar company experience. */
            metadata_description: string;
            /** @example [{"trait_type":"Background","value":"Black"},{"trait_type":"Body","value":"Man"},{"trait_type":"Dress","value":"Suit Tie Blue"},{"trait_type":"Face","value":"Pipe"},{"trait_type":"Eye","value":"Eye"}] */
            metadata_attributes: string;
            /** @example 14265936 */
            block_number_minted: string;
            /** @example null */
            opensea_lookup?: {
                [key: string]: unknown;
            };
            /** @example 0xdcf086e3f7954b38180daae1405569da86588bfe */
            minter_address: string;
            /** @example 0x2c8d7ec7a8439b0f67b50e93be63242de52e9b5cdfc7dc0aee80c6a2f104c41a */
            transaction_minted: string;
            /** @example null */
            frozen_log_index?: {
                [key: string]: unknown;
            };
            /** @example null */
            imported?: {
                [key: string]: unknown;
            };
            /**
             * @description When the token_uri was last updated
             * @example 2021-02-24T00:47:26.647Z
             */
            last_token_uri_sync: string;
            /**
             * @description When the metadata was last updated
             * @example 2021-02-24T00:47:26.647Z
             */
            last_metadata_sync: string;
            /**
             * Format: date-time
             * @example 2022-02-24T00:47:26.647Z
             */
            createdAt: string;
            /**
             * Format: date-time
             * @example 2022-04-09T23:56:44.807Z
             */
            updatedAt: string;
            /**
             * @description Indicates if a contract is possibly a spam contract
             * @example false
             */
            possible_spam: boolean;
        };
        nftWalletCollections: {
            /**
             * @description The syncing status of the address [SYNCING/SYNCED]
             * @example SYNCING
             */
            status?: string;
            /**
             * @description The total number of matches for this query
             * @example 2000
             */
            total?: number;
            /**
             * @description The current page of the result
             * @example 2
             */
            page?: number;
            /**
             * @description The number of results per page
             * @example 100
             */
            page_size?: number;
            /** @description The cursor to get to the next page */
            cursor?: string;
            result?: components["schemas"]["nftCollections"][];
        };
        nftCollection: {
            /**
             * @description The total number of matches for this query
             * @example 2000
             */
            total?: number;
            /**
             * @description The current page of the result
             * @example 2
             */
            page?: number;
            /**
             * @description The number of results per page
             * @example 100
             */
            page_size?: number;
            /** @description The cursor to get to the next page */
            cursor?: string;
            result?: components["schemas"]["nft"][];
        };
        nftMetadataCollection: {
            /**
             * @description The total number of matches for this query
             * @example 2000
             */
            total?: number;
            /**
             * @description The current page of the result
             * @example 2
             */
            page?: number;
            /**
             * @description The number of results per page
             * @example 100
             */
            page_size?: number;
            result?: components["schemas"]["nftMetadata"][];
        };
        nftCollections: {
            /**
             * @description The address of the NFT contract
             * @example 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB
             */
            token_address: string;
            /**
             * @description The type of NFT contract standard
             * @example ERC721
             */
            contract_type: string;
            /**
             * @description The name of the NFT contract
             * @example CryptoKitties
             */
            name: string;
            /**
             * @description The symbol of the NFT contract
             * @example RARI
             */
            symbol: string;
        };
        nftOwner: {
            /**
             * @description The address of the NFT contract
             * @example 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB
             */
            token_address: string;
            /**
             * @description The token ID of the NFT
             * @example 15
             */
            token_id: string;
            /**
             * @description The type of NFT contract standard
             * @example ERC721
             */
            contract_type: string;
            /**
             * @description The wallet address of the owner of the NFT
             * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
             */
            owner_of: string;
            /**
             * @description The block number when the amount or owner changed
             * @example 88256
             */
            block_number: string;
            /**
             * @description The block number when the NFT was minted
             * @example 88256
             */
            block_number_minted: string;
            /** @description The URI to the metadata of the token */
            token_uri?: string;
            /** @description The metadata of the token */
            metadata?: string;
            /** @description A normalized metadata version of the NFT's metadata. */
            normalized_metadata?: components["schemas"]["normalizedMetadata"];
            /** @description A set of links to 'thumbnail / preview' media files */
            media?: components["schemas"]["media"];
            /**
             * @description The number of this item the user owns (used by ERC1155)
             * @example 1
             */
            amount?: string;
            /**
             * @description The name of the NFT contract
             * @example CryptoKitties
             */
            name: string;
            /**
             * @description The symbol of the NFT contract
             * @example RARI
             */
            symbol: string;
            /**
             * @description The token hash
             * @example 502cee781b0fb40ea02508b21d319ced
             */
            token_hash: string;
            /**
             * @description When the token_uri was last updated
             * @example 2021-02-24T00:47:26.647Z
             */
            last_token_uri_sync: string;
            /**
             * @description When the metadata was last updated
             * @example 2021-02-24T00:47:26.647Z
             */
            last_metadata_sync: string;
            /**
             * @description Indicates if a contract is possibly a spam contract
             * @example false
             */
            possible_spam: boolean;
        };
        normalizedMetadataAttribute: {
            /**
             * @description The trait title or descriptor
             * @example Eye Color
             */
            trait_type?: string;
            /**
             * @description The value of the attribute
             * @example hazel
             */
            value?: {
                [key: string]: unknown;
            };
            /**
             * @description The type the attribute value should be displayed as
             * @example string
             */
            display_type?: string;
            /**
             * @description For numeric values, the upper range
             * @example 100
             */
            max_value?: number;
            /**
             * @description The number of possible values for this trait
             * @example 7
             */
            trait_count?: number;
            /**
             * @description Order the trait should appear in the attribute list.
             * @example 1
             */
            order?: number;
        };
        normalizedMetadata: {
            /**
             * @description The name or title of the NFT
             * @example Moralis Mug
             */
            name?: string;
            /**
             * @description A detailed description of the NFT
             * @example Moralis Coffee nug 3D Asset that can be used in 3D worldspaces. This NFT is presented as a flat PNG, a Unity3D Prefab and a standard fbx.
             */
            description?: string;
            /**
             * @description The URL of the NFT's image
             * @example https://arw2wxg84h6b.moralishost.com:2053/server/files/tNJatzsHirx4V2VAep6sc923OYGxvkpBeJttR7Ks/de504bbadadcbe30c86278342fcf2560_moralismug.png
             */
            image?: string;
            /**
             * @description A link to additional information
             * @example https://giphy.com/gifs/loop-recursion-ting-aaODAv1iuQdgI
             */
            external_link?: string;
            /**
             * @description An animated version of the NFT's image
             * @example https://giphy.com/gifs/food-design-donuts-o9ngTPVYW4qo8
             */
            animation_url?: string;
            attributes?: components["schemas"]["normalizedMetadataAttribute"][];
        };
        mediaItem: {
            /** @description The width of the preview image. */
            width: number;
            /** @description The height of the preview image. */
            height: number;
            /** @description The url of the preview file. */
            url: string;
        };
        mediaCollection: {
            /** @description Preview media file, lowest quality (for images 100px x 100px) */
            low: components["schemas"]["mediaItem"];
            /** @description Preview media file, medium quality (for images 250px x 250px) */
            medium: components["schemas"]["mediaItem"];
            /** @description Preview media file, highest quality (for images 500px x 500px) */
            high: components["schemas"]["mediaItem"];
        } & {
            original: unknown;
        };
        media: {
            /** @description The mimetype of the media file [see https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types] */
            mimetype?: string;
            /** @enum {undefined} */
            category?: "image" | "audio" | "video";
            /**
             * @description <table><tr><td>success</td><td>The NFT Preview was created / retrieved successfully</td></tr><tr><td>processing</td><td>The NFT Preview was not found and has been submitted for generation.</td></tr><tr><td>unsupported_media</td><td>The mime-type of the NFT's media file indicates a type not currently supported.</td></tr><tr><td>invalid_url</td><td>The 'image' URL from the NFT's metadata is not a valid URL and cannot be processed.</td></tr><tr><td>host_unavailable</td><td>The 'image' URL from the NFT's metadata returned an HttpCode indicating the host / file is not available.</td></tr><tr><td>temporarily_unavailable</td><td>The attempt to load / parse the NFT media file failed (usually due to rate limiting) and will be tried again at next request.</td></tr></table>
             * @enum {undefined}
             */
            status?: "success" | "processing" | "unsupported_media" | "invalid_url" | "host_unavailable" | "temporarily_unavailable";
            /** @description The url of the original media file. */
            original_media_url?: string;
            /** @description The timestamp of the last update to this NFT media record. */
            updatedAt?: string;
            /** @description Hash value of the original media file. */
            parent_hash?: string;
            /** @description Preview item associated with the original */
            media_collection?: components["schemas"]["mediaCollection"];
        };
        nftOwnerCollection: {
            /**
             * @description The syncing status of the address [SYNCING/SYNCED]
             * @example SYNCING
             */
            status?: string;
            /**
             * @description The total number of matches for this query
             * @example 2000
             */
            total?: number;
            /**
             * @description The current page of the result
             * @example 2
             */
            page?: number;
            /**
             * @description The number of results per page
             * @example 100
             */
            page_size?: number;
            /** @description The cursor to get to the next page */
            cursor?: string;
            result?: components["schemas"]["nftOwner"][];
        };
        nftTransfer: {
            /**
             * @description The address of the NFT contract
             * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
             */
            token_address: string;
            /**
             * @description The token ID of the NFT
             * @example 15
             */
            token_id: string;
            /**
             * @description The address that sent the NFT
             * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
             */
            from_address?: string;
            /**
             * @description The address that received the NFT
             * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
             */
            to_address: string;
            /**
             * @description The value that was sent in the transaction (ETH/BNB/etc..)
             * @example 1000000000000000
             */
            value?: string;
            /**
             * @description The number of tokens transferred
             * @example 1
             */
            amount?: string;
            /**
             * @description The type of NFT contract standard
             * @example ERC721
             */
            contract_type: string;
            /**
             * @description The block number of the transaction
             * @example 88256
             */
            block_number: string;
            /**
             * @description The block timestamp
             * @example 2021-06-04T16:00:15
             */
            block_timestamp: string;
            /** @description The block hash of the transaction */
            block_hash: string;
            /**
             * @description The transaction hash
             * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
             */
            transaction_hash: string;
            /** @description The transaction type */
            transaction_type?: string;
            /** @description The transaction index */
            transaction_index?: number;
            /** @description The log index */
            log_index: number;
            /**
             * @description The operator present only for ERC1155 transfers
             * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
             */
            operator?: string;
            /**
             * @description Indicates if a contract is possibly a spam contract
             * @example false
             */
            possible_spam: boolean;
        };
        nftTransferCollection: {
            /**
             * @description The total number of matches for this query
             * @example 2000
             */
            total: number;
            /**
             * @description The current page of the result
             * @example 2
             */
            page: number;
            /**
             * @description The number of results per page
             * @example 100
             */
            page_size: number;
            /** @description The cursor to get to the next page */
            cursor: string;
            result: components["schemas"]["nftTransfer"][];
            /**
             * @description Indicator if the block exists
             * @example true
             */
            block_exists?: boolean;
            /**
             * @description Indicator if the block is fully indexed
             * @example true
             */
            index_complete?: boolean;
        };
        nftContractMetadata: {
            /**
             * @description The address of the token contract
             * @example 0x2d30ca6f024dbc1307ac8a1a44ca27de6f797ec22ef20627a1307243b0ab7d09
             */
            token_address: string;
            /**
             * @description The name of the token contract
             * @example KryptoKitties
             */
            name: string;
            /** @description Timestamp of when the contract was last synced with the node */
            synced_at?: string;
            /**
             * @description The symbol of the NFT contract
             * @example RARI
             */
            symbol: string;
            /**
             * @description The type of NFT contract
             * @example ERC721
             */
            contract_type: string;
        };
        nftContractMetadataCollection: {
            /**
             * @description The total number of matches for this query
             * @example 2000
             */
            total: number;
            /**
             * @description The current page of the result
             * @example 2
             */
            page: number;
            /**
             * @description The number of results per page
             * @example 100
             */
            page_size: number;
            result: components["schemas"]["nftContractMetadata"][];
        };
        erc20Transaction: {
            /** @example Tether USD */
            token_name: string;
            /** @example USDT */
            token_symbol: string;
            /** @example https://assets.coingecko.com/coins/images/325/large/Tether-logo.png?1598003707 */
            token_logo?: string;
            /** @example 6 */
            token_decimals: string;
            /**
             * @description The transaction hash
             * @example 0x2d30ca6f024dbc1307ac8a1a44ca27de6f797ec22ef20627a1307243b0ab7d09
             */
            transaction_hash: string;
            /**
             * @description The address of the token
             * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
             */
            address: string;
            /**
             * @description The block timestamp
             * @example 2021-04-02T10:07:54.000Z
             */
            block_timestamp: string;
            /**
             * @description The block number
             * @example 12526958
             */
            block_number: string;
            /**
             * @description The block hash
             * @example 0x0372c302e3c52e8f2e15d155e2c545e6d802e479236564af052759253b20fd86
             */
            block_hash: string;
            /**
             * @description The recipient
             * @example 0x62AED87d21Ad0F3cdE4D147Fdcc9245401Af0044
             */
            to_address: string;
            /**
             * @description The sender
             * @example 0xd4a3BebD824189481FC45363602b83C9c7e9cbDf
             */
            from_address: string;
            /**
             * @description The value that was transfered (in wei)
             * @example 650000000000000000
             */
            value: string;
            /**
             * @description The transaction index of the transfer within the block
             * @example 12
             */
            transaction_index: number;
            /**
             * @description The log index of the transfer within the block
             * @example 2
             */
            log_index: number;
            /**
             * @description Indicates if a contract is possibly a spam contract
             * @example false
             */
            possible_spam: boolean;
        } & {
            value_decimal: unknown;
        };
        historicalNftTransfer: {
            /**
             * @description The transaction hash
             * @example 0x2d30ca6f024dbc1307ac8a1a44ca27de6f797ec22ef20627a1307243b0ab7d09
             */
            transaction_hash: string;
            /**
             * @description The address of the token
             * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
             */
            address: string;
            /**
             * @description The block timestamp
             * @example 2021-04-02T10:07:54.000Z
             */
            block_timestamp: string;
            /**
             * @description The block number
             * @example 12526958
             */
            block_number: string;
            /**
             * @description The block hash
             * @example 0x0372c302e3c52e8f2e15d155e2c545e6d802e479236564af052759253b20fd86
             */
            block_hash: string;
            /**
             * @description The recipient
             * @example 0x62AED87d21Ad0F3cdE4D147Fdcc9245401Af0044
             */
            to_address: string;
            /**
             * @description The sender
             * @example 0xd4a3BebD824189481FC45363602b83C9c7e9cbDf
             */
            from_address: string;
            /** @description The token ids of the tokens that were transferred */
            token_ids: string[];
            /** @description The amounts that were transferred */
            amounts: string[];
            /**
             * @description They contract type of the transfer
             * @example ERC721
             */
            contract_type: string;
        };
        erc20Metadata: {
            /**
             * @description The address of the token contract
             * @example 0x2d30ca6f024dbc1307ac8a1a44ca27de6f797ec22ef20627a1307243b0ab7d09
             */
            address: string;
            /**
             * @description The name of the token contract
             * @example Kylin Network
             */
            name: string;
            /**
             * @description The symbol of the NFT contract
             * @example KYL
             */
            symbol: string;
            /**
             * @description The number of decimals on the token
             * @example 18
             */
            decimals: string;
            /**
             * @description The logo of the token
             * @example https://cdn.moralis.io/eth/0x67b6d479c7bb412c54e03dca8e1bc6740ce6b99c.png
             */
            logo?: string;
            /**
             * @description The logo hash
             * @example ee7aa2cdf100649a3521a082116258e862e6971261a39b5cd4e4354fcccbc54d
             */
            logo_hash?: string;
            /**
             * @description The thumbnail of the logo
             * @example https://cdn.moralis.io/eth/0x67b6d479c7bb412c54e03dca8e1bc6740ce6b99c_thumb.png
             */
            thumbnail?: string;
            block_number?: string;
            validated?: string;
            /**
             * @description Indicates if a contract is possibly a spam contract
             * @example false
             */
            possible_spam: boolean;
        };
        metadataResync: {
            /** @description The status of the resync request */
            status: string;
        };
        erc721Metadata: {
            /**
             * @description The name of the token contract
             * @example Kylin Network
             */
            name: string;
            /**
             * @description The symbol of the NFT contract
             * @example KYL
             */
            symbol: string;
            token_uri?: string;
        };
        erc20Price: {
            /**
             * @description The name of the token
             * @example Kylin Network
             */
            tokenName?: string;
            /**
             * @description The symbol of the token
             * @example KYL
             */
            tokenSymbol?: string;
            /**
             * @description The logo of the token
             * @example https://cdn.moralis.io/eth/0x67b6d479c7bb412c54e03dca8e1bc6740ce6b99c.png
             */
            tokenLogo?: string;
            /**
             * @description The number of decimals of the token
             * @example 18
             */
            tokenDecimals?: string;
            nativePrice?: components["schemas"]["nativeErc20Price"];
            /**
             * Format: double
             * @description The price in USD for the token
             * @example 19.722370676
             */
            usdPrice: number;
            /**
             * @description The address of the exchange used to calculate the price
             * @example 0x1f98431c8ad98523631ae4a59f267346ea31f984
             */
            exchangeAddress?: string;
            /**
             * @description The name of the exchange used to calculate the price
             * @example Uniswap v3
             */
            exchangeName?: string;
            /**
             * @description The address of the token
             * @example 0x67b6d479c7bb412c54e03dca8e1bc6740ce6b99c
             */
            tokenAddress?: string;
        };
        nativeErc20Price: {
            /**
             * @description The native price of the token
             * @example 8409770570506626
             */
            value: string;
            /**
             * @description The number of decimals on the token
             * @example 18
             */
            decimals: number;
            /**
             * @description The name of the token
             * @example Ether
             */
            name: string;
            /**
             * @description The symbol of the token
             * @example ETH
             */
            symbol: string;
            /** @description The address of the native token */
            address: string;
        };
        erc20TransactionCollection: {
            /**
             * @description The total number of matches for this query
             * @example 2000
             */
            total?: number;
            /**
             * @description The current page of the result
             * @example 2
             */
            page?: number;
            /**
             * @description The number of results per page
             * @example 100
             */
            page_size?: number;
            result?: components["schemas"]["erc20Transaction"][];
        };
        ens: {
            /**
             * @description Resolved ENS address
             * @example Vitalik.eth
             */
            name: string;
        };
        resolve: {
            /**
             * @description Resolved domain address
             * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
             */
            address: string;
        };
        reservesPair: {
            /** @example 220969226548536862025877 */
            reserve0?: string;
            /** @example 844810441191293211036 */
            reserve1?: string;
        };
        reservesCollection: {
            token0?: {
                /** @example 0x2b591e99afe9f32eaa6214f7b7629768c40eeb39 */
                address?: string;
                /** @example HEX */
                name?: string;
                /** @example HEX */
                symbol?: string;
                /** @example 9 */
                decimals?: string;
                /** @example https://cdn.moralis.io/eth/0x2b591e99afe9f32eaa6214f7b7629768c40eeb39.png */
                logo?: string;
                /** @example b3bd1b5512965d7b6aeee903dcc6d28b116d58c788eb41e9c1690baed878beaa */
                logo_hash?: string;
                /** @example https://cdn.moralis.io/eth/0x2b591e99afe9f32eaa6214f7b7629768c40eeb39_thumb.png */
                thumbnail?: string;
                /** @example 14836562 */
                block_number?: string;
                /** @example 0 */
                validated?: number;
                /** @example 2022-01-20T09:39:55.818Z */
                created_at?: string;
            };
            token1?: {
                /** @example 0xdac17f958d2ee523a2206206994597c13d831ec7 */
                address?: string;
                /** @example Tether USD */
                name?: string;
                /** @example USDT */
                symbol?: string;
                /** @example 6 */
                decimals?: string;
                /** @example https://cdn.moralis.io/eth/0xdac17f958d2ee523a2206206994597c13d831ec7.png */
                logo?: string;
                /** @example ee7aa2cdf100649a3521a082116258e862e6971261a39b5cd4e4354fcccbc54d */
                logo_hash?: string;
                /** @example https://cdn.moralis.io/eth/0xdac17f958d2ee523a2206206994597c13d831ec7_thumb.png */
                thumbnail?: string;
                /** @example 4638568 */
                block_number?: string;
                /** @example 1 */
                validated?: number;
                /** @example 2022-01-20T09:39:55.818Z */
                created_at?: string;
            };
            /** @example 0xbbb9bf440d0f686487925fef3b0a0f9aa67753f6 */
            pairAddress?: string;
        };
        ipfsFileRequest: {
            /**
             * @description Path to the file
             * @example moralis/logo.jpg
             */
            path: string;
            /**
             * @description Base64 or JSON
             * @example iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAApgAAAKYB3X3
             */
            content: string;
        };
        ipfsFile: {
            /**
             * @description Path to the file
             * @example https://ipfs.moralis.io/QmPQ3YJ3hgfsBzJ1U4MGyV2C1GhDy6MWCENr1qMdMpKVnY/moralis/logo.jpg
             */
            path: string;
        };
        web3version: {
            /**
             * @description The version of the API
             * @example 1.0.0
             */
            version: string;
        };
        endpointWeights: {
            /**
             * @description endpoint
             * @example endpointWeights
             */
            endpoint: string;
            /**
             * @description The path to the endpoint
             * @example /info/endpointWeights
             */
            path: string;
            /**
             * @description The number of hits the request counts towards rate limiting
             * @example 1
             */
            rateLimitCost: string;
            /**
             * @description The number of compute units the request counts towards billing
             * @example 0
             */
            price: string;
        };
        marketDataERC20Token: {
            /**
             * @description The rank
             * @example 1
             */
            rank: number;
            /**
             * @description The token name
             * @example Wrapped Ether
             */
            token_name: string;
            /**
             * @description The token symbol
             * @example WETH
             */
            token_symbol: string;
            /**
             * @description The token image
             * @example https://assets.coingecko.com/coins/images/2518/large/weth.png?1595348880
             */
            token_logo: string;
            /**
             * @description The token decimals
             * @example 18
             */
            token_decimals: string;
            /**
             * @description The contract address
             * @example 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
             */
            contract_address: string;
            /**
             * @description The price in USD
             * @example 0.0285
             */
            price_usd: string;
            /**
             * @description The price change in the last 24h
             * @example 0.0285
             */
            price_24h_percent_change: string;
            /**
             * @description The price change in the last 7d
             * @example 0.0285
             */
            price_7d_percent_change: string;
            /**
             * @description The market cap in USD
             * @example 0.0285
             */
            market_cap_usd: string;
        }[];
        marketDataERC20TokensByPriceMovers: {
            gainers: components["schemas"]["marketDataERC20Token"];
            losers: components["schemas"]["marketDataERC20Token"];
        };
        marketDataTopNFTCollectionByMarketCap: {
            /**
             * @description The rank
             * @example 1
             */
            rank: number;
            /**
             * @description The collection title
             * @example CryptoPunks
             */
            collection_title: string;
            /**
             * @description The collection image
             * @example
             */
            collection_image: string;
            /**
             * @description The floor price in USD
             * @example 0.0
             */
            floor_price_usd: string;
            /**
             * @description The floor price 24hr percent change
             * @example 0.0
             */
            floor_price_24hr_percent_change: string;
            /**
             * @description The market cap in USD
             * @example 0.0
             */
            market_cap_usd: string;
            /**
             * @description The market cap 24hr percent change
             * @example 0.0
             */
            market_cap_24hr_percent_change: string;
            /**
             * @description The volume in USD
             * @example 0.0
             */
            volume_usd: string;
            /**
             * @description The volume 24hr percent change
             * @example 0.0
             */
            volume_24hr_percent_change: string;
        }[];
        marketDataHottestNFTCollectionByTradingVolume: ({
            /**
             * @description The rank
             * @example 1
             */
            rank: number;
            /**
             * @description The collection title
             * @example CryptoPunks
             */
            collection_title: string;
            /**
             * @description The collection image
             * @example
             */
            collection_image: string;
            /**
             * @description The floor price in USD
             * @example 0.0
             */
            floor_price_usd: string;
            /**
             * @description The floor price 24hr percent change
             * @example 0.0
             */
            floor_price_24hr_percent_change: string;
            /**
             * @description The volume in USD
             * @example 0.0
             */
            volume_usd: string;
            /**
             * @description The volume 24hr percent change
             * @example 0.0
             */
            volume_24hr_percent_change: string;
            /**
             * @description The average price in USD
             * @example 0.0
             */
            average_price_usd?: string;
        } & {
            market_cap_usd: unknown;
            market_cap_24hr_percent_change: unknown;
        })[];
        nativeBalances: {
            /**
             * @description The chain
             * @example eth_mainnet
             */
            chain: string;
            /**
             * @description The chain id
             * @example 2
             */
            chain_id: string;
            /**
             * @description The total balances for all the walttes
             * @example 57499206466583095
             */
            total_balance: string;
            /**
             * @description The block Number
             * @example 123456789
             */
            block_number: string;
            /**
             * @description The block timestamp
             * @example 0.057
             */
            block_timestamp: string;
            /**
             * @description The total balances for all the walttes formatted
             * @example 123456789
             */
            total_balance_formatted: string;
            wallet_balances: {
                /**
                 * @description address
                 * @example 0x123
                 */
                address: string;
                /**
                 * @description balance
                 * @example 28499206466583095
                 */
                balance: string;
                /**
                 * @description balance formatted
                 * @example 0.0285
                 */
                balance_formatted: string;
            }[];
        }[];
        contractsReviewItem: {
            /**
             * @description The contract address
             * @example 0x06012c8cf97bead5deae237070f9587f8e7a266d
             */
            contract_address: string;
            /**
             * @description The reason for the contract being spam
             * @example 100
             */
            reason: string;
            /**
             * @description This can be spam or not_spam
             * @example spam
             * @enum {enum}
             */
            report_type: "spam" | "not_spam";
            /**
             * @description This can be ERC20, or NFT
             * @example ERC20
             * @enum {enum}
             */
            contract_type: "ERC20" | "NFT";
        };
        ContractsReviewDto: {
            /**
             * @description The contracts to be reported
             * @example [
             *   {
             *     "contract_address": "0xa4991609c508b6d4fb7156426db0bd49fe298bd8",
             *     "report_type": "spam",
             *     "contract_type": "ERC20",
             *     "reason": "The contract contains shady code"
             *   }
             * ]
             */
            contracts: components["schemas"]["contractsReviewItem"][];
        };
    };
}
interface operations$1 {
    /**
     * Get NFTs owned by a given address.
     * * The response will include status [SYNCED/SYNCING] based on the contracts being indexed.
     * * Use the token_address param to get results for a specific contract only
     * * Note that results will include all indexed NFTs
     * * Any request that includes the token_address param will start the indexing process for that NFT collection the very first time it is requested.
     */
    getWalletNFTs: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The format of the token ID */
                format?: "decimal" | "hex";
                /** The desired page size of the result. */
                limit?: number;
                /** If the result should skip returning the total count (Improves performance). */
                disable_total?: boolean;
                /** The addresses to get balances for (optional) */
                token_addresses?: string[];
                /** The cursor returned in the previous response (used for getting the next page). */
                cursor?: string;
                /** Should normalized metadata be returned? */
                normalizeMetadata?: boolean;
                /** Should preview media data be returned? */
                media_items?: boolean;
            };
            path: {
                /** The address of the wallet */
                address: string;
            };
        };
        responses: {
            /** Returns a collection of NFT owners */
            200: {
                content: {
                    "application/json": components["schemas"]["nftOwnerCollection"];
                };
            };
        };
    };
    /**
     * Returns an array of NFTs specified in the request.
     * * Note that results will include all indexed NFTs
     * * Any request that includes the token_address param will start the indexing process for that NFT collection the very first time it is requested.
     * * Only 25 NFTs can be fetched in one API call.
     */
    getMultipleNFTs: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
            };
        };
        responses: {
            /** Returns a collection of NFT owners */
            200: {
                content: {
                    "application/json": components["schemas"]["nftOwner"][];
                };
            };
        };
        /** Body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["GetMultipleNftsDto"];
            };
        };
    };
    /** Get transfers of NFTs given the wallet and other parameters. */
    getWalletNFTTransfers: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The format of the token ID */
                format?: "decimal" | "hex";
                /** The transfer direction */
                direction?: "both" | "to" | "from";
                /**
                 * The minimum block number from which to get the transfers
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 */
                from_block?: number;
                /** To get the reserves at this block number */
                to_block?: string;
                /**
                 * The date from where to get the transfers (any format that is accepted by momentjs)
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 */
                from_date?: string;
                /**
                 * Get transfers up until this date (any format that is accepted by momentjs)
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 */
                to_date?: string;
                /** The desired page size of the result. */
                limit?: number;
                /** If the result should skip returning the total count (Improves performance). */
                disable_total?: boolean;
                /** The cursor returned in the previous response (used for getting the next page). */
                cursor?: string;
            };
            path: {
                /** The wallet address of the sender or recipient of the transfers */
                address: string;
            };
        };
        responses: {
            /** Returns a collection of NFT transfers */
            200: {
                content: {
                    "application/json": components["schemas"]["nftTransferCollection"];
                };
            };
        };
    };
    /** Get NFT collections owned by a given wallet address. */
    getWalletNFTCollections: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The desired page size of the result. */
                limit?: number;
                /** If the result should skip returning the total count (Improves performance). */
                disable_total?: boolean;
                /** The cursor returned in the previous response (used for getting the next page). */
                cursor?: string;
            };
            path: {
                /** The wallet address of the owner of NFTs in the collections */
                address: string;
            };
        };
        responses: {
            /** Returns the NFT collections owned by a wallet */
            200: {
                content: {
                    "application/json": components["schemas"]["nftWalletCollections"];
                };
            };
        };
    };
    /**
     * Get NFTs for a given contract address, including metadata for all NFTs (where available).
     * * Results are limited to 100 per page by default
     * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection.
     */
    getContractNFTs: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The format of the token ID */
                format?: "decimal" | "hex";
                /** The desired page size of the result. */
                limit?: number;
                /** If the result should skip returning the total count (Improves performance). */
                disable_total?: boolean;
                /** The number of subranges to split the results into */
                totalRanges?: number;
                /** The desired subrange to query */
                range?: number;
                /** The cursor returned in the previous response (used for getting the next page). */
                cursor?: string;
                /** Should normalized metadata be returned? */
                normalizeMetadata?: boolean;
                /** Should preview media data be returned? */
                media_items?: boolean;
            };
            path: {
                /** The address of the NFT contract */
                address: string;
            };
        };
        responses: {
            /** Returns a collection of NFTs */
            200: {
                content: {
                    "application/json": components["schemas"]["nftCollection"];
                };
            };
        };
    };
    /**
     * Get owners of NFTs for a given contract.
     * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection.
     */
    getNFTOwners: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The format of the token ID */
                format?: "decimal" | "hex";
                /** The desired page size of the result. */
                limit?: number;
                /** If the result should skip returning the total count (Improves performance). */
                disable_total?: boolean;
                /** The cursor returned in the previous response (used for getting the next page). */
                cursor?: string;
                /** Should normalized metadata be returned? */
                normalizeMetadata?: boolean;
                /** Should preview media data be returned? */
                media_items?: boolean;
            };
            path: {
                /** The address of the NFT contract */
                address: string;
            };
        };
        responses: {
            /** Returns a collection of NFT owners */
            200: {
                content: {
                    "application/json": components["schemas"]["nftOwnerCollection"];
                };
            };
        };
    };
    /** Get transfers of NFTs for a given contract and other parameters. */
    getNFTContractTransfers: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /**
                 * The minimum block number from where to get the transfers
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 */
                from_block?: number;
                /**
                 * The maximum block number from where to get the transfers.
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 */
                to_block?: number;
                /**
                 * The date from where to get the transfers (any format that is accepted by momentjs)
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 */
                from_date?: string;
                /**
                 * Get transfers up until this date (any format that is accepted by momentjs)
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 */
                to_date?: string;
                /** The format of the token ID */
                format?: "decimal" | "hex";
                /** The desired page size of the result. */
                limit?: number;
                /** If the result should skip returning the total count (Improves performance). */
                disable_total?: boolean;
                /** The cursor returned in the previous response (used for getting the next page). */
                cursor?: string;
            };
            path: {
                /** The address of the NFT contract */
                address: string;
            };
        };
        responses: {
            /** Returns a collection of NFT transfers */
            200: {
                content: {
                    "application/json": components["schemas"]["nftTransferCollection"];
                };
            };
        };
    };
    /** Get transfers of NFTs from a block number to a block number. */
    getNFTTransfersFromToBlock: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /**
                 * The minimum block number from which to get the transfers
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 */
                from_block?: number;
                /**
                 * The maximum block number from which to get the transfers.
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 */
                to_block?: number;
                /**
                 * The start date from which to get the transfers (any format that is accepted by momentjs)
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 */
                from_date?: string;
                /**
                 * The end date from which to get the transfers (any format that is accepted by momentjs)
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 */
                to_date?: string;
                /** The format of the token ID */
                format?: "decimal" | "hex";
                /** The desired page size of the result. */
                limit?: number;
                /** If the result should skip returning the total count (Improves performance). */
                disable_total?: boolean;
                /** The cursor returned in the previous response (for getting the next page) */
                cursor?: string;
            };
        };
        responses: {
            /** Returns a collection of NFT transfers */
            200: {
                content: {
                    "application/json": components["schemas"]["nftTransferCollection"];
                };
            };
        };
    };
    /** Get transfers of NFTs given a block number or block hash. */
    getNFTTransfersByBlock: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The desired page size of the result. */
                limit?: number;
                /** If the result should skip returning the total count (Improves performance). */
                disable_total?: boolean;
                /** The cursor returned in the previous response (used for getting the next page). */
                cursor?: string;
            };
            path: {
                /** The block number or block hash */
                block_number_or_hash: string;
            };
        };
        responses: {
            /** Returns the contents of a block */
            200: {
                content: {
                    "application/json": components["schemas"]["nftTransferCollection"];
                };
            };
        };
    };
    /** Get trades of NFTs for a given contract and marketplace. */
    getNFTTrades: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /**
                 * The minimum block number from which to get the transfers
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 */
                from_block?: number;
                /** The block number to get the trades from */
                to_block?: string;
                /**
                 * The start date from which to get the transfers (any format that is accepted by momentjs)
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 */
                from_date?: string;
                /**
                 * The end date from which to get the transfers (any format that is accepted by momentjs)
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 */
                to_date?: string;
                /** Marketplace from which to get the trades (only OpenSea is supported at the moment) */
                marketplace?: "opensea";
                /** The cursor returned in the previous response (used for getting the next page). */
                cursor?: string;
                /** The desired page size of the result. */
                limit?: number;
                /** If the result should skip returning the total count (Improves performance). */
                disable_total?: boolean;
            };
            path: {
                /** The address of the NFT contract */
                address: string;
            };
        };
        responses: {
            /** Returns the trades */
            200: {
                content: {
                    "application/json": components["schemas"]["tradeCollection"];
                };
            };
        };
    };
    /**
     * Get the collection / contract level metadata for a given contract (name, symbol, base token URI).
     * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
     */
    getNFTContractMetadata: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
            };
            path: {
                /** The address of the NFT contract */
                address: string;
            };
        };
        responses: {
            /** Returns the metadata for an NFT collection. */
            200: {
                content: {
                    "application/json": components["schemas"]["nftContractMetadata"];
                };
            };
        };
    };
    /**
     * Get NFT data, including metadata (where available), for the given NFT token ID and contract address.
     * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
     */
    getNFTMetadata: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The format of the token ID */
                format?: "decimal" | "hex";
                /** Should normalized metadata be returned? */
                normalizeMetadata?: boolean;
                /** Should preview media data be returned? */
                media_items?: boolean;
            };
            path: {
                /** The address of the NFT contract */
                address: string;
                /** The ID of the token */
                token_id: string;
            };
        };
        responses: {
            /** Returns the specified NFT. */
            200: {
                content: {
                    "application/json": components["schemas"]["nft"];
                };
            };
        };
    };
    /** Get transfers of an NFT given a contract address and token ID. */
    getNFTTransfers: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The format of the token ID */
                format?: "decimal" | "hex";
                /** The desired page size of the result. */
                limit?: number;
                /** If the result should skip returning the total count (Improves performance). */
                disable_total?: boolean;
                /** The cursor returned in the previous response (used for getting the next page). */
                cursor?: string;
            };
            path: {
                /** The address of the NFT contract */
                address: string;
                /** The ID of the token */
                token_id: string;
            };
        };
        responses: {
            /** Returns a collection of NFT transfers */
            200: {
                content: {
                    "application/json": components["schemas"]["nftTransferCollection"];
                };
            };
        };
    };
    /**
     * Get owners of a specific NFT given the contract address and token ID.
     * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
     */
    getNFTTokenIdOwners: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The format of the token ID */
                format?: "decimal" | "hex";
                /** The desired page size of the result. */
                limit?: number;
                /** If the result should skip returning the total count (Improves performance). */
                disable_total?: boolean;
                /** The cursor returned in the previous response (used for getting the next page). */
                cursor?: string;
                /** Should normalized metadata be returned? */
                normalizeMetadata?: boolean;
                /** Should preview media data be returned? */
                media_items?: boolean;
            };
            path: {
                /** The address of the NFT contract */
                address: string;
                /** The ID of the token */
                token_id: string;
            };
        };
        responses: {
            /** Returns a collection of NFTs with their respective owners. */
            200: {
                content: {
                    "application/json": components["schemas"]["nftOwnerCollection"];
                };
            };
        };
    };
    /** Initiates a sync of a previously non synced contract. */
    syncNFTContract: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
            };
            path: {
                /** The address of the NFT contract */
                address: string;
            };
        };
        responses: {
            /** Contract address was triggered for index. */
            201: unknown;
        };
    };
    /**
     * Resync the metadata for an NFT
     * * The metadata flag will request the NFT's metadata from an already existing token_uri
     * * The uri (default) flag will fetch the latest token_uri from the given NFT contract address. In sync mode the metadata will also be fetched
     * * The sync mode will make the endpoint synchronous so it will wait for the task to be completed before responding
     * * The async mode (default) will make the endpoint asynchronous so we will wait for the task to be completed before responding
     */
    reSyncMetadata: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The type of resync to operate */
                flag?: "uri" | "metadata";
                /** To define the behaviour of the endpoint */
                mode?: "async" | "sync";
            };
            path: {
                /** The address of the NFT contract */
                address: string;
                /** The ID of the token */
                token_id: string;
            };
        };
        responses: {
            /** (In sync mode) Resync request executed. */
            200: {
                content: {
                    "application/json": components["schemas"]["metadataResync"];
                };
            };
            /** The resync request was received and will be executed. */
            202: {
                content: {
                    "application/json": components["schemas"]["metadataResync"];
                };
            };
            /** (In sync mode) Resync request executed and metadata could not be updated. */
            404: {
                content: {
                    "application/json": components["schemas"]["metadataResync"];
                };
            };
        };
    };
    /** Get the lowest executed price for an NFT contract for the last x days (only trades paid in ETH). */
    getNFTLowestPrice: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /**
                 * The number of days to look back to find the lowest price
                 * If not provided 7 days will be the default
                 */
                days?: number;
                /** Marketplace from which to get the trades (only OpenSea is supported at the moment) */
                marketplace?: "opensea";
            };
            path: {
                /** The address of the NFT contract */
                address: string;
            };
        };
        responses: {
            /** Returns the trade with the lowest price */
            200: {
                content: {
                    "application/json": components["schemas"]["trade"];
                };
            };
        };
    };
    /** Get NFTs that match a given metadata search query. */
    searchNFTs: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The format of the token ID */
                format?: "decimal" | "hex";
                /** The search string */
                q: string;
                /** What fields the search should match on. To look into the entire metadata set the value to 'global'. To have a better response time you can look into a specific field like name */
                filter?: "name" | "description" | "attributes" | "global" | "name,description" | "name,attributes" | "description,attributes" | "name,description,attributes";
                /**
                 * The minimum block number from which to start the search
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 */
                from_block?: number;
                /**
                 * The maximum block number from which to end the search
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 */
                to_block?: number;
                /**
                 * The date from which to start the search (any format that is accepted by momentjs)
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 */
                from_date?: string;
                /**
                 * Get search results up until this date (any format that is accepted by momentjs)
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 */
                to_date?: string;
                /** The addresses to get metadata for */
                addresses?: string[];
                /** The cursor returned in the previous response (used for getting the next page). */
                cursor?: string;
                /** The desired page size of the result. */
                limit?: number;
                /** If the result should skip returning the total count (Improves performance). */
                disable_total?: boolean;
            };
        };
        responses: {
            /** Returns the matching NFTs */
            200: {
                content: {
                    "application/json": components["schemas"]["nftMetadataCollection"];
                };
            };
        };
    };
    /** Get the token price denominated in the blockchain's native token and USD. */
    getTokenPrice: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The factory name or address of the token exchange */
                exchange?: string;
                /** The block number from which the token price should be checked */
                to_block?: number;
            };
            path: {
                /** The address of the token contract */
                address: string;
            };
        };
        responses: {
            /** Returns the price denominated in the blockchain's native token and USD for a given token contract address */
            200: {
                content: {
                    "application/json": components["schemas"]["erc20Price"];
                };
            };
        };
    };
    /** Get token balances for a specific wallet address. */
    getWalletTokenBalances: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The block number from which the balances should be checked */
                to_block?: number;
                /** The addresses to get balances for (optional) */
                token_addresses?: string[];
            };
            path: {
                /** The address from which token balances will be checked */
                address: string;
            };
        };
        responses: {
            /** Returns token balances for a specific address */
            200: {
                content: {
                    "application/json": components["schemas"]["erc20TokenBalance"][];
                };
            };
        };
    };
    /** Get ERC20 token transactions ordered by block number in descending order. */
    getWalletTokenTransfers: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /**
                 * The minimum block number from which to get the transactions
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 */
                from_block?: number;
                /**
                 * The maximum block number from which to get the transactions.
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 */
                to_block?: number;
                /**
                 * The start date from which to get the transactions (any format that is accepted by momentjs)
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 */
                from_date?: string;
                /**
                 * Get the transactions up to this date (any format that is accepted by momentjs)
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 */
                to_date?: string;
                /** The desired page size of the result. */
                limit?: number;
                /** If the result should skip returning the total count (Improves performance). */
                disable_total?: boolean;
                /** The cursor returned in the previous response (used for getting the next page). */
                cursor?: string;
            };
            path: {
                /** The address of the wallet */
                address: string;
            };
        };
        responses: {
            /** Returns a collection of token transactions. */
            200: {
                content: {
                    "application/json": components["schemas"]["erc20TransactionCollection"];
                };
            };
        };
    };
    /** Get the metadata for a given token contract address (name, symbol, decimals, logo). */
    getTokenMetadata: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The addresses to get metadata for */
                addresses: string[];
            };
        };
        responses: {
            /** Get the metadata for a given ERC20 token contract address (name, symbol, decimals, logo). */
            200: {
                content: {
                    "application/json": components["schemas"]["erc20Metadata"][];
                };
            };
        };
    };
    /** Get the metadata for a list of token symbols (name, symbol, decimals, logo). */
    getTokenMetadataBySymbol: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The symbols to get metadata for */
                symbols: string[];
            };
        };
        responses: {
            /** Returns metadata for a given token contract address (name, symbol, decimals, logo). */
            200: {
                content: {
                    "application/json": components["schemas"]["erc20Metadata"][];
                };
            };
        };
    };
    /** Get the amount which the spender is allowed to withdraw on behalf of the owner. */
    getTokenAllowance: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The address of the token owner */
                owner_address: string;
                /** The address of the token spender */
                spender_address: string;
            };
            path: {
                /** The address of the token contract */
                address: string;
            };
        };
        responses: {
            /** Returns the amount which the spender is allowed to withdraw on behalf of the owner. */
            200: {
                content: {
                    "application/json": components["schemas"]["erc20Allowance"];
                };
            };
        };
    };
    /** Get ERC20 token transactions from a contract ordered by block number in descending order. */
    getTokenTransfers: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /**
                 * The minimum block number from which to get the transfers
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 */
                from_block?: number;
                /**
                 * The maximum block number from which to get the transfers.
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 */
                to_block?: number;
                /**
                 * The start date from which to get the transfers (any format that is accepted by momentjs)
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 */
                from_date?: string;
                /**
                 * Get transfers up until this date (any format that is accepted by momentjs)
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 */
                to_date?: string;
                /** The desired page size of the result. */
                limit?: number;
                /** If the result should skip returning the total count (Improves performance). */
                disable_total?: boolean;
                /** The cursor returned in the previous response (used for getting the next page). */
                cursor?: string;
            };
            path: {
                /** The address of the token contract */
                address: string;
            };
        };
        responses: {
            /** Returns a collection of token contract transactions. */
            200: {
                content: {
                    "application/json": components["schemas"]["erc20TransactionCollection"];
                };
            };
        };
    };
    getErc20Transfers: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The block number from which the transfers will be returned */
                from_block?: number;
                /** The block number to which the transfers will be returned */
                to_block?: number;
                /** The desired page size of the result. */
                limit?: number;
                /** Contract addresses to only include */
                contract_addresses?: string[];
                /** Contract addresses to ignore */
                exclude_contracts?: string[];
                /** Wallet addresses to only include */
                wallet_addresses?: string[];
                /** Wallet addresses to ignore */
                exclude_wallets?: string[];
                /** The cursor returned in the previous response (used to getting the next page). */
                cursor?: string;
            };
        };
        responses: {
            200: {
                content: {
                    "application/json": components["schemas"]["erc20TransfersResponse"];
                };
            };
        };
    };
    getErc20Mints: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The block number from which the mints will be returned */
                from_block?: number;
                /** The block number to which the mints will be returned */
                to_block?: number;
                /** The desired page size of the result. */
                limit?: number;
                /** Contract addresses to only include */
                contract_addresses?: string[];
                /** Contract addresses to ignore */
                exclude_contracts?: string[];
                /** Wallet addresses to only include */
                wallet_addresses?: string[];
                /** Wallet addresses to ignore */
                exclude_wallets?: string[];
                /** The cursor returned in the previous response (used to getting the next page). */
                cursor?: string;
            };
        };
        responses: {
            200: {
                content: {
                    "application/json": components["schemas"]["erc20MintsResponse"];
                };
            };
        };
    };
    getErc20Burns: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The block number from which the burns will be returned */
                from_block?: number;
                /** The block number to which the burns will be returned */
                to_block?: number;
                /** The desired page size of the result. */
                limit?: number;
                /** Contract addresses to only include */
                contract_addresses?: string[];
                /** Contract addresses to ignore */
                exclude_contracts?: string[];
                /** Wallet addresses to only include */
                wallet_addresses?: string[];
                /** Wallet addresses to ignore */
                exclude_wallets?: string[];
                /** The cursor returned in the previous response (used to getting the next page). */
                cursor?: string;
            };
        };
        responses: {
            200: {
                content: {
                    "application/json": components["schemas"]["erc20BurnsResponse"];
                };
            };
        };
    };
    getErc20Approvals: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The block number from which the approvals will be returned */
                from_block?: number;
                /** The block number to which the approvals will be returned */
                to_block?: number;
                /** The desired page size of the result. */
                limit?: number;
                /** Contract addresses to only include */
                contract_addresses?: string[];
                /** Contract addresses to ignore */
                exclude_contracts?: string[];
                /** Wallet addresses to only include */
                wallet_addresses?: string[];
                /** Wallet addresses to ignore */
                exclude_wallets?: string[];
                /** The cursor returned in the previous response (used to getting the next page). */
                cursor?: string;
            };
        };
        responses: {
            200: {
                content: {
                    "application/json": components["schemas"]["erc20ApprovalsResponse"];
                };
            };
        };
    };
    /** Get the native balance for a specific wallet address. */
    getNativeBalance: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The block number from which the balances should be checked */
                to_block?: number;
            };
            path: {
                /** The address from which the native balance will be checked */
                address: string;
            };
        };
        responses: {
            /** Returns the native balance for a specific address */
            200: {
                content: {
                    "application/json": components["schemas"]["nativeBalance"];
                };
            };
        };
    };
    /** Get the native balances for a set of specific addresses */
    getNativeBalancesForAddresses: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The block number on which the balances should be checked */
                to_block?: number;
                /** The addresses to get metadata for */
                wallet_addresses: string[];
            };
        };
        responses: {
            /** Returns a collection of balances */
            200: {
                content: {
                    "application/json": components["schemas"]["nativeBalances"];
                };
            };
        };
    };
    /** Get native transactions ordered by block number in descending order. */
    getWalletTransactions: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /**
                 * The minimum block number from which to get the transactions
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 */
                from_block?: number;
                /**
                 * The maximum block number from which to get the transactions.
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 */
                to_block?: number;
                /**
                 * The start date from which to get the transactions (any format that is accepted by momentjs)
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 */
                from_date?: string;
                /**
                 * Get the transactions up to this date (any format that is accepted by momentjs)
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 */
                to_date?: string;
                /** The cursor returned in the previous response (used for getting the next page). */
                cursor?: string;
                /** The desired page size of the result. */
                limit?: number;
                /** If the result should skip returning the total count (Improves performance). */
                disable_total?: boolean;
                /** If the result should contain the internal transactions. */
                include?: components["schemas"]["includeList"];
            };
            path: {
                /** The address of the wallet */
                address: string;
            };
        };
        responses: {
            /** Returns a collection of native transactions. */
            200: {
                content: {
                    "application/json": components["schemas"]["transactionCollection"];
                };
            };
        };
    };
    /** Get native transactions and logs ordered by block number in descending order. */
    getWalletTransactionsVerbose: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /**
                 * The minimum block number from which to get the transactions
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 */
                from_block?: number;
                /**
                 * The maximum block number from which to get the transactions.
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 */
                to_block?: number;
                /**
                 * The start date from which to get the transactions (any format that is accepted by momentjs)
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 */
                from_date?: string;
                /**
                 * Get the transactions up to this date (any format that is accepted by momentjs)
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 */
                to_date?: string;
                /** If the result should contain the internal transactions. */
                include?: components["schemas"]["includeList"];
                /** The cursor returned in the previous response (used for getting the next page). */
                cursor?: string;
                /** The desired page size of the result. */
                limit?: number;
                /** If the result should skip returning the total count (Improves performance). */
                disable_total?: boolean;
            };
            path: {
                /** The address of the wallet */
                address: string;
            };
        };
        responses: {
            /** Returns a collection of native transactions. */
            200: {
                content: {
                    "application/json": components["schemas"]["transactionCollectionVerbose"];
                };
            };
        };
    };
    /** Get the contents of a internal transaction by transaction hash. */
    getInternalTransactions: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
            };
            path: {
                /** The transaction hash */
                transaction_hash: string;
            };
        };
        responses: {
            /** Internal Transaction details by transaction hash */
            200: {
                content: {
                    "application/json": components["schemas"]["internalTransaction"][];
                };
            };
        };
    };
    /** Get the contents of a transaction by the given transaction hash. */
    getTransaction: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** If the result should contain the internal transactions. */
                include?: components["schemas"]["includeList"];
            };
            path: {
                /** The transaction hash */
                transaction_hash: string;
            };
        };
        responses: {
            /** Transaction details by transaction hash */
            200: {
                content: {
                    "application/json": components["schemas"]["blockTransaction"];
                };
            };
        };
    };
    /** Get the contents of a transaction by the given transaction hash. */
    getTransactionVerbose: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** If the result should contain the internal transactions. */
                include?: components["schemas"]["includeList"];
            };
            path: {
                /** The transaction hash */
                transaction_hash: string;
            };
        };
        responses: {
            /** Transaction details by transaction hash */
            200: {
                content: {
                    "application/json": components["schemas"]["blockTransaction"];
                };
            };
        };
    };
    /** Get the contents of a block given the block hash. */
    getBlock: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** If the result should contain the internal transactions. */
                include?: components["schemas"]["includeList"];
            };
            path: {
                /** The block number or block hash */
                block_number_or_hash: string;
            };
        };
        responses: {
            /** Returns the contents of a block */
            200: {
                content: {
                    "application/json": components["schemas"]["block"];
                };
            };
        };
    };
    /** Get the closest block given the date. */
    getDateToBlock: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** Unix date in milliseconds or a datestring (any format that is accepted by momentjs) */
                date: string;
            };
        };
        responses: {
            /** Returns the block number and corresponding date and timestamp */
            200: {
                content: {
                    "application/json": components["schemas"]["blockDate"];
                };
            };
        };
    };
    /** Get the logs for a contract. */
    getContractLogs: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /**
                 * The block number
                 * * Provide the param 'block_numer' or ('from_block' and / or 'to_block')
                 * * If 'block_numer' is provided in combination with 'from_block' and / or 'to_block', 'block_number' will will be used
                 */
                block_number?: string;
                /**
                 * The minimum block number from which to get the logs
                 * * Provide the param 'block_numer' or ('from_block' and / or 'to_block')
                 * * If 'block_numer' is provided in combination with 'from_block' and / or 'to_block', 'block_number' will will be used
                 */
                from_block?: string;
                /**
                 * The maximum block number from which to get the logs
                 * * Provide the param 'block_numer' or ('from_block' and / or 'to_block')
                 * * If 'block_numer' is provided in combination with 'from_block' and / or 'to_block', 'block_number' will will be used
                 */
                to_block?: string;
                /**
                 * The start date from which to get the logs (any format that is accepted by momentjs)
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 * * If 'from_date' and the block params are provided, the block params will be used. Please refer to the blocks params sections (block_number,from_block and to_block) on how to use them
                 */
                from_date?: string;
                /**
                 * Get the logs up to this date (any format that is accepted by momentjs)
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 * * If 'to_date' and the block params are provided, the block params will be used. Please refer to the blocks params sections (block_number,from_block and to_block) on how to use them
                 */
                to_date?: string;
                /** topic0 */
                topic0?: string;
                /** topic1 */
                topic1?: string;
                /** topic2 */
                topic2?: string;
                /** topic3 */
                topic3?: string;
                /** The desired page size of the result. */
                limit?: number;
                /** If the result should skip returning the total count (Improves performance). */
                disable_total?: boolean;
                /** The cursor returned in the previous response (used for getting the next page). */
                cursor?: string;
            };
            path: {
                /** The address of the contract */
                address: string;
            };
        };
        responses: {
            /** Returns the logs for an address */
            200: {
                content: {
                    "application/json": components["schemas"]["logCollection"];
                };
            };
        };
    };
    /** Get events for a contract ordered by block number in descending order. [Try it with Swagger](https://deep-index.moralis.io/api-docs-2.1/#/Events/getContractEvents). */
    getContractEvents: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /**
                 * The minimum block number from which to get the logs
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 */
                from_block?: number;
                /**
                 * The maximum block number from which to get the logs.
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 */
                to_block?: number;
                /**
                 * The start date from which to get the logs (any format that is accepted by momentjs)
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 */
                from_date?: string;
                /**
                 * Get the logs up to this date (any format that is accepted by momentjs)
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 */
                to_date?: string;
                /** The topic of the event */
                topic: string;
                /** offset */
                offset?: number;
                /** The desired page size of the result. */
                limit?: number;
                /** If the result should skip returning the total count (Improves performance). */
                disable_total?: boolean;
            };
            path: {
                /** The address of the contract */
                address: string;
            };
        };
        responses: {
            /** Returns a collection of events by topic */
            200: {
                content: {
                    "application/json": {
                        /**
                         * @description The total number of matches for this query
                         * @example 2000
                         */
                        total?: number;
                        /**
                         * @description The current page of the result
                         * @example 2
                         */
                        page?: number;
                        /**
                         * @description The number of results per page
                         * @example 100
                         */
                        page_size?: number;
                        result?: components["schemas"]["logEvent"][];
                    };
                };
            };
        };
        /** ABI of the specific event */
        requestBody: {
            content: {
                "application/json": {
                    [key: string]: unknown;
                };
            };
        };
    };
    /** Run a given function of a contract ABI and retrieve readonly data. [Try it with Swagger](https://deep-index.moralis.io/api-docs-2.1/#/Utils/runContractFunction). */
    runContractFunction: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The function name of the contract */
                function_name: string;
            };
            path: {
                /** The address of the contract */
                address: string;
            };
        };
        responses: {
            /** Returns response of the function executed */
            200: {
                content: {
                    "application/json": string;
                };
            };
        };
        /** Body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["RunContractDto"];
            };
        };
    };
    /** Get the current version of the Moralis Web3 API. */
    web3ApiVersion: {
        responses: {
            /** Get the current version of the Moralis Web3 API. */
            200: {
                content: {
                    "application/json": components["schemas"]["web3version"];
                };
            };
        };
    };
    /** Get the cost and rate limit for each API endpoint. */
    endpointWeights: {
        responses: {
            /** The cost and rate limit for each API endpoint. */
            200: {
                content: {
                    "application/json": components["schemas"]["endpointWeights"][];
                };
            };
        };
    };
    /** Reverse resolve a given ETH address to its ENS domain. */
    resolveAddress: {
        parameters: {
            path: {
                /** The address to be resolved */
                address: string;
            };
        };
        responses: {
            /** Returns an ENS */
            200: {
                content: {
                    "application/json": components["schemas"]["ens"];
                };
            };
        };
    };
    /** Resolve a specific Unstoppable domain to its address. */
    resolveDomain: {
        parameters: {
            query: {
                /** The currency to query */
                currency?: "eth" | "0x1";
            };
            path: {
                /** The domain to be resolved */
                domain: string;
            };
        };
        responses: {
            /** Returns an address */
            200: {
                content: {
                    "application/json": components["schemas"]["resolve"];
                };
            };
            /** Returns an address */
            404: {
                content: {
                    "application/json": {
                        [key: string]: unknown;
                    };
                };
            };
        };
    };
    /** Resolve a specific ENS domain to its address. */
    resolveENSDomain: {
        parameters: {
            path: {
                /** The domain to be resolved */
                domain: string;
            };
        };
        responses: {
            /** Returns an address */
            200: {
                content: {
                    "application/json": components["schemas"]["resolve"];
                };
            };
            /** Returns an address */
            404: {
                content: {
                    "application/json": {
                        [key: string]: unknown;
                    };
                };
            };
        };
    };
    /** Get the liquidity reserves for a given pair address. Only Uniswap V2 based exchanges supported at the moment. */
    getPairReserves: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The block number to get the reserves from */
                to_block?: string;
                /**
                 * Get the reserves up to this date (any format that is accepted by momentjs)
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 */
                to_date?: string;
            };
            path: {
                /** The liquidity pair address */
                pair_address: string;
            };
        };
        responses: {
            /** Returns the pair reserves */
            200: {
                content: {
                    "application/json": {
                        /** @example 220969226548536862025877 */
                        reserve0?: string;
                        /** @example 844810441191293211036 */
                        reserve1?: string;
                    };
                };
            };
        };
    };
    /**
     * Fetch the pair data of the provided token0+token1 combination.
     * The token0 and token1 options are interchangable (ie. there is no different outcome in "token0=WETH and token1=USDT" or "token0=USDT and token1=WETH")
     */
    getPairAddress: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The block number to get the reserves from */
                to_block?: string;
                /**
                 * Get the reserves up to this date (any format that is accepted by momentjs)
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 */
                to_date?: string;
                /** The factory name or address of the token exchange */
                exchange: "uniswapv2" | "uniswapv3" | "sushiswapv2" | "pancakeswapv2" | "pancakeswapv1" | "quickswap";
            };
            path: {
                /** The token0 address */
                token0_address: string;
                /** The token1 address */
                token1_address: string;
            };
        };
        responses: {
            /** Returns the pair address of the two tokens. */
            200: {
                content: {
                    "application/json": components["schemas"]["reservesCollection"];
                };
            };
        };
    };
    /** Upload multiple files to IPFS and place them in a folder directory. */
    uploadFolder: {
        responses: {
            /** Returns the path to the uploaded files */
            200: {
                content: {
                    "application/json": components["schemas"]["ipfsFile"][];
                };
            };
        };
        /** Array of JSON and Base64 Supported */
        requestBody: {
            content: {
                "application/json": components["schemas"]["ipfsFileRequest"][];
            };
        };
    };
    /** Get the top ERC20 tokens by market cap */
    getTopERC20TokensByMarketCap: {
        parameters: {};
        responses: {
            /** Returns the top ERC20 tokens by market cap */
            200: {
                content: {
                    "application/json": components["schemas"]["marketDataERC20Token"];
                };
            };
        };
    };
    /** Get the top ERC20 tokens by price change */
    getTopERC20TokensByPriceMovers: {
        parameters: {};
        responses: {
            /** Returns an a list of ERC20 tokens with their price change */
            200: {
                content: {
                    "application/json": components["schemas"]["marketDataERC20TokensByPriceMovers"];
                };
            };
        };
    };
    /** Get the top NFT collections by market cap */
    getTopNFTCollectionsByMarketCap: {
        parameters: {};
        responses: {
            /** Returns the top NFT collections by market cap */
            200: {
                content: {
                    "application/json": components["schemas"]["marketDataTopNFTCollectionByMarketCap"];
                };
            };
        };
    };
    /** Get the hottest NFT collections by trading volume */
    getHottestNFTCollectionsByTradingVolume: {
        parameters: {};
        responses: {
            /** Returns the hottest NFT collections by trading volume */
            200: {
                content: {
                    "application/json": components["schemas"]["marketDataHottestNFTCollectionByTradingVolume"];
                };
            };
        };
    };
    /** Review contracts as spam or not spam */
    reviewContracts: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
            };
        };
        responses: {
            /** Returns a message acknowledging the report */
            200: {
                content: {
                    "application/json": {
                        /** @example Submission successful */
                        message?: string;
                    };
                };
            };
        };
        /** Body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["ContractsReviewDto"];
            };
        };
    };
}

type EvmBlockDateInput = components['schemas']['blockDate'];
interface EvmBlockDateData {
    date: Date;
    block: number;
    timestamp: number;
    blockTimestamp?: string;
    hash?: string;
    parentHash?: string;
}

type EvmBlockDateish = EvmBlockDateInput | EvmBlockDate;
declare class EvmBlockDate {
    private readonly data;
    /**
     * Create a new instance of EvmBlockDate.
     * @param data - the EvmBlockDateish type.
     */
    static create(data: EvmBlockDateish): EvmBlockDate;
    private static parse;
    private constructor();
    /**
     * @description The block number.
     * @example `9193266`
     */
    get block(): number;
    /**
     * @description The date of the block.
     * @example `2020-01-01T00:00:00+00:00`
     */
    get date(): Date;
    /**
     * @description The timestamp of the block
     * @example `1577836811`
     */
    get timestamp(): number;
    /**
     * @description The timestamp of the block
     * @example `2022-01-03T22:59:39.000Z`
     */
    get blockTimestamp(): string | undefined;
    /**
     * @deprecated Use `blockTimestamp` instead.
     */
    get block_timestamp(): string | undefined;
    /**
     * @description The block hash.
     * @example `0x9b559aef7ea858608c2e554246fe4a24287e7aeeb976848df2b9a2531f4b9171`
     */
    get hash(): string | undefined;
    /**
     * @deprecated Use `hash` instead.
     */
    get block_hash(): string | undefined;
    /**
     * @description The block hash of the parent block.
     * @example `0x011d1fc45839de975cc55d758943f9f1d204f80a90eb631f3bf064b80d53e045`
     */
    get parentHash(): string | undefined;
    /**
     * @deprecated Use `parentHash` instead.
     */
    get parent_hash(): string | undefined;
}

/**
 * This can be any object with valid event data.
 * @example
 * ```
 * const transactionInput = {
 * chain: 1,
 * address: "0xdac17f958d2ee523a2206206994597c13d831ec7",
 * blockHash: "0x1bb168d2725d15b12604c92a83c529617cd54a415c5d610a687f7859d45f9ea5",
 * blockNumber: "14327217",
 * blockTimestamp: "2022-03-05T13:45:42.000Z",
 * transactionHash: "0xc9f62f4f6ab505a96c1a84ec2899c6bfd86245ef1effaa689fc997798be763d5",
 * data: {
 *  to: "0x54e41aa7ac19efd71d19a3ca6b8a6c0154fe3afb",
 *  from: "0x21f510cc9f81df4e4d2c705e672761cf487cdc5a",
 *  value: "878000000",
 * },
 *}
 * ```
 */
interface EvmEventInput {
    chain: EvmChainish;
    transactionHash: string;
    address: EvmAddressish;
    blockTimestamp: DateInput;
    blockNumber: BigNumberish;
    blockHash: string;
    data: {
        from?: EvmAddressish;
        to?: EvmAddressish;
        value?: EvmNativeish;
    };
}
/**
 * This is the return type of the processed EVM event
 */
interface EvmEventData {
    chain: EvmChain;
    transactionHash: string;
    address: EvmAddress;
    blockTimestamp: Date;
    blockNumber: BigNumber;
    blockHash: string;
    data: {
        from?: EvmAddress;
        to?: EvmAddress;
        value?: EvmNative;
    };
}

/**
 * Valid input for a new EvmEvent instance.
 * This can be an existing {@link EvmEvent} or a valid {@link EvmEventInput} object
 */
type EvmEventish = EvmEventInput | EvmEvent;
/**
 * The EvmEvent is a representation of an event.
 *
 * Use this class any time you work with an event.
 *
 * @category DataType
 */
declare class EvmEvent implements MoralisDataObject {
    private readonly _data;
    /**
     * Create a new instance of EvmEvent from any valid event input
     * @param data - the EvmEventish type
     * @example
     * ```
     * const event = EvmEventish.create(data);
     *```
     */
    static create(data: EvmEventish): EvmEvent;
    private constructor();
    static parse: (data: EvmEventInput) => EvmEventData;
    /**
     * Check the equality between two Evm events. It checks if the chain, block number, address and data are equal.
     * @param dataA - The first event
     * @param dataB - The second event
     * @example
     * ```ts
     * EvmEvent.equals(dataA, dataB)
     * ```
     * @returns true if the events are equal, false otherwise
     */
    static equals(dataA: EvmEventish, dataB: EvmEventish): boolean;
    /**
     * Checks the equality of the current event instance with another evm event
     * @param data - the event to compare with
     * @example
     * ```ts
     * event.equals(data)
     * ```
     * @returns true if the events are equal, false otherwise
     */
    equals(data: EvmEventish): boolean;
    /**
     * @returns a JSON represention of the event.
     * @example
     * ```
     * event.toJSON()
     * ```
     */
    toJSON(): {
        chain: string;
        address: string;
        blockNumber: string;
        data: {
            from: string | undefined;
            to: string | undefined;
            value: string | undefined;
        };
        transactionHash: string;
        blockTimestamp: Date;
        blockHash: string;
    };
    /**
     * @deprecated This method will be removed soon. To format the value, use one of the properties.
     */
    format(): {
        chain: string;
        address: string;
        blockNumber: string;
        data: {
            from: string | undefined;
            to: string | undefined;
            value: string | undefined;
        };
        transactionHash: string;
        blockTimestamp: Date;
        blockHash: string;
    };
    /**
     * @returns all the data without casting it to JSON.
     * @example event.result
     */
    get result(): EvmEventData;
    /**
     * @returns the event chain
     * @example event.chain // EvmChain
     */
    get chain(): EvmChain;
    /**
     * @returns the event address
     * @example event.address // EvmAddress
     */
    get address(): EvmAddress;
    /**
     * @returns the event block number
     * @example event.blockNumber // BigNumber
     */
    get blockNumber(): BigNumber;
    /**
     * @returns the event block timestamp
     * @example event.blockTimestamp // Date
     */
    get blockTimestamp(): Date;
    /**
     * @returns the event data with from address, to address and value
     * @example event.data
     */
    get data(): {
        from?: EvmAddress | undefined;
        to?: EvmAddress | undefined;
        value?: EvmNative | undefined;
    };
    /**
     * @returns the event block trannsaciton hash
     * @example event.transactionHash // "0xc9f62f4f6ab505a96c1a84ec2899c6bfd86245ef1effaa689fc997798be763d5"
     */
    get transactionHash(): string;
    /**
     * @returns the event block hash
     * @example event.blockHash // "0xc9f62f4f6ab505a96c1a84ec2899c6bfd86245ef1effaa689fc997798be763d5"
     */
    get blockHash(): string;
}

type EvmNftMediaCategory = 'image' | 'video' | 'audio';
type EvmNftMediaStatus = 'success' | 'processing' | 'unsupported_media' | 'invalid_url' | 'host_unavailable' | 'temporarily_unavailable';
type EvmNftMediaItem = {
    height: number;
    width: number;
    url: string;
};
interface EvmNftMediaInput {
    chain: EvmChainish;
    status?: EvmNftMediaStatus;
    updatedAt?: DateInput;
    originalMediaUrl?: string;
    category?: EvmNftMediaCategory;
    mimetype?: string;
    parentHash?: string;
    mediaCollection?: {
        low: EvmNftMediaItem;
        medium: EvmNftMediaItem;
        high: EvmNftMediaItem;
    };
}
interface EvmNftMediaData {
    chain: EvmChain;
    status?: EvmNftMediaStatus;
    updatedAt?: Date;
    originalMediaUrl?: string;
    category?: EvmNftMediaCategory;
    mimetype?: string;
    parentHash?: string;
    mediaCollection?: {
        low: EvmNftMediaItem;
        medium: EvmNftMediaItem;
        high: EvmNftMediaItem;
    };
}

/**
 * The EvmNftMedia is a representation of an processed NFT media.
 *
 * @category DataType
 */
declare class EvmNftMedia implements MoralisDataObject {
    /**
     * Create a new instance of EvmNftMedia from any valid input
     * @param data -  EvmNftMedia instance or valid EvmNftMediaInput
     * @example
     * ```
     * const media = EvmNftMedia.create(data);
     *```
     */
    static create(data: EvmNftMediaInput): EvmNftMedia;
    private _data;
    constructor(data: EvmNftMediaInput);
    static parse: (data: EvmNftMediaInput) => EvmNftMediaData;
    /**
     * Check the equality between two Erc20 medias
     * @param dataA - The first media to compare
     * @param dataB - The second media to compare
     * @example EvmNftMedia.equals(dataA, dataB)
     * @returns true if the medias are equal, false otherwise
     */
    static equals(dataA: EvmNftMedia | EvmNftMediaInput, dataB: EvmNftMedia | EvmNftMediaInput): boolean;
    /**
     * Checks the equality of the current media with another erc20 media
     * @param data - the media to compare with
     * @example media.equals(data)
     * @returns true if the medias are equal, false otherwise
     */
    equals(data: EvmNftMedia | EvmNftMediaInput): boolean;
    /**
     * @returns a JSON representation of the media.
     * @example media.toJSON()
     */
    toJSON(): {
        chain: string;
        status?: EvmNftMediaStatus | undefined;
        updatedAt?: Date | undefined;
        originalMediaUrl?: string | undefined;
        category?: EvmNftMediaCategory | undefined;
        mimetype?: string | undefined;
        parentHash?: string | undefined;
        mediaCollection?: {
            low: EvmNftMediaItem;
            medium: EvmNftMediaItem;
            high: EvmNftMediaItem;
        } | undefined;
    };
    /**
     * @deprecated This method will be removed soon. To format the value, use one of the properties.
     */
    format(): {
        chain: string;
        status?: EvmNftMediaStatus | undefined;
        updatedAt?: Date | undefined;
        originalMediaUrl?: string | undefined;
        category?: EvmNftMediaCategory | undefined;
        mimetype?: string | undefined;
        parentHash?: string | undefined;
        mediaCollection?: {
            low: EvmNftMediaItem;
            medium: EvmNftMediaItem;
            high: EvmNftMediaItem;
        } | undefined;
    };
    /**
     * @returns all the data without casting it to JSON.
     * @example media.result
     */
    get result(): EvmNftMediaData;
    get chain(): EvmChain;
    get status(): EvmNftMediaStatus | undefined;
    get updatedAt(): Date | undefined;
    get originalMediaUrl(): string | undefined;
    get category(): EvmNftMediaCategory | undefined;
    get mimetype(): string | undefined;
    get parentHash(): string | undefined;
    get mediaCollection(): {
        low: EvmNftMediaItem;
        medium: EvmNftMediaItem;
        high: EvmNftMediaItem;
    } | undefined;
}

/**
 * This can be any object with valid transaction data.
 * @example
 * ```ts
 * const nftInput = {
          chain: 1,
          contractType: "ERC721",
          tokenAddress: "0x057Ec652A4F150f7FF94f089A38008f49a0DF88e",
          tokenId: "15",
          tokenUri: "string",
          metadata: "string",
          name: "CryptoKitties",
          symbol: "RARI",
          amount: "1",
          blockNumberMinted: "88256",
          blockNumber: "88256",
          ownerOf: "0xfB6916095ca1df60bB79Ce92cE3Ea74c37c5d359",
          tokenHash: nft.token_hash,
          lastMetadataSync: "date_string",
          lastTokenUriSync: "date_string",
          possibleSpam: false
        }
 * ```
 */
interface EvmNftInput {
    tokenId: number | string;
    contractType: string;
    chain: EvmChainish;
    tokenUri?: null | string;
    tokenAddress: EvmAddressish;
    tokenHash?: null | string;
    metadata?: null | string;
    name?: null | string;
    symbol?: null | string;
    ownerOf?: null | EvmAddressish;
    blockNumberMinted?: null | BigNumberish;
    blockNumber?: null | BigNumberish;
    lastMetadataSync?: null | DateInput;
    lastTokenUriSync?: null | DateInput;
    amount?: null | number | string;
    media?: EvmNftMedia | EvmNftMediaInput;
    possibleSpam: boolean;
}
/**
 * This is the return type of the processed EVM NFT
 */
interface EvmNftData {
    tokenId: number | string;
    contractType?: string;
    chain: EvmChain;
    tokenUri?: string;
    tokenAddress: EvmAddress;
    tokenHash?: string;
    metadata?: MoralisDataObjectValue;
    name?: string;
    symbol?: string;
    ownerOf?: EvmAddress;
    blockNumberMinted?: BigNumber;
    blockNumber?: BigNumber;
    lastMetadataSync?: Date;
    lastTokenUriSync?: Date;
    amount?: number;
    media?: EvmNftMedia;
    possibleSpam: boolean;
}

/**
 * Valid input for a new EvmNft instance.
 * This can be an existing {@link EvmNft} or a valid {@link EvmNftInput} object
 */
type EvmNftish = EvmNftInput | EvmNft;
/**
 * The EvmNft class is a MoralisData that references to a the NFT of the type; Erc721 or Erc1155
 *
 * @category DataType
 */
declare class EvmNft implements MoralisDataObject {
    /**
     * Create a new instance of EvmNft from any valid address input
     *
     * @param data - the EvmNftish type
     * @example
     * ```ts
     * const nft = EvmNft.create(data);
     * ```
     * @returns an instance of EvmNft
     */
    static create(data: EvmNftish): EvmNft;
    private _data;
    constructor(data: EvmNftInput);
    static parse: (data: EvmNftInput) => EvmNftData;
    /**
     * This function confirms that the NFT metadata is a valid JSON string.
     *
     * @param value - the new value for the NFT metadata
     * @returns the parsed value of the JSON string
     * @throws {CoreError} if the value is not a valid JSON string
     */
    private static validateMetadata;
    /**
     * Compares two EvmNftish data. verifies that the chain, tokenAddress and owner of values are equal.
     * @param valueA - the first EvmNftish data to compare
     * @param valueB - the second EvmNftish data to compare
     * @returns true if the values are equal, false otherwise
     * @example
     * ```ts
     *  EvmNft.equals(valueA, valueB);
     * ```
     */
    static equals(valueA: EvmNftish, valueB: EvmNftish): boolean;
    /**
     * Compares an EvmNftish data to this EvmNft instance.
     * @param value - the value to compare
     * @returns true if the value is equal to the current instance, false otherwise
     * @example
     * ```ts
     * nft.equals(value);
     * ```
     */
    equals(value: EvmNftish): boolean;
    /**
     * Converts the EvmNft instance to a JSON object.
     * @returns JSON object of the EvmNft instance
     * @example `nft.toJSON()`
     */
    toJSON(): {
        tokenAddress: string;
        chain: string;
        ownerOf: string | undefined;
        blockNumberMinted: string | undefined;
        blockNumber: string | undefined;
        media: {
            chain: string;
            status?: EvmNftMediaStatus | undefined;
            updatedAt?: Date | undefined;
            originalMediaUrl?: string | undefined;
            category?: EvmNftMediaCategory | undefined;
            mimetype?: string | undefined;
            parentHash?: string | undefined;
            mediaCollection?: {
                low: EvmNftMediaItem;
                medium: EvmNftMediaItem;
                high: EvmNftMediaItem;
            } | undefined;
        } | undefined;
        tokenId: string | number;
        contractType?: string | undefined;
        tokenUri?: string | undefined;
        tokenHash?: string | undefined;
        metadata?: MoralisDataObjectValue | undefined;
        name?: string | undefined;
        symbol?: string | undefined;
        lastMetadataSync?: Date | undefined;
        lastTokenUriSync?: Date | undefined;
        amount?: number | undefined;
        possibleSpam: boolean;
    };
    /**
     * @deprecated This method will be removed soon. To format the value, use one of the properties.
     */
    format(): {
        tokenAddress: string;
        chain: string;
        ownerOf: string | undefined;
        blockNumberMinted: string | undefined;
        blockNumber: string | undefined;
        media: {
            chain: string;
            status?: EvmNftMediaStatus | undefined;
            updatedAt?: Date | undefined;
            originalMediaUrl?: string | undefined;
            category?: EvmNftMediaCategory | undefined;
            mimetype?: string | undefined;
            parentHash?: string | undefined;
            mediaCollection?: {
                low: EvmNftMediaItem;
                medium: EvmNftMediaItem;
                high: EvmNftMediaItem;
            } | undefined;
        } | undefined;
        tokenId: string | number;
        contractType?: string | undefined;
        tokenUri?: string | undefined;
        tokenHash?: string | undefined;
        metadata?: MoralisDataObjectValue | undefined;
        name?: string | undefined;
        symbol?: string | undefined;
        lastMetadataSync?: Date | undefined;
        lastTokenUriSync?: Date | undefined;
        amount?: number | undefined;
        possibleSpam: boolean;
    };
    get result(): EvmNftData;
    /**
     * @returns the NFT chain
     * @example
     * ```
     * nft.chain // EvmChain
     * ```
     */
    get chain(): EvmChain;
    /**
     * @returns the NFT contract type
     * @example
     * ```
     * nft.contractType // "ERC721" | "ERC1155"
     * ```
     */
    get contractType(): string | undefined;
    /**
     * @returns the NFT token address
     * @example
     * ```
     * nft.tokenAddress // EvmAddress
     * ```
     */
    get tokenAddress(): EvmAddress;
    /**
     * @returns the NFT metadata
     * @example
     * ```ts
     * nft.metadata
     * // {
     * // name: 'Pancake',
     * // description: 'The dessert series 1',
     * // image: 'ipfs://QmNQFXCZ6LGzvpMW9Q5PWbCrEnLknQrPwr2r8pbQAgzQ9A/4863BD6B-6C92-4B96-BF80-8020B2F7C3A5.jpeg',
     * // }
     * ```
     */
    get metadata(): MoralisDataObjectValue | undefined;
    /**
     * @returns the NFT token URI
     * @example
     * ```
     * nft.tokenUri // "https://gateway.moralisipfs.com/ipfs/QmajSqgxY3cWBgBeRm38vasJAcTit1kp5EwqVHxszJYgUC/728.json"
     * ```
     */
    get tokenUri(): string | undefined;
    /**
     * @returns the NFT token hash
     * @example
     * ```
     * nft.tokenHash // "QmajSqgxY3cWBgBeRm38vasJAcTit1kp5EwqVHxszJYgUC"
     * ```
     */
    get tokenHash(): string | undefined;
    /**
     * @returns the NFT name
     * @example
     * ```
     * nft.name // "Tether USD"
     * ```
     */
    get name(): string | undefined;
    /**
     * @returns the NFT symbol
     * @example
     * ```
     * nft.symbol // "USDT"
     * ```
     */
    get symbol(): string | undefined;
    /**
     * @returns the NFT owner of address
     * @example
     * ```
     * nft.ownerOf // EvmAddress
     * ```
     */
    get ownerOf(): EvmAddress | undefined;
    /**
     * @returns the NFT block number minted from
     * @example
     * ```
     * nft.blockNumberMinted // BigNumber
     * ```
     */
    get blockNumberMinted(): BigNumber | undefined;
    /**
     * @returns the NFT block number
     * @example
     * ```
     * nft.blockNumber // BigNumber
     * ```
     */
    get blockNumber(): BigNumber | undefined;
    /**
     * @returns the NFT latest metadata sync date
     * @example
     * ```
     * nft.latestMetadataSync // Date
     * ```
     */
    get lastMetadataSync(): Date | undefined;
    /**
     * @returns the NFT latest token URI sync date
     * @example
     * ```
     * nft.latestTokenUriSync // Date
     * ```
     */
    get lastTokenUriSync(): Date | undefined;
    /**
     * @returns the NFT amount
     * @example
     * ```
     * nft.amount // 2
     * ```
     */
    get amount(): number | undefined;
    /**
     * @returns the token id
     * @example
     * ```
     * nft.tokenId // '1234'
     * ```
     */
    get tokenId(): string | number;
    /**
     * @returns the processed media of the NFT
     * @example
     * ```
     * nft.media // EvmNftMedia
     * ```
     */
    get media(): EvmNftMedia | undefined;
    /**
     * @returns possibility of the token being a spam token
     * @example transfer.possibleSpam // true
     */
    get possibleSpam(): boolean;
}

/**
 * This can be any object with valid block data.
 * @example
 * ```
 * const input = {
 *   chain: '0x1',
 *   contractType: 'ERC721',
 *   name: 'Test NFT',
 *   symbol: 'TEST',
 *   tokenAddress: '0xe4c7bf3aff7ad07f9e80d57f7189f0252592fee6321c2a9bd9b09b6ce0690d27',
 *  }
 * ```
 */
interface EvmNftCollectionInput {
    chain: EvmChainish;
    contractType: string;
    name: string;
    symbol: string;
    tokenAddress: EvmAddressish;
}
/**
 * This is the return type of the processed EVM transaction
 */
interface EvmNftCollectionData {
    chain: EvmChain;
    contractType?: string;
    name: string;
    symbol: string;
    tokenAddress: EvmAddress;
}

/**
 * Valid input for a new EvmNftCollection instance.
 * This can be an existing {@link EvmNftCollection} or a valid {@link EvmNftCollectionInput} object
 */
type EvmNftCollectionish = EvmNftCollectionInput | EvmNftCollection;
/**
 * The EvmNftCollection is a representation of an nft collection.
 *
 * @category DataType
 */
declare class EvmNftCollection implements MoralisDataObject {
    /**
     * Create a new instance of EvmNftCollection from any valid transaction input
     * @param data - the EvmNftCollectionish type
     * @example const collection = EvmNftCollection.create(data);
     */
    static create(data: EvmNftCollectionish): EvmNftCollection;
    private _data;
    constructor(data: EvmNftCollectionInput);
    static parse: (data: EvmNftCollectionInput) => EvmNftCollectionData;
    /**
     * Check the equality between two Evm collections. It compares their hashes and collections.
     * @param dataA - The first collection to compare
     * @param dataB - The second collection to compare
     * @example EvmNftCollection.equals(dataA, dataB)
     */
    static equals(dataA: EvmNftCollectionish, dataB: EvmNftCollectionish): boolean;
    /**
     * Checks the equality of the current collection with another evm collection
     * @param data - the collection to compare with
     * @example
     * ```ts
     * collection.equals(data)
     * ```
     */
    equals(data: EvmNftCollectionish): boolean;
    /**
     * @returns a JSON represention of the collection.
     * @example
     * ```
     * collection.toJSON()
     * ```
     */
    toJSON(): {
        chain: string;
        tokenAddress: string;
        contractType?: string | undefined;
        name: string;
        symbol: string;
    };
    /**
     * @deprecated This method will be removed soon. To format the value, use one of the properties.
     */
    format(): {
        chain: string;
        tokenAddress: string;
        contractType?: string | undefined;
        name: string;
        symbol: string;
    };
    /**
     * @returns all the data without casting it to JSON.
     * @example collection.result
     */
    get result(): EvmNftCollectionData;
    /**
     * @returns the chain where the collection is deployed.
     * @example collection.chain // EvmChain
     */
    get chain(): EvmChain;
    /**
     * @returns the token address of collection.
     * @example collection.tokenAddress // EvmAddress
     */
    get tokenAddress(): EvmAddress;
    /**
     * @returns the token type of collection.
     * @example collection.tokenAddress // 'ERC721'
     */
    get contractType(): string | undefined;
    /**
     * @returns the token name of collection.
     * @example collection.tokenAddress // 'Test NFT'
     */
    get name(): string;
    /**
     * @returns the token symbol of collection.
     * @example collection.symbol // 'TEST'
     */
    get symbol(): string;
}

/**
 * Valid ERC20 token input
 *
 * @example
 * ```ts
 * const input = {
 *   chain: 1,
 *   tokenAddress: "0x7de3085b3190b3a787822ee16f23be010f5f8686",
 *   syncedAt: "2022-02-19",
 *   contractType: "ERC721",
 *   symbol: "BAMC",
 * }
 * ```
 */
interface EvmNftMetadataInput {
    chain: EvmChainish;
    tokenAddress: EvmAddressish;
    name: string;
    symbol: string;
    contractType?: string;
    syncedAt: DateInput | null;
}
/**
 * This is the return type of the processed Evm NFT Metadata
 */
interface EvmNftMetadataData {
    chain: EvmChain;
    tokenAddress: EvmAddress;
    name: string;
    symbol: string;
    contractType?: string;
    syncedAt?: Date;
}

/**
 * This can be an exsisting {@link EvmNftMetadata} or a valid {@link EvmNftMetadataInput}.
 */
type EvmNftMetadataish = EvmNftMetadataInput | EvmNftMetadata;
/**
 * The EvmNftMetadata contains metadata of an NFT.
 *
 * @category DataType
 */
declare class EvmNftMetadata implements MoralisDataObject {
    /**
     *  Create a new instance of EvmNftMetadata from any valid EvmNftMetadata input
     *
     * @param data - the EvmNftMetadataish type
     * @example
     * ```ts
     * const token = EvmNftMetadataish.create(value);
     * ```
     */
    static create(data: EvmNftMetadataish): EvmNftMetadata;
    private _data;
    constructor(data: EvmNftMetadataInput);
    static parse: (data: EvmNftMetadataInput) => EvmNftMetadataData;
    /**
     * Compares two EvmNftMetadata instances. This checks if the chain and tokenAddress of both meatdatas are equal.
     *
     * @param dataA - the first EvmNftMetadataish to compare
     * @param dataB - the second EvmNftMetadataish to compare
     * @returns true if the two EvmNftMetadataData are equal
     * @example
     * ```ts
     * EvmNftMetadata.equals(dataA, dataB);
     * ```
     */
    static equals(dataA: EvmNftMetadataish, dataB: EvmNftMetadataish): boolean;
    /**
     * Compares EvmNftMetadata instance to current instance
     *
     * @param data - the EvmNftMetadataish to compare
     * @returns true if the EvmNftMetadataish is equals given metadata
     * @example
     * ```ts
     * metadata.equals(data);
     * ```
     */
    equals(data: EvmNftMetadataish): boolean;
    /**
     * @returns the data as JSON.
     * @example metadata.toJSON();
     */
    toJSON(): {
        chain: string;
        tokenAddress: string;
        name: string;
        symbol: string;
        contractType?: string | undefined;
        syncedAt?: Date | undefined;
    };
    /**
     * @deprecated This method will be removed soon. To format the value, use one of the properties.
     */
    format(): {
        chain: string;
        tokenAddress: string;
        name: string;
        symbol: string;
        contractType?: string | undefined;
        syncedAt?: Date | undefined;
    };
    /**
     * @returns all the data without casting it to JSON.
     * @example metadata.result;
     */
    get result(): EvmNftMetadataData;
    /**
     * @returns the name in the metadata.
     * @example metadata.name; // "Baby Ape Mutant Club"
     */
    get name(): string;
    /**
     * @returns the symbol in the metadata.
     * @example metadata.symbol; // "BAMC"
     */
    get symbol(): string;
    /**
     * @returns the contract type of the NFT.
     * @example metadata.contractType; // "ERC721"
     */
    get contractType(): string | undefined;
    /**
     * @returns the chain in the metadata.
     * @example metadata.chain; // EvmChain
     */
    get chain(): EvmChain;
    /**
     * @returns the token address in the metadata.
     * @example metadata.tokenAddress; // EvmAddress
     */
    get tokenAddress(): EvmAddress;
    /**
     * @returns the date the metadata was synced.
     * @example metadata.syncedAt; // Date
     */
    get syncedAt(): Date | undefined;
}

/**
 * This can be any object with valid transfer data.
 * @example
 * ```
 * const input = {
 *  chain: 1,
 *  tokenAddress: "0x057Ec652A4F150f7FF94f089A38008f49a0DF88e",
 *  toAddress: "0x057Ec652A4F150f7FF94f089A38008f49a0DF88e",
 *  operator: null,
 *  fromAddress: "0x057Ec652A4F150f7FF94f089A38008f49a0DF88e",
 *  value: null,
 *  blockTimestamp: "2021-06-04T16:00:15",
 *  blockHash: "0x057Ec652A4F150f7FF94f089A38008f49a0DF88e",
 *  transactionIndex: 123,
 *  blockNumber: "88256",
 *  contractType: "ERC721",
 *  logIndex: 0,
 *  tokenId: "15",
 *  transactionHash: "0x057Ec652A4F150f7FF94f089A38008f49a0DF88e",
 *  transactionType: "1",
 *  possibleSpam: false
 * }
 * ```
 */
interface EvmNftTransferInput {
    chain: EvmChainish;
    amount?: null | string | number;
    blockHash: string;
    blockNumber: BigNumberish;
    blockTimestamp: DateInput;
    contractType: string;
    fromAddress?: null | EvmAddressish;
    value?: null | EvmNativeish;
    logIndex: number | string;
    toAddress: EvmAddressish;
    tokenAddress: EvmAddressish;
    tokenId: string;
    transactionHash: string;
    transactionIndex?: null | string | number;
    transactionType?: null | string;
    operator?: null | EvmAddressish;
    possibleSpam: boolean;
}
/**
 * This is the return type of the processed EVM NFT Transfer.
 */
interface EvmNftTransferData {
    chain: EvmChain;
    amount?: number;
    blockHash: string;
    blockNumber: BigNumber;
    blockTimestamp: Date;
    contractType: string;
    fromAddress?: EvmAddress;
    value?: EvmNative;
    logIndex: number;
    toAddress: EvmAddress;
    tokenAddress: EvmAddress;
    tokenId: string;
    transactionHash: string;
    transactionIndex?: number;
    transactionType?: string;
    operator?: EvmAddress;
    possibleSpam: boolean;
}

/**
 * Valid input for a new EvmNftTransfer instance.
 * This can be an existing {@link EvmNftTransfer} or a valid {@link EvmNftTransferInput} object
 */
type EvmNftTransferish = EvmNftTransferInput | EvmNftTransfer;
/**
 * The EvmNftTransfer is a representation of a completed NFT transfer.
 *
 * @category DataType
 */
declare class EvmNftTransfer implements MoralisDataObject {
    /**
     * Create a new instance of EvmNftTransfer from any valid transfer input
     * @param data - the EvmNftTransferish type
     * @example
     * ```
     * const transfer = EvmNftTransfer.create(data);
     *```
     */
    static create(data: EvmNftTransferish): EvmNftTransfer;
    protected _data: EvmNftTransferData;
    constructor(data: EvmNftTransferInput);
    static parse: (data: EvmNftTransferInput) => EvmNftTransferData;
    /**
     * Check the equality between two NFT transfers. The compares the chain, blockHash, tokenId and logIndex.
     * @param dataA - The first transfer to compare
     * @param dataB - The second transfer to compare
     * @example EvmNftTransfer.equals(dataA, dataB)
     * @returns true if the transfers are equal, false otherwise
     */
    static equals(dataA: EvmNftTransferish, dataB: EvmNftTransferish): boolean;
    /**
     * Checks the equality of the current transfer instance with another nft transfer
     * @param data - the transfer to compare with
     * @example transaction.equals(data)
     * @returns true if the transfers are equal, false otherwise
     */
    equals(data: EvmNftTransferish): boolean;
    /**
     * @returns a JSON represention of the transfer.
     * @example
     * ```
     * transfer.toJSON()
     * ```
     */
    toJSON(): {
        chain: string;
        fromAddress: string | undefined;
        toAddress: string;
        tokenAddress: string;
        value: string | undefined;
        operator: string | undefined;
        blockNumber: string;
        amount?: number | undefined;
        blockHash: string;
        blockTimestamp: Date;
        contractType: string;
        logIndex: number;
        tokenId: string;
        transactionHash: string;
        transactionIndex?: number | undefined;
        transactionType?: string | undefined;
        possibleSpam: boolean;
    };
    /**
     * @returns a JSON represention of the transfer.
     * @example
     * ```
     * transfer.format()
     * ```
     */
    format(): {
        chain: string;
        fromAddress: string | undefined;
        toAddress: string;
        tokenAddress: string;
        value: string | undefined;
        operator: string | undefined;
        blockNumber: string;
        amount?: number | undefined;
        blockHash: string;
        blockTimestamp: Date;
        contractType: string;
        logIndex: number;
        tokenId: string;
        transactionHash: string;
        transactionIndex?: number | undefined;
        transactionType?: string | undefined;
        possibleSpam: boolean;
    };
    /**
     * @returns all the data without casting it to JSON.
     * @example transfer.result
     */
    get result(): EvmNftTransferData;
    /**
     * @returns the chain of the transfer.
     * @example transfer.chain // EvmChain
     */
    get chain(): EvmChain;
    /**
     * @returns the block hash of the transfer.
     * @example transfer.blockHash // "0x057Ec652A4F150f7FF94f089A38008f49a0DF88e"
     */
    get blockHash(): string;
    /**
     * @returns the block number of the transfer.
     * @example transfer.blockNumber // BigNumber
     */
    get blockNumber(): BigNumber;
    /**
     * @returns the block timestamp of the transfer.
     * @example transfer.blockTimestamp // Date
     */
    get blockTimestamp(): Date;
    /**
     * @returns the from address of the transfer.
     * @example transfer.fromAddress // EvmAddress
     */
    get fromAddress(): EvmAddress | undefined;
    /**
     * @returns the to address of the transfer.
     * @example transfer.toAddress // EvmAddress
     */
    get toAddress(): EvmAddress;
    /**
     * @returns the token address of the transfer.
     * @example transfer.tokenAddress // EvmAddress
     */
    get tokenAddress(): EvmAddress;
    /**
     * @returns the token id of the transfer.
     * @example transfer.tokenId // "15"
     */
    get tokenId(): string;
    /**
     * @returns the amount of the transfer.
     * @example transfer.amount // 1
     */
    get amount(): number | undefined;
    /**
     * @returns the value of the transfer.
     * @example transfer.value // EvmNative
     */
    get value(): EvmNative | undefined;
    /**
     * @returns the log index of the transfer.
     * @example transfer.logIndex // 0
     */
    get logIndex(): number;
    /**
     * @returns the transaction hash of the transfer.
     * @example transfer.transactionHash // "0x057Ec652A4F150f7FF94f089A38008f49a0DF88e"
     */
    get transactionHash(): string;
    /**
     * @returns the transaction index of the transfer.
     * @example transfer.transactionIndex // 123
     */
    get transactionIndex(): number | undefined;
    /**
     * @returns the transaction type of the transfer.
     * @example transfer.transactionType // "1"
     */
    get transactionType(): string | undefined;
    /**
     * @returns the operator of the transfer.
     * @example transfer.operator // EvmAddress
     */
    get operator(): EvmAddress | undefined;
    /**
     * @returns the contract type of the transfer.
     * @example transfer.contractType // "ERC721"
     */
    get contractType(): string;
    /**
     * @returns possibility of the token being a spam token
     * @example transfer.possibleSpam // true
     */
    get possibleSpam(): boolean;
}

type EvmTransactionLogDecodedEventParam = {
    name?: string;
    value?: string;
    type?: string;
};
interface EvmTransactionLogDecodedEvent {
    signature?: string;
    label?: string;
    type?: string;
    params?: EvmTransactionLogDecodedEventParam[];
}
/**
 * This can be any object with valid verbose transaction data.
 */
interface EvmTransactionLogDecodedInput extends EvmTransactionLogInput {
    decodedEvent: EvmTransactionLogDecodedEvent;
}
/**
 * This is the return type of the processed EVM verbose transaction
 */
interface EvmTransactionLogDecodedData extends EvmTransactionLogData {
    decodedEvent: EvmTransactionLogDecodedEvent;
}

/**
 * This can be any valid {@link EvmTransactionLogDecodedInput} or {@link EvmTransactionLogDecoded}.
 */
type EvmTransactionLogDecodedish = EvmTransactionLogDecodedInput | EvmTransactionLogDecoded;
/**
 * The EvmTransactionLogDecoded class is a MoralisData that references an EVM decoded transaction log.
 *
 * @category DataType
 */
declare class EvmTransactionLogDecoded extends EvmTransactionLog {
    /**
     * Create a new instance of EvmTransactionLogDecoded from any valid address input
     *
     * @example
     * ```
     * const log = EvmTransactionLogDecoded.create(value, core);
     * ```
     * @param value - A valid EvmTransactionLogDecodedish
     */
    static create(value: EvmTransactionLogDecodedish): EvmTransactionLogDecoded;
    protected _value: EvmTransactionLogDecodedData;
    constructor(value: EvmTransactionLogDecodedInput);
    static parse(value: EvmTransactionLogDecodedInput): EvmTransactionLogDecodedData;
    get decodedEvent(): EvmTransactionLogDecodedEvent;
}

/**
 * This can be any object with valid verbose transaction data.
 */
interface EvmTransactionVerboseInput extends EvmTransactionInput {
    chain: EvmChainish;
    logs: EvmTransactionLogDecodedish[];
    decodedCall: EvmTransactionLogDecodedEvent;
}
/**
 * This is the return type of the processed EVM verbose transaction
 */
interface EvmTransactionVerboseData extends EvmTransactionData {
    chain: EvmChain;
    logs: EvmTransactionLogDecoded[];
    decodedCall: EvmTransactionLogDecodedEvent;
}

/**
 * Valid input for a new EvmTransactionVerbose instance.
 * This can be an existing {@link EvmTransactionVerbose} or a valid {@link EvmTransactionVerboseInput} object
 */
type EvmTransactionVerboseish = EvmTransactionVerboseInput | EvmTransactionVerbose;
/**
 * The EvmTransactionVerbose is a representation of a published transaction.
 *
 * Use this class any time you work with a transaction.
 *
 * @category DataType
 */
declare class EvmTransactionVerbose extends EvmTransaction {
    /**
     * Create a new instance of EvmTransactionVerbose from any valid transaction input
     * @param data - the EvmTransactionVerboseish type
     * @example
     * ```
     * const transaction = EvmTransactionVerbose.create(data);
     *```
     */
    static create(data: EvmTransactionVerboseish): EvmTransactionVerbose;
    constructor(data: EvmTransactionVerboseInput);
    protected _data: EvmTransactionVerboseData;
    static parse: (data: EvmTransactionVerboseInput) => EvmTransactionVerboseData;
    get decodedCall(): EvmTransactionLogDecodedEvent;
    get logs(): EvmTransactionLogDecoded[];
}

/**
 * @deprecated Use `EvmTrade` instead.
 */
type EvmNftTrade = EvmTrade;
/**
 * @deprecated Don't use this type.
 */
type EvmNftTradeish = EvmTradeInput | EvmTrade;

interface EvmTradeJSON {
    readonly transaction_hash: string;
    readonly transaction_index: string;
    readonly token_ids: string[];
    readonly seller_address: EvmAddressJSON;
    readonly buyer_address: EvmAddressJSON;
    readonly token_address: EvmAddressJSON;
    readonly marketplace_address: EvmAddressJSON;
    readonly price_token_address?: EvmAddressJSON;
    readonly price: EvmNativeJSON;
    readonly block_timestamp: string;
    readonly block_number: BigNumberJSON;
    readonly block_hash: string;
}
interface EvmTradeInput {
    readonly transactionHash: string;
    readonly transactionIndex: number;
    readonly tokenIds: string[];
    readonly sellerAddress: EvmAddressInput | EvmAddress;
    readonly buyerAddress: EvmAddressInput | EvmAddress;
    readonly tokenAddress: EvmAddressInput | EvmAddress;
    readonly marketplaceAddress: EvmAddressInput | EvmAddress;
    readonly priceTokenAddress?: EvmAddressInput | EvmAddress;
    readonly price: EvmNativeInput | EvmNative;
    readonly blockTimestamp: Date;
    readonly blockNumber: BigNumberInput | BigNumber;
    readonly blockHash: string;
}
declare class EvmTrade {
    static create(input: EvmTradeInput | EvmTrade): EvmTrade;
    static fromJSON(json: EvmTradeJSON): EvmTrade;
    /**
     * @description The transaction hash
     */
    readonly transactionHash: string;
    /**
     * @description The transaction index
     */
    readonly transactionIndex: number;
    /**
     * @description The token ID(s) traded
     */
    readonly tokenIds: string[];
    /**
     * @description The address that sold the NFT
     */
    readonly sellerAddress: EvmAddress;
    /**
     * @description The address that bought the NFT
     */
    readonly buyerAddress: EvmAddress;
    /**
     * @description The address of the NFT contract
     */
    readonly tokenAddress: EvmAddress;
    /**
     * @description The address of the contract that traded the NFT
     */
    readonly marketplaceAddress: EvmAddress;
    /**
     * @description The address of the token used to pay for the NFT
     */
    readonly priceTokenAddress?: EvmAddress;
    /**
     * @description The value that was sent in the transaction (ETH/BNB/etc..)
     */
    readonly price: EvmNative;
    /**
     * @description The block timestamp
     */
    readonly blockTimestamp: Date;
    /**
     * @description The block number of the transaction
     */
    readonly blockNumber: BigNumber;
    /**
     * @description The block hash
     */
    readonly blockHash: string;
    private constructor();
    toJSON(): EvmTradeJSON;
}

interface EvmTradeCollectionJSON {
    readonly total?: number;
    readonly page?: number;
    readonly page_size?: number;
    readonly cursor?: string;
    readonly result?: EvmTradeJSON[];
}
interface EvmTradeCollectionInput {
    readonly total?: number;
    readonly page?: number;
    readonly pageSize?: number;
    readonly cursor?: string;
    readonly result?: EvmTradeInput[] | EvmTrade[];
}
declare class EvmTradeCollection {
    static create(input: EvmTradeCollectionInput | EvmTradeCollection): EvmTradeCollection;
    static fromJSON(json: EvmTradeCollectionJSON): EvmTradeCollection;
    /**
     * @description The total number of matches for this query
     */
    readonly total?: number;
    /**
     * @description The current page of the result
     */
    readonly page?: number;
    /**
     * @description The number of results per page
     */
    readonly pageSize?: number;
    /**
     * @description The cursor to get to the next page
     */
    readonly cursor?: string;
    readonly result?: EvmTrade[];
    private constructor();
    toJSON(): EvmTradeCollectionJSON;
}

interface EvmErc20TransferJSON {
    readonly token_name: string;
    readonly token_symbol: string;
    readonly token_logo?: string;
    readonly token_decimals: string;
    readonly contract_address: EvmAddressJSON;
    readonly transaction_hash: string;
    readonly transaction_index: string;
    readonly log_index: string;
    readonly block_timestamp: string;
    readonly block_number: BigNumberJSON;
    readonly block_hash: string;
    readonly from_wallet: EvmAddressJSON;
    readonly to_wallet: EvmAddressJSON;
    readonly value: string;
    readonly value_decimal: string;
    readonly possible_spam: boolean;
}
interface EvmErc20TransferInput {
    readonly tokenName: string;
    readonly tokenSymbol: string;
    readonly tokenLogo?: string;
    readonly tokenDecimals: number;
    readonly contractAddress: EvmAddressInput | EvmAddress;
    readonly transactionHash: string;
    readonly transactionIndex: number;
    readonly logIndex: number;
    readonly blockTimestamp: Date;
    readonly blockNumber: BigNumberInput | BigNumber;
    readonly blockHash: string;
    readonly fromWallet: EvmAddressInput | EvmAddress;
    readonly toWallet: EvmAddressInput | EvmAddress;
    readonly value: string;
    readonly valueDecimal: string;
    readonly possibleSpam: boolean;
}
declare class EvmErc20Transfer {
    static create(input: EvmErc20TransferInput | EvmErc20Transfer): EvmErc20Transfer;
    static fromJSON(json: EvmErc20TransferJSON): EvmErc20Transfer;
    readonly tokenName: string;
    readonly tokenSymbol: string;
    readonly tokenLogo?: string;
    readonly tokenDecimals: number;
    readonly contractAddress: EvmAddress;
    /**
     * @description The hash of the transaction
     */
    readonly transactionHash: string;
    readonly transactionIndex: number;
    readonly logIndex: number;
    /**
     * @description The timestamp of the block
     */
    readonly blockTimestamp: Date;
    /**
     * @description The block number
     */
    readonly blockNumber: BigNumber;
    /**
     * @description The hash of the block
     */
    readonly blockHash: string;
    /**
     * @description The address of the contract
     */
    readonly fromWallet: EvmAddress;
    /**
     * @description The address of the contract
     */
    readonly toWallet: EvmAddress;
    /**
     * @description The value of the transfer
     */
    readonly value: string;
    /**
     * @description The decimal value of the transfer
     */
    readonly valueDecimal: string;
    /**
     * @description Indicates if a contract is possibly a spam contract
     */
    readonly possibleSpam: boolean;
    private constructor();
    toJSON(): EvmErc20TransferJSON;
}

interface EvmErc20TransfersResponseJSON {
    readonly cursor?: string;
    readonly result?: EvmErc20TransferJSON[];
}
interface EvmErc20TransfersResponseInput {
    readonly cursor?: string;
    readonly result?: EvmErc20TransferInput[] | EvmErc20Transfer[];
}
declare class EvmErc20TransfersResponse {
    static create(input: EvmErc20TransfersResponseInput | EvmErc20TransfersResponse): EvmErc20TransfersResponse;
    static fromJSON(json: EvmErc20TransfersResponseJSON): EvmErc20TransfersResponse;
    /**
     * @description The cursor to get to the next page
     */
    readonly cursor?: string;
    readonly result?: EvmErc20Transfer[];
    private constructor();
    toJSON(): EvmErc20TransfersResponseJSON;
}

interface EvmWeb3versionJSON {
    readonly version: string;
}
interface EvmWeb3versionInput {
    readonly version: string;
}
declare class EvmWeb3version {
    static create(input: EvmWeb3versionInput | EvmWeb3version): EvmWeb3version;
    static fromJSON(json: EvmWeb3versionJSON): EvmWeb3version;
    /**
     * @description The version of the API
     */
    readonly version: string;
    private constructor();
    toJSON(): EvmWeb3versionJSON;
}

interface EvmEndpointWeightsJSON {
    readonly endpoint: string;
    readonly path: string;
    readonly rateLimitCost: string;
    readonly price: string;
}
interface EvmEndpointWeightsInput {
    readonly endpoint: string;
    readonly path: string;
    readonly rateLimitCost: string;
    readonly price: string;
}
declare class EvmEndpointWeights {
    static create(input: EvmEndpointWeightsInput | EvmEndpointWeights): EvmEndpointWeights;
    static fromJSON(json: EvmEndpointWeightsJSON): EvmEndpointWeights;
    /**
     * @description endpoint
     */
    readonly endpoint: string;
    /**
     * @description The path to the endpoint
     */
    readonly path: string;
    /**
     * @description The number of hits the request counts towards rate limiting
     */
    readonly rateLimitCost: string;
    /**
     * @description The number of compute units the request counts towards billing
     */
    readonly price: string;
    private constructor();
    toJSON(): EvmEndpointWeightsJSON;
}

interface EvmMarketDataERC20TokenItemJSON {
    readonly rank: number;
    readonly token_name: string;
    readonly token_symbol: string;
    readonly token_logo: string;
    readonly token_decimals: string;
    readonly contract_address: EvmAddressJSON;
    readonly price_usd: string;
    readonly price_24h_percent_change: string;
    readonly price_7d_percent_change: string;
    readonly market_cap_usd: string;
}
interface EvmMarketDataERC20TokenItemInput {
    readonly rank: number;
    readonly tokenName: string;
    readonly tokenSymbol: string;
    readonly tokenLogo: string;
    readonly tokenDecimals: number;
    readonly contractAddress: EvmAddressInput | EvmAddress;
    readonly priceUsd: string;
    readonly price24hPercentChange: string;
    readonly price7dPercentChange: string;
    readonly marketCapUsd: string;
}
declare class EvmMarketDataERC20TokenItem {
    static create(input: EvmMarketDataERC20TokenItemInput | EvmMarketDataERC20TokenItem): EvmMarketDataERC20TokenItem;
    static fromJSON(json: EvmMarketDataERC20TokenItemJSON): EvmMarketDataERC20TokenItem;
    /**
     * @description The rank
     */
    readonly rank: number;
    /**
     * @description The token name
     */
    readonly tokenName: string;
    /**
     * @description The token symbol
     */
    readonly tokenSymbol: string;
    /**
     * @description The token image
     */
    readonly tokenLogo: string;
    /**
     * @description The token decimals
     */
    readonly tokenDecimals: number;
    /**
     * @description The contract address
     */
    readonly contractAddress: EvmAddress;
    /**
     * @description The price in USD
     */
    readonly priceUsd: string;
    /**
     * @description The price change in the last 24h
     */
    readonly price24hPercentChange: string;
    /**
     * @description The price change in the last 7d
     */
    readonly price7dPercentChange: string;
    /**
     * @description The market cap in USD
     */
    readonly marketCapUsd: string;
    private constructor();
    toJSON(): EvmMarketDataERC20TokenItemJSON;
}

interface EvmMarketDataERC20TokensByPriceMoversJSON {
    readonly gainers: EvmMarketDataERC20TokenItemJSON[];
    readonly losers: EvmMarketDataERC20TokenItemJSON[];
}
interface EvmMarketDataERC20TokensByPriceMoversInput {
    readonly gainers: EvmMarketDataERC20TokenItemInput[] | EvmMarketDataERC20TokenItem[];
    readonly losers: EvmMarketDataERC20TokenItemInput[] | EvmMarketDataERC20TokenItem[];
}
declare class EvmMarketDataERC20TokensByPriceMovers {
    static create(input: EvmMarketDataERC20TokensByPriceMoversInput | EvmMarketDataERC20TokensByPriceMovers): EvmMarketDataERC20TokensByPriceMovers;
    static fromJSON(json: EvmMarketDataERC20TokensByPriceMoversJSON): EvmMarketDataERC20TokensByPriceMovers;
    readonly gainers: EvmMarketDataERC20TokenItem[];
    readonly losers: EvmMarketDataERC20TokenItem[];
    private constructor();
    toJSON(): EvmMarketDataERC20TokensByPriceMoversJSON;
}

interface EvmMarketDataTopNFTCollectionByMarketCapItemJSON {
    readonly rank: number;
    readonly collection_title: string;
    readonly collection_image: string;
    readonly floor_price_usd: string;
    readonly floor_price_24hr_percent_change: string;
    readonly market_cap_usd: string;
    readonly market_cap_24hr_percent_change: string;
    readonly volume_usd: string;
    readonly volume_24hr_percent_change: string;
}
interface EvmMarketDataTopNFTCollectionByMarketCapItemInput {
    readonly rank: number;
    readonly collectionTitle: string;
    readonly collectionImage: string;
    readonly floorPriceUsd: string;
    readonly floorPrice24hrPercentChange: string;
    readonly marketCapUsd: string;
    readonly marketCap24hrPercentChange: string;
    readonly volumeUsd: string;
    readonly volume24hrPercentChange: string;
}
declare class EvmMarketDataTopNFTCollectionByMarketCapItem {
    static create(input: EvmMarketDataTopNFTCollectionByMarketCapItemInput | EvmMarketDataTopNFTCollectionByMarketCapItem): EvmMarketDataTopNFTCollectionByMarketCapItem;
    static fromJSON(json: EvmMarketDataTopNFTCollectionByMarketCapItemJSON): EvmMarketDataTopNFTCollectionByMarketCapItem;
    /**
     * @description The rank
     */
    readonly rank: number;
    /**
     * @description The collection title
     */
    readonly collectionTitle: string;
    /**
     * @description The collection image
     */
    readonly collectionImage: string;
    /**
     * @description The floor price in USD
     */
    readonly floorPriceUsd: string;
    /**
     * @description The floor price 24hr percent change
     */
    readonly floorPrice24hrPercentChange: string;
    /**
     * @description The market cap in USD
     */
    readonly marketCapUsd: string;
    /**
     * @description The market cap 24hr percent change
     */
    readonly marketCap24hrPercentChange: string;
    /**
     * @description The volume in USD
     */
    readonly volumeUsd: string;
    /**
     * @description The volume 24hr percent change
     */
    readonly volume24hrPercentChange: string;
    private constructor();
    toJSON(): EvmMarketDataTopNFTCollectionByMarketCapItemJSON;
}

interface EvmMarketDataHottestNFTCollectionByTradingVolumeItemJSON {
    readonly rank: number;
    readonly collection_title: string;
    readonly collection_image: string;
    readonly floor_price_usd: string;
    readonly floor_price_24hr_percent_change: string;
    readonly volume_usd: string;
    readonly volume_24hr_percent_change: string;
    readonly average_price_usd?: string;
}
interface EvmMarketDataHottestNFTCollectionByTradingVolumeItemInput {
    readonly rank: number;
    readonly collectionTitle: string;
    readonly collectionImage: string;
    readonly floorPriceUsd: string;
    readonly floorPrice24hrPercentChange: string;
    readonly volumeUsd: string;
    readonly volume24hrPercentChange: string;
    readonly averagePriceUsd?: string;
}
declare class EvmMarketDataHottestNFTCollectionByTradingVolumeItem {
    static create(input: EvmMarketDataHottestNFTCollectionByTradingVolumeItemInput | EvmMarketDataHottestNFTCollectionByTradingVolumeItem): EvmMarketDataHottestNFTCollectionByTradingVolumeItem;
    static fromJSON(json: EvmMarketDataHottestNFTCollectionByTradingVolumeItemJSON): EvmMarketDataHottestNFTCollectionByTradingVolumeItem;
    /**
     * @description The rank
     */
    readonly rank: number;
    /**
     * @description The collection title
     */
    readonly collectionTitle: string;
    /**
     * @description The collection image
     */
    readonly collectionImage: string;
    /**
     * @description The floor price in USD
     */
    readonly floorPriceUsd: string;
    /**
     * @description The floor price 24hr percent change
     */
    readonly floorPrice24hrPercentChange: string;
    /**
     * @description The volume in USD
     */
    readonly volumeUsd: string;
    /**
     * @description The volume 24hr percent change
     */
    readonly volume24hrPercentChange: string;
    /**
     * @description The average price in USD
     */
    readonly averagePriceUsd?: string;
    private constructor();
    toJSON(): EvmMarketDataHottestNFTCollectionByTradingVolumeItemJSON;
}

interface EvmReviewContractsJSON {
    readonly message?: string;
}
interface EvmReviewContractsInput {
    readonly message?: string;
}
declare class EvmReviewContracts {
    static create(input: EvmReviewContractsInput | EvmReviewContracts): EvmReviewContracts;
    static fromJSON(json: EvmReviewContractsJSON): EvmReviewContracts;
    readonly message?: string;
    private constructor();
    toJSON(): EvmReviewContractsJSON;
}

interface EvmContractsReviewItemJSON {
    readonly contract_address: EvmAddressJSON;
    readonly reason: string;
    readonly report_type: EvmContractsReviewItemReportTypeEnumJSON;
    readonly contract_type: EvmContractsReviewItemContractTypeEnumJSON;
}
interface EvmContractsReviewItemInput {
    readonly contractAddress: EvmAddressInput | EvmAddress;
    readonly reason: string;
    readonly reportType: EvmContractsReviewItemReportTypeEnumInput | EvmContractsReviewItemReportTypeEnumValue;
    readonly contractType: EvmContractsReviewItemContractTypeEnumInput | EvmContractsReviewItemContractTypeEnumValue;
}
declare class EvmContractsReviewItem {
    static create(input: EvmContractsReviewItemInput | EvmContractsReviewItem): EvmContractsReviewItem;
    static fromJSON(json: EvmContractsReviewItemJSON): EvmContractsReviewItem;
    /**
     * @description The contract address
     */
    readonly contractAddress: EvmAddress;
    /**
     * @description The reason for the contract being spam
     */
    readonly reason: string;
    /**
     * @description This can be spam or not_spam
     */
    readonly reportType: EvmContractsReviewItemReportTypeEnumValue;
    /**
     * @description This can be ERC20, or NFT
     */
    readonly contractType: EvmContractsReviewItemContractTypeEnumValue;
    private constructor();
    toJSON(): EvmContractsReviewItemJSON;
}

interface EvmContractsReviewDtoJSON {
    readonly contracts: EvmContractsReviewItemJSON[];
}
interface EvmContractsReviewDtoInput {
    readonly contracts: EvmContractsReviewItemInput[] | EvmContractsReviewItem[];
}
declare class EvmContractsReviewDto {
    static create(input: EvmContractsReviewDtoInput | EvmContractsReviewDto): EvmContractsReviewDto;
    static fromJSON(json: EvmContractsReviewDtoJSON): EvmContractsReviewDto;
    /**
     * @description The contracts to be reported
     */
    readonly contracts: EvmContractsReviewItem[];
    private constructor();
    toJSON(): EvmContractsReviewDtoJSON;
}

interface GetNFTTradesOperationRequest {
    /**
     * @description The chain to query
     */
    readonly chain?: EvmChainInput | EvmChain;
    /**
     * @description The minimum block number from which to get the transfers
     * * Provide the param 'from_block' or 'from_date'
     * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
     */
    readonly fromBlock?: number;
    /**
     * @description The block number to get the trades from
     */
    readonly toBlock?: string;
    /**
     * @description The start date from which to get the transfers (any format that is accepted by momentjs)
     * * Provide the param 'from_block' or 'from_date'
     * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
     */
    readonly fromDate?: string;
    /**
     * @description The end date from which to get the transfers (any format that is accepted by momentjs)
     * * Provide the param 'to_block' or 'to_date'
     * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
     */
    readonly toDate?: string;
    /**
     * @description Marketplace from which to get the trades (only OpenSea is supported at the moment)
     */
    readonly marketplace?: EvmGetNFTTradesMarketplaceEnumInput | EvmGetNFTTradesMarketplaceEnumValue;
    /**
     * @description The cursor returned in the previous response (used for getting the next page).
     */
    readonly cursor?: string;
    /**
     * @description The desired page size of the result.
     */
    readonly limit?: number;
    /**
     * @description If the result should skip returning the total count (Improves performance).
     */
    readonly disableTotal?: boolean;
    /**
     * @description The address of the NFT contract
     */
    readonly address: EvmAddressInput | EvmAddress;
}
interface GetNFTTradesOperationRequestJSON {
    readonly chain?: EvmChainJSON;
    readonly from_block?: number;
    readonly to_block?: string;
    readonly from_date?: string;
    readonly to_date?: string;
    readonly marketplace?: EvmGetNFTTradesMarketplaceEnumJSON;
    readonly cursor?: string;
    readonly limit?: number;
    readonly disable_total?: boolean;
    readonly address: EvmAddressJSON;
}
type GetNFTTradesOperationResponse = EvmTradeCollection;
type GetNFTTradesOperationResponseJSON = EvmTradeCollectionJSON;
declare const GetNFTTradesOperation: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: EvmTradeCollectionJSON): EvmTradeCollection;
    serializeRequest(request: GetNFTTradesOperationRequest): GetNFTTradesOperationRequestJSON;
};

interface GetErc20TransfersOperationRequest {
    /**
     * @description The chain to query
     */
    readonly chain?: EvmChainInput | EvmChain;
    /**
     * @description The block number from which the transfers will be returned
     */
    readonly fromBlock?: number;
    /**
     * @description The block number to which the transfers will be returned
     */
    readonly toBlock?: number;
    /**
     * @description The desired page size of the result.
     */
    readonly limit?: number;
    /**
     * @description Contract addresses to only include
     */
    readonly contractAddresses?: EvmAddressInput[] | EvmAddress[];
    /**
     * @description Contract addresses to ignore
     */
    readonly excludeContracts?: EvmAddressInput[] | EvmAddress[];
    /**
     * @description Wallet addresses to only include
     */
    readonly walletAddresses?: EvmAddressInput[] | EvmAddress[];
    /**
     * @description Wallet addresses to ignore
     */
    readonly excludeWallets?: EvmAddressInput[] | EvmAddress[];
    /**
     * @description The cursor returned in the previous response (used to getting the next page).
     */
    readonly cursor?: string;
}
interface GetErc20TransfersOperationRequestJSON {
    readonly chain?: EvmChainJSON;
    readonly from_block?: number;
    readonly to_block?: number;
    readonly limit?: number;
    readonly contract_addresses?: EvmAddressJSON[];
    readonly exclude_contracts?: EvmAddressJSON[];
    readonly wallet_addresses?: EvmAddressJSON[];
    readonly exclude_wallets?: EvmAddressJSON[];
    readonly cursor?: string;
}
type GetErc20TransfersOperationResponse = EvmErc20TransfersResponse;
type GetErc20TransfersOperationResponseJSON = EvmErc20TransfersResponseJSON;
declare const GetErc20TransfersOperation: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: EvmErc20TransfersResponseJSON): EvmErc20TransfersResponse;
    serializeRequest(request: GetErc20TransfersOperationRequest): GetErc20TransfersOperationRequestJSON;
};

interface Web3ApiVersionOperationRequest {
}
interface Web3ApiVersionOperationRequestJSON {
}
type Web3ApiVersionOperationResponse = EvmWeb3version;
type Web3ApiVersionOperationResponseJSON = EvmWeb3versionJSON;
declare const Web3ApiVersionOperation: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: never[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: EvmWeb3versionJSON): EvmWeb3version;
    serializeRequest(request: Web3ApiVersionOperationRequest): Web3ApiVersionOperationRequestJSON;
};

interface EndpointWeightsOperationRequest {
}
interface EndpointWeightsOperationRequestJSON {
}
type EndpointWeightsOperationResponse = EvmEndpointWeights[];
type EndpointWeightsOperationResponseJSON = EvmEndpointWeightsJSON[];
declare const EndpointWeightsOperation: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: never[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: EvmEndpointWeightsJSON[]): EvmEndpointWeights[];
    serializeRequest(request: EndpointWeightsOperationRequest): EndpointWeightsOperationRequestJSON;
};

interface GetTopERC20TokensByMarketCapOperationRequest {
}
interface GetTopERC20TokensByMarketCapOperationRequestJSON {
}
type GetTopERC20TokensByMarketCapOperationResponse = EvmMarketDataERC20TokenItem[];
type GetTopERC20TokensByMarketCapOperationResponseJSON = EvmMarketDataERC20TokenItemJSON[];
declare const GetTopERC20TokensByMarketCapOperation: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: never[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: EvmMarketDataERC20TokenItemJSON[]): EvmMarketDataERC20TokenItem[];
    serializeRequest(request: GetTopERC20TokensByMarketCapOperationRequest): GetTopERC20TokensByMarketCapOperationRequestJSON;
};

interface GetTopERC20TokensByPriceMoversOperationRequest {
}
interface GetTopERC20TokensByPriceMoversOperationRequestJSON {
}
type GetTopERC20TokensByPriceMoversOperationResponse = EvmMarketDataERC20TokensByPriceMovers;
type GetTopERC20TokensByPriceMoversOperationResponseJSON = EvmMarketDataERC20TokensByPriceMoversJSON;
declare const GetTopERC20TokensByPriceMoversOperation: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: never[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: EvmMarketDataERC20TokensByPriceMoversJSON): EvmMarketDataERC20TokensByPriceMovers;
    serializeRequest(request: GetTopERC20TokensByPriceMoversOperationRequest): GetTopERC20TokensByPriceMoversOperationRequestJSON;
};

interface GetTopNFTCollectionsByMarketCapOperationRequest {
}
interface GetTopNFTCollectionsByMarketCapOperationRequestJSON {
}
type GetTopNFTCollectionsByMarketCapOperationResponse = EvmMarketDataTopNFTCollectionByMarketCapItem[];
type GetTopNFTCollectionsByMarketCapOperationResponseJSON = EvmMarketDataTopNFTCollectionByMarketCapItemJSON[];
declare const GetTopNFTCollectionsByMarketCapOperation: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: never[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: EvmMarketDataTopNFTCollectionByMarketCapItemJSON[]): EvmMarketDataTopNFTCollectionByMarketCapItem[];
    serializeRequest(request: GetTopNFTCollectionsByMarketCapOperationRequest): GetTopNFTCollectionsByMarketCapOperationRequestJSON;
};

interface GetHottestNFTCollectionsByTradingVolumeOperationRequest {
}
interface GetHottestNFTCollectionsByTradingVolumeOperationRequestJSON {
}
type GetHottestNFTCollectionsByTradingVolumeOperationResponse = EvmMarketDataHottestNFTCollectionByTradingVolumeItem[];
type GetHottestNFTCollectionsByTradingVolumeOperationResponseJSON = EvmMarketDataHottestNFTCollectionByTradingVolumeItemJSON[];
declare const GetHottestNFTCollectionsByTradingVolumeOperation: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: never[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: EvmMarketDataHottestNFTCollectionByTradingVolumeItemJSON[]): EvmMarketDataHottestNFTCollectionByTradingVolumeItem[];
    serializeRequest(request: GetHottestNFTCollectionsByTradingVolumeOperationRequest): GetHottestNFTCollectionsByTradingVolumeOperationRequestJSON;
};

interface ReviewContractsOperationRequest {
    /**
     * @description The chain to query
     */
    readonly chain?: EvmChainInput | EvmChain;
}
interface ReviewContractsOperationRequestJSON {
    readonly chain?: EvmChainJSON;
}
type ReviewContractsOperationResponse = EvmReviewContracts;
type ReviewContractsOperationResponseJSON = EvmReviewContractsJSON;
type ReviewContractsOperationBody = EvmContractsReviewDtoInput | EvmContractsReviewDto;
declare const ReviewContractsOperation: {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: EvmReviewContractsJSON): EvmReviewContracts;
    serializeRequest(request: ReviewContractsOperationRequest): ReviewContractsOperationRequestJSON;
    serializeBody(body: EvmContractsReviewDtoInput | EvmContractsReviewDto): EvmContractsReviewDtoJSON;
};

declare const operations: ({
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: EvmTradeCollectionJSON): EvmTradeCollection;
    serializeRequest(request: GetNFTTradesOperationRequest): GetNFTTradesOperationRequestJSON;
} | {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: EvmErc20TransfersResponseJSON): EvmErc20TransfersResponse;
    serializeRequest(request: GetErc20TransfersOperationRequest): GetErc20TransfersOperationRequestJSON;
} | {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: never[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: EvmWeb3versionJSON): EvmWeb3version;
    serializeRequest(request: Web3ApiVersionOperationRequest): Web3ApiVersionOperationRequestJSON;
} | {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: never[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: EvmEndpointWeightsJSON[]): EvmEndpointWeights[];
    serializeRequest(request: EndpointWeightsOperationRequest): EndpointWeightsOperationRequestJSON;
} | {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: never[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: EvmMarketDataERC20TokenItemJSON[]): EvmMarketDataERC20TokenItem[];
    serializeRequest(request: GetTopERC20TokensByMarketCapOperationRequest): GetTopERC20TokensByMarketCapOperationRequestJSON;
} | {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: never[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: EvmMarketDataERC20TokensByPriceMoversJSON): EvmMarketDataERC20TokensByPriceMovers;
    serializeRequest(request: GetTopERC20TokensByPriceMoversOperationRequest): GetTopERC20TokensByPriceMoversOperationRequestJSON;
} | {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: never[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: EvmMarketDataTopNFTCollectionByMarketCapItemJSON[]): EvmMarketDataTopNFTCollectionByMarketCapItem[];
    serializeRequest(request: GetTopNFTCollectionsByMarketCapOperationRequest): GetTopNFTCollectionsByMarketCapOperationRequestJSON;
} | {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: never[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: EvmMarketDataHottestNFTCollectionByTradingVolumeItemJSON[]): EvmMarketDataHottestNFTCollectionByTradingVolumeItem[];
    serializeRequest(request: GetHottestNFTCollectionsByTradingVolumeOperationRequest): GetHottestNFTCollectionsByTradingVolumeOperationRequestJSON;
} | {
    operationId: string;
    groupName: string;
    httpMethod: string;
    routePattern: string;
    parameterNames: string[];
    hasResponse: boolean;
    hasBody: boolean;
    parseResponse(json: EvmReviewContractsJSON): EvmReviewContracts;
    serializeRequest(request: ReviewContractsOperationRequest): ReviewContractsOperationRequestJSON;
    serializeBody(body: EvmContractsReviewDtoInput | EvmContractsReviewDto): EvmContractsReviewDtoJSON;
})[];

declare class CommonEvmUtils extends Module {
    static readonly moduleName = "evmUtils";
    static create(core?: Core): CommonEvmUtils;
    private constructor();
    setup(): void;
    start(): void;
    get EvmAddress(): typeof EvmAddress;
    get EvmChain(): typeof EvmChain;
    get EvmNative(): typeof EvmNative;
}

declare class EvmChainResolver {
    static resolve(chain: EvmChainish | undefined, core: Core): EvmChain;
}

type OperationId$M = 'getNativeBalance';
type PathParams$y = operations$1[OperationId$M]['parameters']['path'];
type QueryParams$H = operations$1[OperationId$M]['parameters']['query'];
type RequestParams$J = PathParams$y & QueryParams$H;
type SuccessResponse$M = operations$1[OperationId$M]['responses']['200']['content']['application/json'];
interface GetNativeBalanceRequest extends Camelize<Omit<RequestParams$J, 'chain' | 'address'>> {
    chain?: EvmChainish;
    address: EvmAddressish;
}
type GetNativeBalanceJSONRequest = ReturnType<typeof serializeRequest$K>;
type GetNativeBalanceJSONResponse = SuccessResponse$M;
type GetNativeBalanceResponse = ReturnType<typeof deserializeResponse$M>;
interface GetNativeBalanceResponseAdapter extends ResponseAdapter<GetNativeBalanceResponse, GetNativeBalanceJSONResponse> {
}
/** Get the native balance for a specific wallet address. */
declare const getNativeBalanceOperation: Operation<GetNativeBalanceRequest, GetNativeBalanceJSONRequest, GetNativeBalanceResponse, GetNativeBalanceJSONResponse>;
declare function deserializeResponse$M(jsonResponse: GetNativeBalanceJSONResponse): {
    balance: EvmNative;
};
declare function serializeRequest$K(request: GetNativeBalanceRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    toBlock: number | undefined;
    address: string;
};

type OperationId$L = 'getNativeBalancesForAddresses';
type QueryParams$G = operations$1[OperationId$L]['parameters']['query'];
type RequestParams$I = QueryParams$G;
type SuccessResponse$L = operations$1[OperationId$L]['responses']['200']['content']['application/json'];
interface GetNativeBalancesForAddressesRequest extends Camelize<Omit<RequestParams$I, 'chain' | 'wallet_addresses'>> {
    chain?: EvmChainish;
    walletAddresses: EvmAddressish[];
}
type GetNativeBalancesForAddressesJSONRequest = ReturnType<typeof serializeRequest$J>;
type GetNativeBalancesForAddressesJSONResponse = SuccessResponse$L;
type GetNativeBalancesForAddressesResponse = ReturnType<typeof deserializeResponse$L>;
interface GetNativeBalancesForAddressesResponseAdapter extends ResponseAdapter<GetNativeBalancesForAddressesResponse, GetNativeBalancesForAddressesJSONResponse> {
}
/** Get the native balances for a set of specific addresses */
declare const getNativeBalancesForAddressesOperation: Operation<GetNativeBalancesForAddressesRequest, GetNativeBalancesForAddressesJSONRequest, GetNativeBalancesForAddressesResponse, GetNativeBalancesForAddressesJSONResponse>;
declare function deserializeResponse$L(jsonResponse: GetNativeBalancesForAddressesJSONResponse, request: GetNativeBalancesForAddressesRequest, core: Core): {
    chain: EvmChain;
    blockNumber: string;
    blockTimestamp: string;
    totalBalance: EvmNative;
    walletBalances: {
        address: EvmAddress;
        balance: EvmNative;
    }[];
}[];
declare function serializeRequest$J(request: GetNativeBalancesForAddressesRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    toBlock: number | undefined;
    walletAddresses: string[];
};

type OperationId$K = 'getBlock';
type PathParams$x = operations$1[OperationId$K]['parameters']['path'];
type QueryParams$F = operations$1[OperationId$K]['parameters']['query'];
type RequestParams$H = PathParams$x & QueryParams$F;
type SuccessResponse$K = operations$1[OperationId$K]['responses']['200']['content']['application/json'];
interface GetBlockRequest extends Camelize<Omit<RequestParams$H, 'chain'>> {
    chain?: EvmChainish;
}
type GetBlockJSONRequest = ReturnType<typeof serializeRequest$I>;
type GetBlockJSONResponse = SuccessResponse$K;
type GetBlockResponse = ReturnType<typeof deserializeResponse$K>;
interface GetBlockResponseAdapter extends ResponseAdapter<GetBlockResponse, GetBlockJSONResponse> {
}
/** Get the contents of a block given the block hash. */
declare const getBlockOperation: Operation<GetBlockRequest, GetBlockJSONRequest, GetBlockResponse, GetBlockJSONResponse>;
declare function deserializeResponse$K(jsonResponse: GetBlockJSONResponse, request: GetBlockRequest, core: Core): EvmBlock;
declare function serializeRequest$I(request: GetBlockRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    blockNumberOrHash: string;
    include: "internal_transactions" | undefined;
};

type OperationId$J = 'getDateToBlock';
type QueryParams$E = operations$1[OperationId$J]['parameters']['query'];
type RequestParams$G = QueryParams$E;
type SuccessResponse$J = operations$1[OperationId$J]['responses']['200']['content']['application/json'];
interface GetDateToBlockRequest extends Camelize<Omit<RequestParams$G, 'chain' | 'date'>> {
    chain?: EvmChainish;
    date: DateInput;
}
type GetDateToBlockJSONRequest = ReturnType<typeof serializeRequest$H>;
type GetDateToBlockJSONResponse = SuccessResponse$J;
type GetDateToBlockResponse = ReturnType<typeof deserializeResponse$J>;
interface GetDateToBlockResponseAdapter extends ResponseAdapter<GetDateToBlockResponse, GetDateToBlockJSONResponse> {
}
/** Get the closest block given the date. */
declare const getDateToBlockOperation: Operation<GetDateToBlockRequest, GetDateToBlockJSONRequest, GetDateToBlockResponse, GetDateToBlockJSONResponse>;
declare function deserializeResponse$J(jsonResponse: GetDateToBlockJSONResponse): EvmBlockDate;
declare function serializeRequest$H(request: GetDateToBlockRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    date: string;
};

type OperationId$I = 'getPairAddress';
type PathParams$w = operations$1[OperationId$I]['parameters']['path'];
type QueryParams$D = operations$1[OperationId$I]['parameters']['query'];
type RequestParams$F = PathParams$w & QueryParams$D;
type SuccessResponse$I = operations$1[OperationId$I]['responses']['200']['content']['application/json'];
interface GetPairAddressRequest extends Camelize<Omit<RequestParams$F, 'chain' | 'token0_address' | 'token1_address' | 'to_date'>> {
    chain?: EvmChainish;
    token0Address: EvmAddressish;
    token1Address: EvmAddressish;
    toDate?: DateInput;
}
type GetPairAddressJSONRequest = ReturnType<typeof serializeRequest$G>;
type GetPairAddressJSONResponse = SuccessResponse$I;
type GetPairAddressResponse = ReturnType<typeof deserializeResponse$I>;
interface GetPairAddressResponseAdapter extends ResponseAdapter<GetPairAddressResponse, GetPairAddressJSONResponse> {
}
/**
 * Fetch the pair data of the provided token0+token1 combination.
 * The token0 and token1 options are interchangable (ie. there is no different outcome in "token0=WETH and token1=USDT" or "token0=USDT and token1=WETH")
 */
declare const getPairAddressOperation: Operation<GetPairAddressRequest, GetPairAddressJSONRequest, GetPairAddressResponse, GetPairAddressJSONResponse>;
declare function deserializeResponse$I(jsonResponse: GetPairAddressJSONResponse, request: GetPairAddressRequest, core: Core): {
    token0: {
        token: Erc20Token;
        blockNumber: string | undefined;
        validated: number | undefined;
        createdAt: Date | undefined;
    };
    token1: {
        token: Erc20Token;
        blockNumber: string | undefined;
        validated: number | undefined;
        createdAt: Date | undefined;
    };
    pairAddress: EvmAddress | undefined;
};
declare function serializeRequest$G(request: GetPairAddressRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    toBlock: string | undefined;
    toDate: string | undefined;
    exchange: Camelize<"uniswapv2" | "uniswapv3" | "sushiswapv2" | "pancakeswapv2" | "pancakeswapv1" | "quickswap">;
    token0Address: string;
    token1Address: string;
};

type OperationId$H = 'getPairReserves';
type PathParams$v = operations$1[OperationId$H]['parameters']['path'];
type QueryParams$C = operations$1[OperationId$H]['parameters']['query'];
type RequestParams$E = PathParams$v & QueryParams$C;
type SuccessResponse$H = operations$1[OperationId$H]['responses']['200']['content']['application/json'];
interface GetPairReservesRequest extends Camelize<Omit<RequestParams$E, 'chain' | 'pair_address' | 'to_date'>> {
    chain?: EvmChainish;
    pairAddress: EvmAddressish;
    toDate?: DateInput;
}
type GetPairReservesJSONRequest = ReturnType<typeof serializeRequest$F>;
type GetPairReservesJSONResponse = SuccessResponse$H;
type GetPairReservesResponse = ReturnType<typeof deserializeResponse$H>;
interface GetPairReservesResponseAdapter extends ResponseAdapter<GetPairReservesResponse, GetPairReservesJSONResponse> {
}
/** Get the liquidity reserves for a given pair address. Only Uniswap V2 based exchanges supported at the moment. */
declare const getPairReservesOperation: Operation<GetPairReservesRequest, GetPairReservesJSONRequest, GetPairReservesResponse, GetPairReservesJSONResponse>;
declare function serializeRequest$F(request: GetPairReservesRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    toBlock: string | undefined;
    toDate: string | undefined;
    pairAddress: string;
};
declare function deserializeResponse$H(jsonResponse: GetPairReservesJSONResponse): {
    reserve0?: string | undefined;
    reserve1?: string | undefined;
};

type OperationId$G = 'getContractEvents';
type PathParams$u = operations$1[OperationId$G]['parameters']['path'];
type QueryParams$B = operations$1[OperationId$G]['parameters']['query'];
type RequestParams$D = PathParams$u & QueryParams$B;
type SuccessResponse$G = operations$1[OperationId$G]['responses']['200']['content']['application/json'];
interface GetContractEventsRequest extends Camelize<Omit<RequestParams$D, 'chain' | 'address' | 'from_date' | 'to_date'>> {
    chain?: EvmChainish;
    address: EvmAddressish;
    abi: EvmAbiItem;
    fromDate?: DateInput;
    toDate?: DateInput;
}
type GetContractEventsJSONRequest = ReturnType<typeof serializeRequest$E>;
type GetContractEventsJSONResponse = SuccessResponse$G;
type GetContractEventsResponse = ReturnType<typeof deserializeResponse$G>;
interface GetContractEventsResponseAdapter extends PaginatedResponseAdapter<GetContractEventsResponse, GetContractEventsJSONResponse['result']> {
}
/** Get events for a contract ordered by block number in descending order. */
declare const getContractEventsOperation: PaginatedOperation<GetContractEventsRequest, GetContractEventsJSONRequest, GetContractEventsResponse, GetContractEventsJSONResponse['result']>;
declare function deserializeResponse$G(jsonResponse: GetContractEventsJSONResponse, request: GetContractEventsRequest, core: Core): EvmEvent[];
declare function serializeRequest$E(request: GetContractEventsRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    fromBlock: number | undefined;
    toBlock: number | undefined;
    fromDate: string | undefined;
    toDate: string | undefined;
    topic: string;
    offset: number | undefined;
    limit: number | undefined;
    address: string;
    abi: EvmAbiItem;
    disableTotal: boolean | undefined;
};

type OperationId$F = 'getContractLogs';
type PathParams$t = operations$1[OperationId$F]['parameters']['path'];
type QueryParams$A = operations$1[OperationId$F]['parameters']['query'];
type RequestParams$C = PathParams$t & QueryParams$A;
type SuccessResponse$F = operations$1[OperationId$F]['responses']['200']['content']['application/json'];
interface GetContractLogsRequest extends Camelize<Omit<RequestParams$C, 'chain' | 'address' | 'from_date' | 'to_date'>> {
    chain?: EvmChainish;
    address: EvmAddressish;
    fromDate?: DateInput;
    toDate?: DateInput;
}
type GetContractLogsJSONRequest = ReturnType<typeof serializeRequest$D>;
type GetContractLogsJSONResponse = SuccessResponse$F;
type GetContractLogsResponse = ReturnType<typeof deserializeResponse$F>;
interface GetContractLogsResponseAdapter extends PaginatedResponseAdapter<GetContractLogsResponse, GetContractLogsJSONResponse['result']> {
}
/** Get the logs for a contract. */
declare const getContractLogsOperation: PaginatedOperation<GetContractLogsRequest, GetContractLogsJSONRequest, GetContractLogsResponse, GetContractLogsJSONResponse['result']>;
declare function serializeRequest$D(request: GetContractLogsRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    blockNumber: string | undefined;
    fromBlock: string | undefined;
    toBlock: string | undefined;
    fromDate: string | undefined;
    toDate: string | undefined;
    topic0: string | undefined;
    topic1: string | undefined;
    topic2: string | undefined;
    topic3: string | undefined;
    limit: number | undefined;
    cursor: string | undefined;
    address: string;
    disableTotal: boolean | undefined;
};
declare function deserializeResponse$F(jsonResponse: GetContractLogsJSONResponse, request: GetContractLogsRequest, core: Core): EvmTransactionLog[];

type OperationId$E = 'uploadFolder';
type SuccessResponse$E = operations$1[OperationId$E]['responses']['200']['content']['application/json'];
interface UploadFolderRequest {
    abi: {
        path: string;
        content: string;
    }[];
}
type UploadFolderJSONRequest = ReturnType<typeof serializeRequest$C>;
type UploadFolderJSONResponse = SuccessResponse$E;
type UploadFolderResponse = ReturnType<typeof deserializeResponse$E>;
interface UploadFolderResponseAdapter extends ResponseAdapter<UploadFolderResponse, UploadFolderJSONResponse> {
}
/** Upload multiple files to IPFS and place them in a folder directory. */
declare const uploadFolderOperation: Operation<UploadFolderRequest, UploadFolderJSONRequest, UploadFolderResponse, UploadFolderJSONResponse>;
declare function deserializeResponse$E(jsonResponse: UploadFolderJSONResponse): {
    path: string;
}[];
declare function serializeRequest$C(request: UploadFolderRequest): {
    abi: string;
};

type OperationId$D = 'getContractNFTs';
type PathParams$s = operations$1[OperationId$D]['parameters']['path'];
type QueryParams$z = operations$1[OperationId$D]['parameters']['query'];
type RequestParams$B = PathParams$s & QueryParams$z;
type SuccessResponse$D = operations$1[OperationId$D]['responses']['200']['content']['application/json'];
interface GetContractNFTsRequest extends Camelize<Omit<RequestParams$B, 'chain' | 'address'>> {
    chain?: EvmChainish;
    address: EvmAddressish;
}
type GetContractNFTsJSONRequest = ReturnType<typeof serializeRequest$B>;
type GetContractNFTsJSONResponse = SuccessResponse$D;
type GetContractNFTsResponse = ReturnType<typeof deserializeResponse$D>;
interface GetContractNFTsResponseAdapter extends PaginatedResponseAdapter<GetContractNFTsResponse, GetContractNFTsJSONResponse['result']> {
}
/**
 * Get NFTs for a given contract address, including metadata for all NFTs (where available).
 * * Results are limited to 100 per page by default
 * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection.
 */
declare const getContractNFTsOperation: PaginatedOperation<GetContractNFTsRequest, GetContractNFTsJSONRequest, GetContractNFTsResponse, GetContractNFTsJSONResponse['result']>;
declare function deserializeResponse$D(jsonResponse: GetContractNFTsJSONResponse, request: GetContractNFTsRequest, core: Core): EvmNft[];
declare function serializeRequest$B(request: GetContractNFTsRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    format: "decimal" | "hex" | undefined;
    limit: number | undefined;
    totalRanges: number | undefined;
    range: number | undefined;
    cursor: string | undefined;
    address: string;
    normalizeMetadata: boolean | undefined;
    disableTotal: boolean | undefined;
    mediaItems: boolean | undefined;
};

type GetElementType<Element extends unknown[]> = Element extends (infer Infered)[] ? Infered : never;
type OperationId$C = 'getMultipleNFTs';
type QueryParams$y = operations$1[OperationId$C]['parameters']['query'];
type BodyParams$1 = operations$1[OperationId$C]['requestBody']['content']['application/json'];
type RequestParams$A = QueryParams$y & BodyParams$1;
type SuccessElement = GetElementType<operations$1[OperationId$C]['responses']['200']['content']['application/json']>;
type SuccessResponse$C = (SuccessElement | null)[];
interface GetMultipleNFTsRequest extends Camelize<Omit<RequestParams$A, 'chain' | 'tokens'>> {
    chain?: EvmChainish;
    tokens: {
        tokenAddress: EvmAddressish;
        tokenId: string;
    }[];
}
type GetMultipleNFTsJSONRequest = ReturnType<typeof serializeRequest$A>;
type GetMultipleNFTsJSONResponse = SuccessResponse$C;
type GetMultipleNFTsResponse = ReturnType<typeof deserializeResponse$C>;
interface GetMultipleNFTsResponseAdapter extends ResponseAdapter<GetMultipleNFTsResponse, GetMultipleNFTsJSONResponse> {
}
/**
 * Get NFTs for a given contract address, including metadata for all NFTs (where available).
 * * Results are limited to 100 per page by default
 * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection.
 */
declare const getMultipleNFTsOperation: Operation<GetMultipleNFTsRequest, GetMultipleNFTsJSONRequest, GetMultipleNFTsResponse, GetMultipleNFTsJSONResponse>;
declare function deserializeResponse$C(jsonResponse: GetMultipleNFTsJSONResponse, request: GetMultipleNFTsRequest, core: Core): (EvmNft | null)[];
declare function serializeRequest$A(request: GetMultipleNFTsRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    normalizeMetadata: boolean | undefined;
    tokens: {
        tokenAddress: string;
        tokenId: string;
    }[];
    mediaItems: boolean | undefined;
};

type OperationId$B = 'getNFTContractMetadata';
type PathParams$r = operations$1[OperationId$B]['parameters']['path'];
type QueryParams$x = operations$1[OperationId$B]['parameters']['query'];
type RequestParams$z = PathParams$r & QueryParams$x;
type SuccessResponse$B = operations$1[OperationId$B]['responses']['200']['content']['application/json'];
interface GetNFTContractMetadataRequest extends Camelize<Omit<RequestParams$z, 'chain' | 'address'>> {
    chain?: EvmChainish;
    address: EvmAddressish;
}
type GetNFTContractMetadataJSONRequest = ReturnType<typeof serializeRequest$z>;
type GetNFTContractMetadataJSONResponse = SuccessResponse$B;
type GetNFTContractMetadataResponse = ReturnType<typeof deserializeResponse$B>;
interface GetNFTContractMetadataResponseAdapter extends ResponseAdapter<GetNFTContractMetadataResponse, GetNFTContractMetadataJSONResponse> {
}
/**
 * Get the collection / contract level metadata for a given contract (name, symbol, base token uri).
 * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
 */
declare const getNFTContractMetadataOperation: Operation<GetNFTContractMetadataRequest, GetNFTContractMetadataJSONRequest, GetNFTContractMetadataResponse, GetNFTContractMetadataJSONResponse>;
declare function deserializeResponse$B(jsonResponse: GetNFTContractMetadataJSONResponse, request: GetNFTContractMetadataRequest, core: Core): EvmNftMetadata;
declare function serializeRequest$z(request: GetNFTContractMetadataRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    address: string;
};

type OperationId$A = 'getNFTContractTransfers';
type PathParams$q = operations$1[OperationId$A]['parameters']['path'];
type QueryParams$w = operations$1[OperationId$A]['parameters']['query'];
type RequestParams$y = PathParams$q & QueryParams$w;
type SuccessResponse$A = operations$1[OperationId$A]['responses']['200']['content']['application/json'];
interface GetNFTContractTransfersRequest extends Camelize<Omit<RequestParams$y, 'chain' | 'address' | 'from_date' | 'to_date'>> {
    chain?: EvmChainish;
    address: EvmAddressish;
    fromDate?: DateInput;
    toDate?: DateInput;
}
type GetNFTContractTransfersJSONRequest = ReturnType<typeof serializeRequest$y>;
type GetNFTContractTransfersJSONResponse = SuccessResponse$A;
type GetNFTContractTransfersResponse = ReturnType<typeof deserializeResponse$A>;
interface GetNFTContractTransfersResponseAdapter extends PaginatedResponseAdapter<GetNFTContractTransfersResponse, GetNFTContractTransfersJSONResponse['result']> {
}
/** Get transfers of NFTs for a given contract and other parameters. */
declare const getNFTContractTransfersOperation: PaginatedOperation<GetNFTContractTransfersRequest, GetNFTContractTransfersJSONRequest, GetNFTContractTransfersResponse, GetNFTContractTransfersJSONResponse['result']>;
declare function deserializeResponse$A(jsonResponse: GetNFTContractTransfersJSONResponse, request: GetNFTContractTransfersRequest, core: Core): EvmNftTransfer[];
declare function serializeRequest$y(request: GetNFTContractTransfersRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    format: "decimal" | "hex" | undefined;
    limit: number | undefined;
    cursor: string | undefined;
    address: string;
    fromBlock: number | undefined;
    toBlock: number | undefined;
    fromDate: string | undefined;
    toDate: string | undefined;
    disableTotal: boolean | undefined;
};

type OperationId$z = 'getNFTLowestPrice';
type PathParams$p = operations$1[OperationId$z]['parameters']['path'];
type QueryParams$v = operations$1[OperationId$z]['parameters']['query'];
type RequestParams$x = PathParams$p & QueryParams$v;
type SuccessResponse$z = operations$1[OperationId$z]['responses']['200']['content']['application/json'];
interface GetNFTLowestPriceRequest extends Camelize<Omit<RequestParams$x, 'chain' | 'address'>> {
    chain?: EvmChainish;
    address: EvmAddressish;
}
type GetNFTLowestPriceJSONRequest = ReturnType<typeof serializeRequest$x>;
type GetNFTLowestPriceJSONResponse = SuccessResponse$z;
type GetNFTLowestPriceResponse = ReturnType<typeof deserializeResponse$z>;
interface GetNFTLowestPriceResponseAdapter extends ResponseAdapter<GetNFTLowestPriceResponse, GetNFTLowestPriceJSONResponse> {
}
/** Get the lowest executed price for an NFT contract for the last x days (only trades paid in ETH). */
declare const getNFTLowestPriceOperation: Operation<GetNFTLowestPriceRequest, GetNFTLowestPriceJSONRequest, GetNFTLowestPriceResponse, GetNFTLowestPriceJSONResponse>;
declare function deserializeResponse$z(jsonResponse: GetNFTLowestPriceJSONResponse): EvmTrade;
declare function serializeRequest$x(request: GetNFTLowestPriceRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    days: number | undefined;
    marketplace: "opensea" | undefined;
    address: string;
};

type OperationId$y = 'getNFTMetadata';
type PathParams$o = operations$1[OperationId$y]['parameters']['path'];
type QueryParams$u = operations$1[OperationId$y]['parameters']['query'];
type RequestParams$w = PathParams$o & QueryParams$u;
type SuccessResponse$y = operations$1[OperationId$y]['responses']['200']['content']['application/json'];
interface GetNFTMetadataRequest extends Camelize<Omit<RequestParams$w, 'chain' | 'address'>> {
    chain?: EvmChainish;
    address: EvmAddressish;
}
type GetNFTMetadataJSONRequest = ReturnType<typeof serializeRequest$w>;
type GetNFTMetadataJSONResponse = SuccessResponse$y;
type GetNFTMetadataResponse = ReturnType<typeof deserializeResponse$y>;
interface GetNFTMetadataResponseAdapter extends ResponseAdapter<GetNFTMetadataResponse, GetNFTMetadataJSONResponse> {
}
/**
 * Get NFT data, including metadata (where available), for the given NFT token ID and contract address.
 * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
 */
declare const getNFTMetadataOperation: Operation<GetNFTMetadataRequest, GetNFTMetadataJSONRequest, GetNFTMetadataResponse, GetNFTMetadataJSONResponse>;
declare function deserializeResponse$y(jsonResponse: GetNFTMetadataJSONResponse, request: GetNFTMetadataRequest, core: Core): EvmNft;
declare function serializeRequest$w(request: GetNFTMetadataRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    format: "decimal" | "hex" | undefined;
    address: string;
    tokenId: string;
    normalizeMetadata: boolean | undefined;
    mediaItems: boolean | undefined;
};

type OperationId$x = 'getNFTOwners';
type PathParams$n = operations$1[OperationId$x]['parameters']['path'];
type QueryParams$t = operations$1[OperationId$x]['parameters']['query'];
type RequestParams$v = PathParams$n & QueryParams$t;
type SuccessResponse$x = operations$1[OperationId$x]['responses']['200']['content']['application/json'];
interface GetNFTOwnersRequest extends Camelize<Omit<RequestParams$v, 'chain' | 'address'>> {
    chain?: EvmChainish;
    address: EvmAddressish;
}
type GetNFTOwnersJSONRequest = ReturnType<typeof serializeRequest$v>;
type GetNFTOwnersJSONResponse = SuccessResponse$x;
type GetNFTOwnersResponse = ReturnType<typeof deserializeResponse$x>;
interface GetNFTOwnersResponseAdapter extends PaginatedResponseAdapter<GetNFTOwnersResponse, GetNFTOwnersJSONResponse['result']> {
}
/**
 * Get owners of NFTs for a given contract.
 * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection.
 */
declare const getNFTOwnersOperation: PaginatedOperation<GetNFTOwnersRequest, GetNFTOwnersJSONRequest, GetNFTOwnersResponse, GetNFTOwnersJSONResponse['result']>;
declare function deserializeResponse$x(jsonResponse: GetNFTOwnersJSONResponse, request: GetNFTOwnersRequest, core: Core): EvmNft[];
declare function serializeRequest$v(request: GetNFTOwnersRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    format: "decimal" | "hex" | undefined;
    limit: number | undefined;
    cursor: string | undefined;
    address: string;
    normalizeMetadata: boolean | undefined;
    disableTotal: boolean | undefined;
    mediaItems: boolean | undefined;
};

type OperationId$w = 'getNFTTokenIdOwners';
type PathParams$m = operations$1[OperationId$w]['parameters']['path'];
type QueryParams$s = operations$1[OperationId$w]['parameters']['query'];
type RequestParams$u = PathParams$m & QueryParams$s;
type SuccessResponse$w = operations$1[OperationId$w]['responses']['200']['content']['application/json'];
interface GetNFTTokenIdOwnersRequest extends Camelize<Omit<RequestParams$u, 'chain' | 'address'>> {
    chain?: EvmChainish;
    address: EvmAddressish;
}
type GetNFTTokenIdOwnersJSONRequest = ReturnType<typeof serializeRequest$u>;
type GetNFTTokenIdOwnersJSONResponse = SuccessResponse$w;
type GetNFTTokenIdOwnersResponse = ReturnType<typeof deserializeResponse$w>;
interface GetNFTTokenIdOwnersResponseAdapter extends PaginatedResponseAdapter<GetNFTTokenIdOwnersResponse, GetNFTTokenIdOwnersJSONResponse['result']> {
}
/**
 * Get owners of a specific NFT given the contract address and token ID.
 * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
 */
declare const getNFTTokenIdOwnersOperation: PaginatedOperation<GetNFTTokenIdOwnersRequest, GetNFTTokenIdOwnersJSONRequest, GetNFTTokenIdOwnersResponse, GetNFTTokenIdOwnersJSONResponse['result']>;
declare function deserializeResponse$w(jsonResponse: GetNFTTokenIdOwnersJSONResponse, request: GetNFTTokenIdOwnersRequest, core: Core): EvmNft[];
declare function serializeRequest$u(request: GetNFTTokenIdOwnersRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    format: "decimal" | "hex" | undefined;
    limit: number | undefined;
    cursor: string | undefined;
    address: string;
    tokenId: string;
    normalizeMetadata: boolean | undefined;
    disableTotal: boolean | undefined;
    mediaItems: boolean | undefined;
};

type OperationId$v = 'getNFTTrades';
type PathParams$l = operations$1[OperationId$v]['parameters']['path'];
type QueryParams$r = operations$1[OperationId$v]['parameters']['query'];
type RequestParams$t = PathParams$l & QueryParams$r;
type SuccessResponse$v = operations$1[OperationId$v]['responses']['200']['content']['application/json'];
interface GetNFTTradesRequest extends Camelize<Omit<RequestParams$t, 'chain' | 'address' | 'from_date' | 'to_date'>> {
    chain?: EvmChainish;
    address: EvmAddressish;
    fromDate?: DateInput;
    toDate?: DateInput;
}
type GetNFTTradesJSONRequest = ReturnType<typeof serializeRequest$t>;
type GetNFTTradesJSONResponse = SuccessResponse$v;
type GetNFTTradesResponse = ReturnType<typeof deserializeResponse$v>;
interface GetNFTTradesResponseAdapter extends PaginatedResponseAdapter<GetNFTTradesResponse, GetNFTTradesJSONResponse['result']> {
}
/** Get trades of NFTs for a given contract and marketplace. */
declare const getNFTTradesOperation: PaginatedOperation<GetNFTTradesRequest, GetNFTTradesJSONRequest, GetNFTTradesResponse, GetNFTTradesJSONResponse['result']>;
declare function deserializeResponse$v(jsonResponse: GetNFTTradesJSONResponse): EvmTrade[];
declare function serializeRequest$t(request: GetNFTTradesRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    fromBlock: number | undefined;
    toBlock: string | undefined;
    fromDate: DateInput | undefined;
    toDate: DateInput | undefined;
    marketplace: "opensea" | undefined;
    cursor: string | undefined;
    limit: number | undefined;
    address: string;
    disableTotal: boolean | undefined;
};

type OperationId$u = 'getNFTTransfersByBlock';
type PathParams$k = operations$1[OperationId$u]['parameters']['path'];
type QueryParams$q = operations$1[OperationId$u]['parameters']['query'];
type RequestParams$s = PathParams$k & QueryParams$q;
type SuccessResponse$u = operations$1[OperationId$u]['responses']['200']['content']['application/json'];
interface GetNFTTransfersByBlockRequest extends Camelize<Omit<RequestParams$s, 'chain'>> {
    chain?: EvmChainish;
}
type GetNFTTransfersByBlockJSONRequest = ReturnType<typeof serializeRequest$s>;
type GetNFTTransfersByBlockJSONResponse = SuccessResponse$u;
type GetNFTTransfersByBlockResponse = ReturnType<typeof deserializeResponse$u>;
interface GetNFTTransfersByBlockResponseAdapter extends PaginatedResponseAdapter<GetNFTTransfersByBlockResponse, GetNFTTransfersByBlockJSONResponse['result']> {
}
/** Get transfers of NFTs given a block number or block hash. */
declare const getNFTTransfersByBlockOperation: PaginatedOperation<GetNFTTransfersByBlockRequest, GetNFTTransfersByBlockJSONRequest, GetNFTTransfersByBlockResponse, GetNFTTransfersByBlockJSONResponse['result']>;
declare function deserializeResponse$u(jsonResponse: GetNFTTransfersByBlockJSONResponse, request: GetNFTTransfersByBlockRequest, core: Core): EvmNftTransfer[];
declare function serializeRequest$s(request: GetNFTTransfersByBlockRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    limit: number | undefined;
    cursor: string | undefined;
    blockNumberOrHash: string;
    disableTotal: boolean | undefined;
};

type OperationId$t = 'getNFTTransfersFromToBlock';
type QueryParams$p = operations$1[OperationId$t]['parameters']['query'];
type RequestParams$r = QueryParams$p;
type SuccessResponse$t = operations$1[OperationId$t]['responses']['200']['content']['application/json'];
interface GetNFTTransfersFromToBlockRequest extends Camelize<Omit<RequestParams$r, 'chain' | 'from_date' | 'to_date'>> {
    chain?: EvmChainish;
    fromDate?: DateInput;
    toDate?: DateInput;
}
type GetNFTTransfersFromToBlockJSONRequest = ReturnType<typeof serializeRequest$r>;
type GetNFTTransfersFromToBlockJSONResponse = SuccessResponse$t;
type GetNFTTransfersFromToBlockResponse = ReturnType<typeof deserializeResponse$t>;
interface GetNFTTransfersFromToBlockResponseAdapter extends PaginatedResponseAdapter<GetNFTTransfersFromToBlockResponse, GetNFTTransfersFromToBlockJSONResponse['result']> {
}
/** Get transfers of NFTs from a block number to a block number. */
declare const getNFTTransfersFromToBlockOperation: PaginatedOperation<GetNFTTransfersFromToBlockRequest, GetNFTTransfersFromToBlockJSONRequest, GetNFTTransfersFromToBlockResponse, GetNFTTransfersFromToBlockJSONResponse['result']>;
declare function deserializeResponse$t(jsonResponse: GetNFTTransfersFromToBlockJSONResponse, request: GetNFTTransfersFromToBlockRequest, core: Core): EvmNftTransfer[];
declare function serializeRequest$r(request: GetNFTTransfersFromToBlockRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    fromBlock: number | undefined;
    toBlock: number | undefined;
    fromDate: DateInput | undefined;
    toDate: DateInput | undefined;
    format: "decimal" | "hex" | undefined;
    limit: number | undefined;
    cursor: string | undefined;
    disableTotal: boolean | undefined;
};

type OperationId$s = 'getNFTTransfers';
type PathParams$j = operations$1[OperationId$s]['parameters']['path'];
type QueryParams$o = operations$1[OperationId$s]['parameters']['query'];
type RequestParams$q = PathParams$j & QueryParams$o;
type SuccessResponse$s = operations$1[OperationId$s]['responses']['200']['content']['application/json'];
interface GetNFTTransfersRequest extends Camelize<Omit<RequestParams$q, 'chain' | 'address'>> {
    chain?: EvmChainish;
    address: EvmAddressish;
}
type GetNFTTransfersJSONRequest = ReturnType<typeof serializeRequest$q>;
type GetNFTTransfersJSONResponse = SuccessResponse$s;
type GetNFTTransfersResponse = ReturnType<typeof deserializeResponse$s>;
interface GetNFTTransfersResponseAdapter extends PaginatedResponseAdapter<GetNFTTransfersResponse, GetNFTTransfersJSONResponse['result']> {
}
/** Get transfers of an NFT given a contract address and token ID. */
declare const getNFTTransfersOperation: PaginatedOperation<GetNFTTransfersRequest, GetNFTTransfersJSONRequest, GetNFTTransfersResponse, GetNFTTransfersJSONResponse['result']>;
declare function deserializeResponse$s(jsonResponse: GetNFTTransfersJSONResponse, request: GetNFTTransfersRequest, core: Core): EvmNftTransfer[];
declare function serializeRequest$q(request: GetNFTTransfersRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    format: "decimal" | "hex" | undefined;
    limit: number | undefined;
    cursor: string | undefined;
    address: string;
    tokenId: string;
    disableTotal: boolean | undefined;
};

type OperationId$r = 'getWalletNFTCollections';
type PathParams$i = operations$1[OperationId$r]['parameters']['path'];
type QueryParams$n = operations$1[OperationId$r]['parameters']['query'];
type RequestParams$p = PathParams$i & QueryParams$n;
type SuccessResponse$r = operations$1[OperationId$r]['responses']['200']['content']['application/json'];
interface GetWalletNFTCollectionsRequest extends Camelize<Omit<RequestParams$p, 'chain' | 'address'>> {
    chain?: EvmChainish;
    address: EvmAddressish;
}
type GetWalletNFTCollectionsJSONRequest = ReturnType<typeof serializeRequest$p>;
type GetWalletNFTCollectionsJSONResponse = SuccessResponse$r;
type GetWalletNFTCollectionsResponse = ReturnType<typeof deserializeResponse$r>;
interface GetWalletNFTCollectionsResponseAdapter extends PaginatedResponseAdapter<GetWalletNFTCollectionsResponse, GetWalletNFTCollectionsJSONResponse['result']> {
}
/** Get NFT collections owned by a given wallet address. */
declare const getWalletNFTCollectionsOperation: PaginatedOperation<GetWalletNFTCollectionsRequest, GetWalletNFTCollectionsJSONRequest, GetWalletNFTCollectionsResponse, GetWalletNFTCollectionsJSONResponse['result']>;
declare function deserializeResponse$r(jsonResponse: GetWalletNFTCollectionsJSONResponse, request: GetWalletNFTCollectionsRequest, core: Core): EvmNftCollection[];
declare function serializeRequest$p(request: GetWalletNFTCollectionsRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    limit: number | undefined;
    cursor: string | undefined;
    address: string;
    disableTotal: boolean | undefined;
};

type OperationId$q = 'getWalletNFTs';
type PathParams$h = operations$1[OperationId$q]['parameters']['path'];
type QueryParams$m = operations$1[OperationId$q]['parameters']['query'];
type RequestParams$o = PathParams$h & QueryParams$m;
type SuccessResponse$q = operations$1[OperationId$q]['responses']['200']['content']['application/json'];
interface GetWalletNFTsRequest extends Camelize<Omit<RequestParams$o, 'chain' | 'token_addresses' | 'address'>> {
    chain?: EvmChainish;
    tokenAddresses?: EvmAddressish[];
    address: EvmAddressish;
}
type GetWalletNFTsJSONRequest = ReturnType<typeof serializeRequest$o>;
type GetWalletNFTsJSONResponse = SuccessResponse$q;
type GetWalletNFTsResponse = ReturnType<typeof deserializeResponse$q>;
interface GetWalletNFTsResponseAdapter extends PaginatedResponseAdapter<GetWalletNFTsResponse, GetWalletNFTsJSONResponse['result']> {
}
/**
 * Get NFTs owned by a given address.
 * * The response will include status [SYNCED/SYNCING] based on the contracts being indexed.
 * * Use the token_address param to get results for a specific contract only
 * * Note results will include all indexed NFTs
 * * Any request which includes the token_address param will start the indexing process for that NFT collection the very first time it is requested.
 */
declare const getWalletNFTsOperation: PaginatedOperation<GetWalletNFTsRequest, GetWalletNFTsJSONRequest, GetWalletNFTsResponse, GetWalletNFTsJSONResponse['result']>;
declare function deserializeResponse$q(jsonResponse: GetWalletNFTsJSONResponse, request: GetWalletNFTsRequest, core: Core): EvmNft[];
declare function serializeRequest$o(request: GetWalletNFTsRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    format: "decimal" | "hex" | undefined;
    limit: number | undefined;
    tokenAddresses: string[] | undefined;
    cursor: string | undefined;
    address: string;
    normalizeMetadata: boolean | undefined;
    disableTotal: boolean | undefined;
    mediaItems: boolean | undefined;
};

type OperationId$p = 'getWalletNFTTransfers';
type PathParams$g = operations$1[OperationId$p]['parameters']['path'];
type QueryParams$l = operations$1[OperationId$p]['parameters']['query'];
type RequestParams$n = PathParams$g & QueryParams$l;
type SuccessResponse$p = operations$1[OperationId$p]['responses']['200']['content']['application/json'];
interface GetWalletNFTTransfersRequest extends Camelize<Omit<RequestParams$n, 'chain' | 'address' | 'from_date' | 'to_date'>> {
    chain?: EvmChainish;
    address: EvmAddressish;
    fromDate?: DateInput;
    toDate?: DateInput;
}
type GetWalletNFTTransfersJSONRequest = ReturnType<typeof serializeRequest$n>;
type GetWalletNFTTransfersJSONResponse = SuccessResponse$p;
type GetWalletNFTTransfersResponse = ReturnType<typeof deserializeResponse$p>;
interface GetWalletNFTTransfersResponseAdapter extends PaginatedResponseAdapter<GetWalletNFTTransfersResponse, GetWalletNFTTransfersJSONResponse['result']> {
}
/** Get transfers of NFTs given the wallet and other parameters. */
declare const getWalletNFTTransfersOperation: PaginatedOperation<GetWalletNFTTransfersRequest, GetWalletNFTTransfersJSONRequest, GetWalletNFTTransfersResponse, GetWalletNFTTransfersJSONResponse['result']>;
declare function deserializeResponse$p(jsonResponse: GetWalletNFTTransfersJSONResponse, request: GetWalletNFTTransfersRequest, core: Core): EvmNftTransfer[];
declare function serializeRequest$n(request: GetWalletNFTTransfersRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    format: "decimal" | "hex" | undefined;
    direction: "from" | "to" | "both" | undefined;
    fromBlock: number | undefined;
    toBlock: string | undefined;
    limit: number | undefined;
    cursor: string | undefined;
    address: string;
    disableTotal: boolean | undefined;
    fromDate: string | undefined;
    toDate: string | undefined;
};

type OperationId$o = 'reSyncMetadata';
type PathParams$f = operations$1[OperationId$o]['parameters']['path'];
type QueryParams$k = operations$1[OperationId$o]['parameters']['query'];
type RequestParams$m = PathParams$f & QueryParams$k;
type SuccessResponse$o = operations$1[OperationId$o]['responses']['200']['content']['application/json'];
interface ReSyncMetadataRequest extends Camelize<Omit<RequestParams$m, 'chain' | 'address'>> {
    chain?: EvmChainish;
    address: EvmAddressish;
}
type ReSyncMetadataJSONRequest = ReturnType<typeof serializeRequest$m>;
type ReSyncMetadataJSONResponse = SuccessResponse$o;
type ReSyncMetadataResponse = ReturnType<typeof deserializeResponse$o>;
interface ReSyncMetadataResponseAdapter extends ResponseAdapter<ReSyncMetadataResponse, ReSyncMetadataJSONResponse> {
}
/**
 * ReSync the metadata for an NFT
 * * The metadata flag will request a the NFT's metadata from the already existing token_uri
 * * The uri(default) flag will fetch the latest token_uri from the given NFT address. In sync mode the metadata will also be fetched
 * * The sync mode will make the endpoint synchronous so it will wait for the task to be completed before responding
 * * The async mode(default) will make the endpoint asynchronous so we will wait for the task to be completed before responding
 */
declare const reSyncMetadataOperation: Operation<ReSyncMetadataRequest, ReSyncMetadataJSONRequest, ReSyncMetadataResponse, ReSyncMetadataJSONResponse>;
declare function serializeRequest$m(request: ReSyncMetadataRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    flag: "uri" | "metadata" | undefined;
    mode: "async" | "sync" | undefined;
    address: string;
    tokenId: string;
};
declare function deserializeResponse$o(jsonResponse: ReSyncMetadataJSONResponse): {
    status: string;
};

type OperationId$n = 'searchNFTs';
type QueryParams$j = operations$1[OperationId$n]['parameters']['query'];
type RequestParams$l = QueryParams$j;
type SuccessResponse$n = operations$1[OperationId$n]['responses']['200']['content']['application/json'];
interface SearchNFTsRequest extends Camelize<Omit<RequestParams$l, 'chain' | 'addresses' | 'from_date' | 'to_date'>> {
    chain?: EvmChainish;
    addresses?: EvmAddressish[];
    fromDate?: DateInput;
    toDate?: DateInput;
}
type SearchNFTsJSONRequest = ReturnType<typeof serializeRequest$l>;
type SearchNFTsJSONResponse = SuccessResponse$n;
type SearchNFTsResponse = ReturnType<typeof deserializeResponse$n>;
interface SearchNFTsResponseAdapter extends PaginatedResponseAdapter<SearchNFTsResponse, SearchNFTsJSONResponse['result']> {
}
/** Get NFTs that match a given metadata search query. */
declare const searchNFTsOperation: PaginatedOperation<SearchNFTsRequest, SearchNFTsJSONRequest, SearchNFTsResponse, SearchNFTsJSONResponse['result']>;
declare function deserializeResponse$n(jsonResponse: SearchNFTsJSONResponse, request: SearchNFTsRequest, core: Core): {
    token: EvmNft;
    tokenHash: string;
    blockNumberMinted: string;
    lastMetadataSync: Date | undefined;
    lastTokenUriSync: Date | undefined;
    batchId: string;
    frozen: number;
    frozenLogIndex: {
        [key: string]: unknown;
    } | undefined;
    imported: {
        [key: string]: unknown;
    } | undefined;
    isValid: number;
    openseaLookup: {
        [key: string]: unknown;
    } | undefined;
    resyncing: number;
    syncing: number;
    updatedAt: Date;
}[];
declare function serializeRequest$l(request: SearchNFTsRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    format: "decimal" | "hex" | undefined;
    q: string;
    filter: "name" | "description" | "attributes" | "global" | "name,description" | "name,attributes" | "description,attributes" | "name,description,attributes" | undefined;
    fromBlock: number | undefined;
    toBlock: number | undefined;
    fromDate: DateInput | undefined;
    toDate: DateInput | undefined;
    addresses: string[] | undefined;
    cursor: string | undefined;
    limit: number | undefined;
    disableTotal: boolean | undefined;
};

type OperationId$m = 'syncNFTContract';
type PathParams$e = operations$1[OperationId$m]['parameters']['path'];
type QueryParams$i = operations$1[OperationId$m]['parameters']['query'];
type RequestParams$k = PathParams$e & QueryParams$i;
type SuccessResponse$m = operations$1[OperationId$m]['responses']['201'];
interface SyncNFTContractRequest extends Camelize<Omit<RequestParams$k, 'chain' | 'address'>> {
    chain?: EvmChainish;
    address: EvmAddressish;
}
type SyncNFTContractJSONRequest = ReturnType<typeof serializeRequest$k>;
type SyncNFTContractJSONResponse = SuccessResponse$m;
type SyncNFTContractResponse = ReturnType<typeof deserializeResponse$m>;
interface SyncNFTContractResponseAdapter extends ResponseAdapter<SyncNFTContractResponse, SyncNFTContractJSONResponse> {
}
/** Initiates a sync of a previously non synced Contract. */
declare const syncNFTContractOperation: Operation<SyncNFTContractRequest, SyncNFTContractJSONRequest, SyncNFTContractResponse, SyncNFTContractJSONResponse>;
declare function deserializeResponse$m(): {
    success: boolean;
};
declare function serializeRequest$k(request: SyncNFTContractRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    address: string;
};

type OperationId$l = 'runContractFunction';
type PathParams$d = operations$1[OperationId$l]['parameters']['path'];
type QueryParams$h = operations$1[OperationId$l]['parameters']['query'];
type BodyParams = operations$1[OperationId$l]['requestBody']['content']['application/json'];
type RequestParams$j = PathParams$d & QueryParams$h & BodyParams;
type SuccessResponse$l = operations$1[OperationId$l]['responses']['200']['content']['application/json'];
interface RunContractFunctionRequest extends Camelize<Omit<RequestParams$j, 'chain' | 'address' | 'abi'>> {
    chain?: EvmChainish;
    address: EvmAddressish;
    abi: unknown;
}
type RunContractFunctionJSONRequest = ReturnType<typeof serializeRequest$j>;
type RunContractFunctionJSONResponse = SuccessResponse$l;
type RunContractFunctionResponse = ReturnType<typeof deserializeResponse$l>;
interface RunContractFunctionResponseAdapter extends ResponseAdapter<RunContractFunctionResponse, RunContractFunctionJSONResponse> {
}
/** Run a given function of a contract ABI and retrieve readonly data. */
declare const runContractFunctionOperation: Operation<RunContractFunctionRequest, RunContractFunctionJSONRequest, RunContractFunctionResponse, RunContractFunctionJSONResponse>;
declare function deserializeResponse$l(jsonResponse: RunContractFunctionJSONResponse): string;
declare function serializeRequest$j(request: RunContractFunctionRequest, core: Core): {
    address: string;
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    functionName: string;
    abi: unknown;
    params: {
        [key: string]: unknown;
    } | undefined;
};

type OperationId$k = 'endpointWeights';
type SuccessResponse$k = operations$1[OperationId$k]['responses']['200']['content']['application/json'];
interface EndpointWeightsRequest {
}
type EndpointWeightsJSONRequest = undefined;
type EndpointWeightsJSONResponse = SuccessResponse$k;
type EndpointWeightsResponse = ReturnType<typeof deserializeResponse$k>;
interface EndpointWeightsResponseAdapter extends ResponseAdapter<EndpointWeightsResponse, EndpointWeightsJSONResponse> {
}
/** Get the endpoint price list for rate limits and cost. */
declare const endpointWeightsOperation: Operation<EndpointWeightsRequest, EndpointWeightsJSONRequest, EndpointWeightsResponse, EndpointWeightsJSONResponse>;
declare function deserializeResponse$k(jsonResponse: EndpointWeightsJSONResponse): {
    endpoint: string;
    path: string;
    rateLimitCost: string;
    price: string;
}[];

type OperationId$j = 'web3ApiVersion';
type SuccessResponse$j = operations$1[OperationId$j]['responses']['200']['content']['application/json'];
interface Web3ApiVersionRequest {
}
type Web3ApiVersionJSONRequest = undefined;
type Web3ApiVersionJSONResponse = SuccessResponse$j;
type Web3ApiVersionResponse = ReturnType<typeof deserializeResponse$j>;
interface Web3ApiVersionResponseAdapter extends ResponseAdapter<Web3ApiVersionResponse, Web3ApiVersionJSONResponse> {
}
/** Get the current version of the Moralis Web3 API. */
declare const web3ApiVersionOperation: Operation<Web3ApiVersionRequest, Web3ApiVersionJSONRequest, Web3ApiVersionResponse, Web3ApiVersionJSONResponse>;
declare function deserializeResponse$j(jsonResponse: Web3ApiVersionJSONResponse): {
    version: string;
};

type OperationId$i = 'resolveAddress';
type PathParams$c = operations$1[OperationId$i]['parameters']['path'];
type RequestParams$i = PathParams$c;
type SuccessResponse$i = operations$1[OperationId$i]['responses']['200']['content']['application/json'];
interface ResolveAddressRequest extends Camelize<Omit<RequestParams$i, 'address'>> {
    address?: EvmAddressish;
}
type ResolveAddressJSONRequest = ReturnType<typeof serializeRequest$i>;
type ResolveAddressJSONResponse = SuccessResponse$i;
type ResolveAddressResponse = ReturnType<typeof deserializeResponse$i>;
interface ResolveAddressResponseAdapter extends ResponseAdapter<ResolveAddressResponse, ResolveAddressJSONResponse> {
}
/** Resolve an ETH address and find the ENS name. */
declare const resolveAddressOperation: Operation<ResolveAddressRequest, ResolveAddressJSONRequest, ResolveAddressResponse, ResolveAddressJSONResponse>;
declare function deserializeResponse$i(jsonResponse: ResolveAddressJSONResponse): {
    name: string;
};
declare function serializeRequest$i(request: ResolveAddressRequest): {
    address: string | undefined;
};

type OperationId$h = 'resolveDomain';
type PathParams$b = operations$1[OperationId$h]['parameters']['path'];
type QueryParams$g = operations$1[OperationId$h]['parameters']['query'];
type RequestParams$h = PathParams$b & QueryParams$g;
type SuccessResponse$h = operations$1[OperationId$h]['responses']['200']['content']['application/json'];
interface ResolveDomainRequest extends Camelize<RequestParams$h> {
}
type ResolveDomainJSONRequest = ReturnType<typeof serializeRequest$h>;
type ResolveDomainJSONResponse = SuccessResponse$h;
type ResolveDomainResponse = ReturnType<typeof deserializeResponse$h>;
interface ResolveDomainResponseAdapter extends ResponseAdapter<ResolveDomainResponse, ResolveDomainJSONResponse> {
}
/** Resolve an Unstoppable domain and get the address. */
declare const resolveDomainOperation: Operation<ResolveDomainRequest, ResolveDomainJSONRequest, ResolveDomainResponse, ResolveDomainJSONResponse>;
declare function serializeRequest$h(request: ResolveDomainRequest): {
    currency: "eth" | "0x1" | undefined;
    domain: string;
};
declare function deserializeResponse$h(jsonResponse: ResolveDomainJSONResponse): {
    address: EvmAddress;
};

type OperationId$g = 'resolveENSDomain';
type PathParams$a = operations$1[OperationId$g]['parameters']['path'];
type RequestParams$g = PathParams$a;
type SuccessResponse$g = operations$1[OperationId$g]['responses']['200']['content']['application/json'];
interface ResolveENSDomainRequest extends Camelize<RequestParams$g> {
}
type ResolveENSDomainJSONRequest = ReturnType<typeof serializeRequest$g>;
type ResolveENSDomainJSONResponse = SuccessResponse$g;
type ResolveENSDomainResponse = ReturnType<typeof deserializeResponse$g>;
interface ResolveENSDomainResponseAdapter extends ResponseAdapter<ResolveENSDomainResponse, ResolveENSDomainJSONResponse> {
}
/** Resolve a specific ENS domain to its address. */
declare const resolveENSDomainOperation: Operation<ResolveENSDomainRequest, ResolveENSDomainJSONRequest, ResolveENSDomainResponse, ResolveENSDomainJSONResponse>;
declare function serializeRequest$g(request: ResolveENSDomainRequest): {
    domain: string;
};
declare function deserializeResponse$g(jsonResponse: ResolveENSDomainJSONResponse): {
    address: EvmAddress;
};

type OperationId$f = 'getTransaction';
type PathParams$9 = operations$1[OperationId$f]['parameters']['path'];
type QueryParams$f = operations$1[OperationId$f]['parameters']['query'];
type RequestParams$f = PathParams$9 & QueryParams$f;
type SuccessResponse$f = operations$1[OperationId$f]['responses']['200']['content']['application/json'];
interface GetTransactionRequest extends Camelize<Omit<RequestParams$f, 'chain'>> {
    chain?: EvmChainish;
}
type GetTransactionJSONRequest = ReturnType<typeof serializeRequest$f>;
type GetTransactionJSONResponse = SuccessResponse$f;
type GetTransactionResponse = ReturnType<typeof deserializeResponse$f>;
interface GetTransactionResponseAdapter extends ResponseAdapter<GetTransactionResponse, GetTransactionJSONResponse> {
}
/** Get the contents of a transaction by the given transaction hash. */
declare const getTransactionOperation: Operation<GetTransactionRequest, GetTransactionJSONRequest, GetTransactionResponse, GetTransactionJSONResponse>;
declare function serializeRequest$f(request: GetTransactionRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    transactionHash: string;
    include: "internal_transactions" | undefined;
};
declare function deserializeResponse$f(jsonResponse: GetTransactionJSONResponse, request: GetTransactionJSONRequest, core: Core): EvmTransaction;

type OperationId$e = 'getTransactionVerbose';
type PathParams$8 = operations$1[OperationId$e]['parameters']['path'];
type QueryParams$e = operations$1[OperationId$e]['parameters']['query'];
type RequestParams$e = PathParams$8 & QueryParams$e;
type SuccessResponse$e = components['schemas']['blockTransactionVerbose'];
interface GetTransactionVerboseRequest extends Camelize<Omit<RequestParams$e, 'chain'>> {
    chain?: EvmChainish;
}
type GetTransactionVerboseJSONRequest = ReturnType<typeof serializeRequest$e>;
type GetTransactionVerboseJSONResponse = SuccessResponse$e;
type GetTransactionVerboseResponse = ReturnType<typeof deserializeResponse$e>;
interface GetTransactionVerboseResponseAdapter extends ResponseAdapter<GetTransactionVerboseResponse, GetTransactionVerboseJSONResponse> {
}
/** Get the contents of a transaction by the given transaction hash. */
declare const getTransactionVerboseOperation: Operation<GetTransactionVerboseRequest, GetTransactionVerboseJSONRequest, GetTransactionVerboseResponse, GetTransactionVerboseJSONResponse>;
declare function serializeRequest$e(request: GetTransactionVerboseRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    transactionHash: string;
    include: "internal_transactions" | undefined;
};
declare function deserializeResponse$e(jsonResponse: GetTransactionVerboseJSONResponse, request: GetTransactionVerboseJSONRequest, core: Core): EvmTransactionVerbose;

type OperationId$d = 'getWalletTransactions';
type PathParams$7 = operations$1[OperationId$d]['parameters']['path'];
type QueryParams$d = operations$1[OperationId$d]['parameters']['query'];
type RequestParams$d = PathParams$7 & QueryParams$d;
type SuccessResponse$d = operations$1[OperationId$d]['responses']['200']['content']['application/json'];
interface GetWalletTransactionsRequest extends Camelize<Omit<RequestParams$d, 'chain' | 'address' | 'from_date' | 'to_date'>> {
    chain?: EvmChainish;
    address: EvmAddressish;
    fromDate?: DateInput;
    toDate?: DateInput;
}
type GetWalletTransactionsJSONRequest = ReturnType<typeof serializeRequest$d>;
type GetWalletTransactionsJSONResponse = SuccessResponse$d;
type GetWalletTransactionsResponse = ReturnType<typeof deserializeResponse$d>;
interface GetWalletTransactionsResponseAdapter extends PaginatedResponseAdapter<GetWalletTransactionsResponse, GetWalletTransactionsJSONResponse['result']> {
}
/** Get native transactions ordered by block number in descending order. */
declare const getWalletTransactionsOperation: PaginatedOperation<GetWalletTransactionsRequest, GetWalletTransactionsJSONRequest, GetWalletTransactionsResponse, GetWalletTransactionsJSONResponse['result']>;
declare function serializeRequest$d(request: GetWalletTransactionsRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    fromBlock: number | undefined;
    toBlock: number | undefined;
    fromDate: DateInput | undefined;
    toDate: DateInput | undefined;
    cursor: string | undefined;
    limit: number | undefined;
    address: string;
    disableTotal: boolean | undefined;
    include: "internal_transactions" | undefined;
};
declare function deserializeResponse$d(jsonResponse: GetWalletTransactionsJSONResponse, request: GetWalletTransactionsJSONRequest, core: Core): EvmTransaction[];

type OperationId$c = 'getWalletTransactionsVerbose';
type PathParams$6 = operations$1[OperationId$c]['parameters']['path'];
type QueryParams$c = operations$1[OperationId$c]['parameters']['query'];
type RequestParams$c = PathParams$6 & QueryParams$c;
type SuccessResponse$c = operations$1[OperationId$c]['responses']['200']['content']['application/json'];
interface GetWalletTransactionsVerboseRequest extends Camelize<Omit<RequestParams$c, 'chain' | 'address' | 'from_date' | 'to_date'>> {
    chain?: EvmChainish;
    address: EvmAddressish;
    fromDate?: DateInput;
    toDate?: DateInput;
}
type GetWalletTransactionsVerboseJSONRequest = ReturnType<typeof serializeRequest$c>;
type GetWalletTransactionsVerboseJSONResponse = SuccessResponse$c;
type GetWalletTransactionsVerboseResponse = ReturnType<typeof deserializeResponse$c>;
interface GetWalletTransactionsVerboseResponseAdapter extends PaginatedResponseAdapter<GetWalletTransactionsVerboseResponse, GetWalletTransactionsVerboseJSONResponse['result']> {
}
/** Get native transactions ordered by block number in descending order. */
declare const getWalletTransactionsVerboseOperation: PaginatedOperation<GetWalletTransactionsVerboseRequest, GetWalletTransactionsVerboseJSONRequest, GetWalletTransactionsVerboseResponse, GetWalletTransactionsVerboseJSONResponse['result']>;
declare function serializeRequest$c(request: GetWalletTransactionsVerboseRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    fromBlock: number | undefined;
    toBlock: number | undefined;
    fromDate: DateInput | undefined;
    toDate: DateInput | undefined;
    cursor: string | undefined;
    limit: number | undefined;
    address: string;
    disableTotal: boolean | undefined;
    include: "internal_transactions" | undefined;
};
declare function deserializeResponse$c(jsonResponse: GetWalletTransactionsVerboseJSONResponse, request: GetWalletTransactionsVerboseJSONRequest, core: Core): EvmTransaction[];

type OperationId$b = 'getInternalTransactions';
type PathParams$5 = operations$1[OperationId$b]['parameters']['path'];
type QueryParams$b = operations$1[OperationId$b]['parameters']['query'];
type RequestParams$b = PathParams$5 & QueryParams$b;
type SuccessResponse$b = operations$1[OperationId$b]['responses']['200']['content']['application/json'];
interface GetInternalTransactionsRequest extends Camelize<Omit<RequestParams$b, 'chain'>> {
    chain?: EvmChainish;
}
type GetInternalTransactionsJSONRequest = ReturnType<typeof serializeRequest$b>;
type GetInternalTransactionsJSONResponse = SuccessResponse$b;
type GetInternalTransactionsResponse = ReturnType<typeof deserializeResponse$b>;
interface GetInternalTransactionsResponseAdapter extends ResponseAdapter<GetInternalTransactionsResponse, GetInternalTransactionsJSONResponse> {
}
/** Get native transactions ordered by block number in descending order. */
declare const getInternalTransactionsOperation: Operation<GetInternalTransactionsRequest, GetInternalTransactionsJSONRequest, GetInternalTransactionsResponse, GetInternalTransactionsJSONResponse>;
declare function serializeRequest$b(request: GetInternalTransactionsRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    transactionHash: string;
};
declare function deserializeResponse$b(jsonResponse: GetInternalTransactionsJSONResponse, request: GetInternalTransactionsJSONRequest, core: Core): EvmInternalTransaction[];

type OperationId$a = 'getErc20Approvals';
type QueryParams$a = operations$1[OperationId$a]['parameters']['query'];
type RequestParams$a = QueryParams$a;
type SuccessResponse$a = operations$1[OperationId$a]['responses']['200']['content']['application/json'];
interface GetErc20ApprovalsRequest extends Camelize<Omit<RequestParams$a, 'chain' | 'contract_addresses' | 'exclude_contracts' | 'wallet_addresses' | 'exclude_wallets'>> {
    chain?: EvmChainish;
    contractAddresses?: EvmAddressish[];
    excludeContracts?: EvmAddressish[];
    walletAddresses?: EvmAddressish[];
    excludeWallets?: EvmAddressish[];
}
type GetErc20ApprovalsJSONRequest = ReturnType<typeof serializeRequest$a>;
type GetErc20ApprovalsJSONResponse = SuccessResponse$a;
type GetErc20ApprovalsResponse = ReturnType<typeof deserializeResponse$a>;
interface GetErc20ApprovalsResponseAdapter extends PaginatedResponseAdapter<GetErc20ApprovalsResponse, GetErc20ApprovalsJSONResponse['result']> {
}
/** Get the amount which the spender is allowed to withdraw on behalf of the owner. */
declare const getErc20ApprovalsOperation: PaginatedOperation<GetErc20ApprovalsRequest, GetErc20ApprovalsJSONRequest, GetErc20ApprovalsResponse, GetErc20ApprovalsJSONResponse['result']>;
declare function deserializeResponse$a(jsonResponse: GetErc20ApprovalsJSONResponse, request: GetErc20ApprovalsRequest, core: Core): Erc20Approval[];
declare function serializeRequest$a(request: GetErc20ApprovalsRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    limit: number | undefined;
    cursor: string | undefined;
    fromBlock: number | undefined;
    toBlock: number | undefined;
    contractAddresses: string[] | undefined;
    excludeContracts: string[] | undefined;
    walletAddresses: string[] | undefined;
    excludeWallets: string[] | undefined;
};

type OperationId$9 = 'getErc20Burns';
type QueryParams$9 = operations$1[OperationId$9]['parameters']['query'];
type RequestParams$9 = QueryParams$9;
type SuccessResponse$9 = operations$1[OperationId$9]['responses']['200']['content']['application/json'];
interface GetErc20BurnsRequest extends Camelize<Omit<RequestParams$9, 'chain' | 'contract_addresses' | 'exclude_contracts' | 'wallet_addresses' | 'exclude_wallets'>> {
    chain?: EvmChainish;
    contractAddresses?: EvmAddressish[];
    excludeContracts?: EvmAddressish[];
    walletAddresses?: EvmAddressish[];
    excludeWallets?: EvmAddressish[];
}
type GetErc20BurnsJSONRequest = ReturnType<typeof serializeRequest$9>;
type GetErc20BurnsJSONResponse = SuccessResponse$9;
type GetErc20BurnsResponse = ReturnType<typeof deserializeResponse$9>;
interface GetErc20BurnsResponseAdapter extends PaginatedResponseAdapter<GetErc20BurnsResponse, GetErc20BurnsJSONResponse['result']> {
}
/** Get the amount which the spender is allowed to withdraw on behalf of the owner. */
declare const getErc20BurnsOperation: PaginatedOperation<GetErc20BurnsRequest, GetErc20BurnsJSONRequest, GetErc20BurnsResponse, GetErc20BurnsJSONResponse['result']>;
declare function deserializeResponse$9(jsonResponse: GetErc20BurnsJSONResponse, request: GetErc20BurnsRequest, core: Core): Erc20Burn[];
declare function serializeRequest$9(request: GetErc20BurnsRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    limit: number | undefined;
    cursor: string | undefined;
    fromBlock: number | undefined;
    toBlock: number | undefined;
    contractAddresses: string[] | undefined;
    excludeContracts: string[] | undefined;
    walletAddresses: string[] | undefined;
    excludeWallets: string[] | undefined;
};

type OperationId$8 = 'getErc20Transfers';
type QueryParams$8 = operations$1[OperationId$8]['parameters']['query'];
type RequestParams$8 = QueryParams$8;
type SuccessResponse$8 = operations$1[OperationId$8]['responses']['200']['content']['application/json'];
interface GetErc20TransfersRequest extends Camelize<Omit<RequestParams$8, 'chain' | 'contract_addresses' | 'exclude_contracts' | 'wallet_addresses' | 'exclude_wallets'>> {
    chain?: EvmChainish;
    contractAddresses?: EvmAddressish[];
    excludeContracts?: EvmAddressish[];
    walletAddresses?: EvmAddressish[];
    excludeWallets?: EvmAddressish[];
}
type GetErc20TransfersJSONRequest = ReturnType<typeof serializeRequest$8>;
type GetErc20TransfersJSONResponse = SuccessResponse$8;
type GetErc20TransfersResponse = ReturnType<typeof deserializeResponse$8>;
interface GetErc20TransfersResponseAdapter extends PaginatedResponseAdapter<GetErc20TransfersResponse, GetErc20TransfersJSONResponse['result']> {
}
/** Get the amount which the spender is allowed to withdraw on behalf of the owner. */
declare const getErc20TransfersOperation: PaginatedOperation<GetErc20TransfersRequest, GetErc20TransfersJSONRequest, GetErc20TransfersResponse, GetErc20TransfersJSONResponse['result']>;
declare function deserializeResponse$8(jsonResponse: GetErc20TransfersJSONResponse): EvmErc20Transfer[];
declare function serializeRequest$8(request: GetErc20TransfersRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    limit: number | undefined;
    cursor: string | undefined;
    fromBlock: number | undefined;
    toBlock: number | undefined;
    contractAddresses: string[] | undefined;
    excludeContracts: string[] | undefined;
    walletAddresses: string[] | undefined;
    excludeWallets: string[] | undefined;
};

type OperationId$7 = 'getErc20Mints';
type QueryParams$7 = operations$1[OperationId$7]['parameters']['query'];
type RequestParams$7 = QueryParams$7;
type SuccessResponse$7 = operations$1[OperationId$7]['responses']['200']['content']['application/json'];
interface GetErc20MintsRequest extends Camelize<Omit<RequestParams$7, 'chain' | 'contract_addresses' | 'exclude_contracts' | 'wallet_addresses' | 'exclude_wallets'>> {
    chain?: EvmChainish;
    contractAddresses?: EvmAddressish[];
    excludeContracts?: EvmAddressish[];
    walletAddresses?: EvmAddressish[];
    excludeWallets?: EvmAddressish[];
}
type GetErc20MintsJSONRequest = ReturnType<typeof serializeRequest$7>;
type GetErc20MintsJSONResponse = SuccessResponse$7;
type GetErc20MintsResponse = ReturnType<typeof deserializeResponse$7>;
interface GetErc20MintsResponseAdapter extends PaginatedResponseAdapter<GetErc20MintsResponse, GetErc20MintsJSONResponse['result']> {
}
/** Get the amount which the spender is allowed to withdraw on behalf of the owner. */
declare const getErc20MintsOperation: PaginatedOperation<GetErc20MintsRequest, GetErc20MintsJSONRequest, GetErc20MintsResponse, GetErc20MintsJSONResponse['result']>;
declare function deserializeResponse$7(jsonResponse: GetErc20MintsJSONResponse, request: GetErc20MintsRequest, core: Core): Erc20Mint[];
declare function serializeRequest$7(request: GetErc20MintsRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    limit: number | undefined;
    cursor: string | undefined;
    fromBlock: number | undefined;
    toBlock: number | undefined;
    contractAddresses: string[] | undefined;
    excludeContracts: string[] | undefined;
    walletAddresses: string[] | undefined;
    excludeWallets: string[] | undefined;
};

type OperationId$6 = 'getTokenAllowance';
type PathParams$4 = operations$1[OperationId$6]['parameters']['path'];
type QueryParams$6 = operations$1[OperationId$6]['parameters']['query'];
type RequestParams$6 = PathParams$4 & QueryParams$6;
type SuccessResponse$6 = operations$1[OperationId$6]['responses']['200']['content']['application/json'];
interface GetTokenAllowanceRequest extends Camelize<Omit<RequestParams$6, 'chain' | 'owner_address' | 'spender_address' | 'address'>> {
    chain?: EvmChainish;
    ownerAddress: EvmAddressish;
    spenderAddress: EvmAddressish;
    address: EvmAddressish;
}
type GetTokenAllowanceJSONRequest = ReturnType<typeof serializeRequest$6>;
type GetTokenAllowanceJSONResponse = SuccessResponse$6;
type GetTokenAllowanceResponse = ReturnType<typeof deserializeResponse$6>;
interface GetTokenAllowanceResponseAdapter extends ResponseAdapter<GetTokenAllowanceResponse, GetTokenAllowanceJSONResponse> {
}
/** Get the amount which the spender is allowed to withdraw on behalf of the owner. */
declare const getTokenAllowanceOperation: Operation<GetTokenAllowanceRequest, GetTokenAllowanceJSONRequest, GetTokenAllowanceResponse, GetTokenAllowanceJSONResponse>;
declare function deserializeResponse$6(jsonResponse: GetTokenAllowanceJSONResponse): {
    allowance: BigNumber;
};
declare function serializeRequest$6(request: GetTokenAllowanceRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    ownerAddress: string;
    spenderAddress: string;
    address: string;
};

type OperationId$5 = 'getTokenMetadataBySymbol';
type QueryParams$5 = operations$1[OperationId$5]['parameters']['query'];
type RequestParams$5 = QueryParams$5;
type SuccessResponse$5 = operations$1[OperationId$5]['responses']['200']['content']['application/json'];
interface GetTokenMetadataBySymbolRequest extends Camelize<Omit<RequestParams$5, 'chain'>> {
    chain?: EvmChainish;
}
type GetTokenMetadataBySymbolJSONRequest = ReturnType<typeof serializeRequest$5>;
type GetTokenMetadataBySymbolJSONResponse = SuccessResponse$5;
type GetTokenMetadataBySymbolResponse = ReturnType<typeof deserializeResponse$5>;
interface GetTokenMetadataBySymbolResponseAdapter extends ResponseAdapter<GetTokenMetadataBySymbolResponse, GetTokenMetadataBySymbolJSONResponse> {
}
/** Get metadata for a list of token symbols (name, symbol, decimals, logo). */
declare const getTokenMetadataBySymbolOperation: Operation<GetTokenMetadataBySymbolRequest, GetTokenMetadataBySymbolJSONRequest, GetTokenMetadataBySymbolResponse, GetTokenMetadataBySymbolJSONResponse>;
declare function deserializeResponse$5(jsonResponse: GetTokenMetadataBySymbolJSONResponse, request: GetTokenMetadataBySymbolRequest, core: Core): {
    token: Erc20Token;
    blockNumber: string | undefined;
    validated: string | undefined;
}[];
declare function serializeRequest$5(request: GetTokenMetadataBySymbolRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    symbols: string[];
};

type OperationId$4 = 'getTokenMetadata';
type QueryParams$4 = operations$1[OperationId$4]['parameters']['query'];
type RequestParams$4 = QueryParams$4;
type SuccessResponse$4 = operations$1[OperationId$4]['responses']['200']['content']['application/json'];
interface GetTokenMetadataRequest extends Camelize<Omit<RequestParams$4, 'chain' | 'addresses'>> {
    chain?: EvmChainish;
    addresses: EvmAddressish[];
}
type GetTokenMetadataJSONRequest = ReturnType<typeof serializeRequest$4>;
type GetTokenMetadataJSONResponse = SuccessResponse$4;
type GetTokenMetadataResponse = ReturnType<typeof deserializeResponse$4>;
interface GetTokenMetadataResponseAdapter extends ResponseAdapter<GetTokenMetadataResponse, GetTokenMetadataJSONResponse> {
}
/** Get the metadata for a given token contract address (name, symbol, decimals, logo). */
declare const getTokenMetadataOperation: Operation<GetTokenMetadataRequest, GetTokenMetadataJSONRequest, GetTokenMetadataResponse, GetTokenMetadataJSONResponse>;
declare function deserializeResponse$4(jsonResponse: GetTokenMetadataJSONResponse, request: GetTokenMetadataRequest, core: Core): {
    token: Erc20Token;
    blockNumber: string | undefined;
    validated: string | undefined;
}[];
declare function serializeRequest$4(request: GetTokenMetadataRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    addresses: string[];
};

type OperationId$3 = 'getTokenPrice';
type PathParams$3 = operations$1[OperationId$3]['parameters']['path'];
type QueryParams$3 = operations$1[OperationId$3]['parameters']['query'];
type RequestParams$3 = PathParams$3 & QueryParams$3;
type SuccessResponse$3 = operations$1[OperationId$3]['responses']['200']['content']['application/json'];
interface GetTokenPriceRequest extends Camelize<Omit<RequestParams$3, 'chain' | 'address'>> {
    chain?: EvmChainish;
    address: EvmAddressish;
}
type GetTokenPriceJSONRequest = ReturnType<typeof serializeRequest$3>;
type GetTokenPriceJSONResponse = SuccessResponse$3;
type GetTokenPriceResponse = ReturnType<typeof deserializeResponse$3>;
interface GetTokenPriceResponseAdapter extends ResponseAdapter<GetTokenPriceResponse, GetTokenPriceJSONResponse> {
}
/** Get the token price denominated in the blockchains native token and USD. */
declare const getTokenPriceOperation: Operation<GetTokenPriceRequest, GetTokenPriceJSONRequest, GetTokenPriceResponse, GetTokenPriceJSONResponse>;
declare function deserializeResponse$3(jsonResponse: GetTokenPriceJSONResponse): {
    nativePrice: EvmNative | null;
    exchangeAddress: EvmAddress | null;
    tokenName?: string | undefined;
    tokenSymbol?: string | undefined;
    tokenLogo?: string | undefined;
    tokenDecimals?: string | undefined;
    usdPrice: number;
    exchangeName?: string | undefined;
    tokenAddress?: string | undefined;
};
declare function serializeRequest$3(request: GetTokenPriceRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    exchange: string | undefined;
    toBlock: number | undefined;
    address: string;
};

type OperationId$2 = 'getTokenTransfers';
type PathParams$2 = operations$1[OperationId$2]['parameters']['path'];
type QueryParams$2 = operations$1[OperationId$2]['parameters']['query'];
type RequestParams$2 = PathParams$2 & QueryParams$2;
type SuccessResponse$2 = operations$1[OperationId$2]['responses']['200']['content']['application/json'];
interface GetTokenTransfersRequest extends Camelize<Omit<RequestParams$2, 'chain' | 'address' | 'from_date' | 'to_date'>> {
    chain?: EvmChainish;
    address: EvmAddressish;
    fromDate?: DateInput;
    toDate?: DateInput;
}
type GetTokenTransfersJSONRequest = ReturnType<typeof serializeRequest$2>;
type GetTokenTransfersJSONResponse = SuccessResponse$2;
type GetTokenTransfersResponse = ReturnType<typeof deserializeResponse$2>;
interface GetTokenTransfersResponseAdapter extends PaginatedResponseAdapter<GetTokenTransfersResponse, GetTokenTransfersJSONResponse['result']> {
}
/** Get ERC20 token transactions from a contract ordered by block number in descending order. */
declare const getTokenTransfersOperation: PaginatedOperation<GetTokenTransfersRequest, GetTokenTransfersJSONRequest, GetTokenTransfersResponse, GetTokenTransfersJSONResponse['result']>;
declare function deserializeResponse$2(jsonResponse: GetTokenTransfersJSONResponse, request: GetTokenTransfersRequest, core: Core): Erc20Transaction[];
declare function serializeRequest$2(request: GetTokenTransfersRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    fromBlock: number | undefined;
    toBlock: number | undefined;
    fromDate: DateInput | undefined;
    toDate: DateInput | undefined;
    limit: number | undefined;
    address: string;
    cursor: string | undefined;
    disableTotal: boolean | undefined;
};

type OperationId$1 = 'getWalletTokenBalances';
type PathParams$1 = operations$1[OperationId$1]['parameters']['path'];
type QueryParams$1 = operations$1[OperationId$1]['parameters']['query'];
type RequestParams$1 = PathParams$1 & QueryParams$1;
type SuccessResponse$1 = operations$1[OperationId$1]['responses']['200']['content']['application/json'];
interface GetWalletTokenBalancesRequest extends Camelize<Omit<RequestParams$1, 'chain' | 'token_addresses' | 'address'>> {
    chain?: EvmChainish;
    tokenAddresses?: EvmAddressish[];
    address: EvmAddressish;
}
type GetWalletTokenBalancesJSONRequest = ReturnType<typeof serializeRequest$1>;
type GetWalletTokenBalancesJSONResponse = SuccessResponse$1;
type GetWalletTokenBalancesResponse = ReturnType<typeof deserializeResponse$1>;
interface GetWalletTokenBalancesResponseAdapter extends ResponseAdapter<GetWalletTokenBalancesResponse, GetWalletTokenBalancesJSONResponse> {
}
/** Get token balances for a specific wallet address. */
declare const getWalletTokenBalancesOperation: Operation<GetWalletTokenBalancesRequest, GetWalletTokenBalancesJSONRequest, GetWalletTokenBalancesResponse, GetWalletTokenBalancesJSONResponse>;
declare function deserializeResponse$1(jsonResponse: GetWalletTokenBalancesJSONResponse, request: GetWalletTokenBalancesRequest, core: Core): Erc20Value[];
declare function serializeRequest$1(request: GetWalletTokenBalancesRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    tokenAddresses: string[] | undefined;
    address: string;
    toBlock: number | undefined;
};

type OperationId = 'getWalletTokenTransfers';
type PathParams = operations$1[OperationId]['parameters']['path'];
type QueryParams = operations$1[OperationId]['parameters']['query'];
type RequestParams = PathParams & QueryParams;
type SuccessResponse = operations$1[OperationId]['responses']['200']['content']['application/json'];
interface GetWalletTokenTransfersRequest extends Camelize<Omit<RequestParams, 'chain' | 'address' | 'from_date' | 'to_date'>> {
    chain?: EvmChainish;
    address: EvmAddressish;
    fromDate?: DateInput;
    toDate?: DateInput;
}
type GetWalletTokenTransfersJSONRequest = ReturnType<typeof serializeRequest>;
type GetWalletTokenTransfersJSONResponse = SuccessResponse;
type GetWalletTokenTransfersResponse = ReturnType<typeof deserializeResponse>;
interface GetWalletTokenTransfersResponseAdapter extends PaginatedResponseAdapter<GetWalletTokenTransfersResponse, GetWalletTokenTransfersJSONResponse['result']> {
}
/** Get ERC20 token transactions ordered by block number in descending order. */
declare const getWalletTokenTransfersOperation: PaginatedOperation<GetWalletTokenTransfersRequest, GetWalletTokenTransfersJSONRequest, GetWalletTokenTransfersResponse, GetWalletTokenTransfersJSONResponse['result']>;
declare function deserializeResponse(jsonResponse: GetWalletTokenTransfersJSONResponse, request: GetWalletTokenTransfersRequest, core: Core): Erc20Transaction[];
declare function serializeRequest(request: GetWalletTokenTransfersRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    address: string;
    fromBlock: number | undefined;
    toBlock: number | undefined;
    fromDate: DateInput | undefined;
    toDate: DateInput | undefined;
    limit: number | undefined;
    cursor: string | undefined;
    disableTotal: boolean | undefined;
};

declare const operationsV2: (_moralisweb3_common_core.Operation<GetBlockRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    blockNumberOrHash: string;
    include: "internal_transactions" | undefined;
}, EvmBlock, {
    timestamp: string;
    number: string;
    hash: string;
    parent_hash: string;
    nonce: string;
    sha3_uncles: string;
    logs_bloom: string;
    transactions_root: string;
    state_root: string;
    receipts_root: string;
    miner: string;
    difficulty: string;
    total_difficulty: string;
    size: string;
    extra_data: string;
    gas_limit: string;
    gas_used: string;
    transaction_count: string;
    transactions: {
        hash: string;
        nonce: string;
        transaction_index: string;
        from_address: string;
        to_address: unknown;
        value: string;
        gas?: string | undefined;
        gas_price: string;
        input: string;
        receipt_cumulative_gas_used: string;
        receipt_gas_used: string;
        receipt_contract_address?: unknown;
        receipt_root?: unknown;
        receipt_status: string;
        block_timestamp: string;
        block_number: string;
        block_hash: string;
        logs?: {
            log_index: string;
            transaction_hash: string;
            transaction_index: string;
            address: string;
            data: string;
            topic0: string;
            topic1?: unknown;
            topic2?: unknown;
            topic3?: unknown;
            block_timestamp: string;
            block_number: string;
            block_hash: string;
        }[] | undefined;
        internal_transactions?: {
            transaction_hash: string;
            block_number: string;
            block_hash: string;
            type: string;
            from: string;
            to: string;
            value: string;
            gas: string;
            gas_used: string;
            input: string;
            output: string;
        }[] | undefined;
    }[];
}> | _moralisweb3_common_core.PaginatedOperation<GetContractEventsRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    fromBlock: number | undefined;
    toBlock: number | undefined;
    fromDate: string | undefined;
    toDate: string | undefined;
    topic: string;
    offset: number | undefined;
    limit: number | undefined;
    address: string;
    abi: EvmAbiItem;
    disableTotal: boolean | undefined;
}, EvmEvent[], {
    transaction_hash: string;
    address: string;
    block_timestamp: string;
    block_number: string;
    block_hash: string;
    data: {
        from?: string | undefined;
        to?: string | undefined;
        value?: string | undefined;
    };
}[] | undefined> | _moralisweb3_common_core.PaginatedOperation<GetContractLogsRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    blockNumber: string | undefined;
    fromBlock: string | undefined;
    toBlock: string | undefined;
    fromDate: string | undefined;
    toDate: string | undefined;
    topic0: string | undefined;
    topic1: string | undefined;
    topic2: string | undefined;
    topic3: string | undefined;
    limit: number | undefined;
    cursor: string | undefined;
    address: string;
    disableTotal: boolean | undefined;
}, EvmTransactionLog[], {
    transaction_hash: string;
    address: string;
    block_timestamp: string;
    block_number: string;
    block_hash: string;
    data: string;
    topic0: string;
    topic1: string;
    topic2: string;
    topic3: string;
    transaction_index: number;
    log_index: number;
}[] | undefined> | _moralisweb3_common_core.PaginatedOperation<GetContractNFTsRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    format: "decimal" | "hex" | undefined;
    limit: number | undefined;
    totalRanges: number | undefined;
    range: number | undefined;
    cursor: string | undefined;
    address: string;
    normalizeMetadata: boolean | undefined;
    disableTotal: boolean | undefined;
    mediaItems: boolean | undefined;
}, EvmNft[], {
    token_address: string;
    token_id: string;
    owner_of?: string | undefined;
    token_hash?: string | undefined;
    block_number?: string | undefined;
    block_number_minted?: string | undefined;
    contract_type: string;
    token_uri?: string | undefined;
    metadata?: string | undefined;
    normalized_metadata?: {
        name?: string | undefined;
        description?: string | undefined;
        image?: string | undefined;
        external_link?: string | undefined;
        animation_url?: string | undefined;
        attributes?: {
            trait_type?: string | undefined;
            value?: {
                [key: string]: unknown;
            } | undefined;
            display_type?: string | undefined;
            max_value?: number | undefined;
            trait_count?: number | undefined;
            order?: number | undefined;
        }[] | undefined;
    } | undefined;
    media?: {
        mimetype?: string | undefined;
        category?: "image" | "video" | "audio" | undefined;
        status?: "success" | "processing" | "unsupported_media" | "invalid_url" | "host_unavailable" | "temporarily_unavailable" | undefined;
        original_media_url?: string | undefined;
        updatedAt?: string | undefined;
        parent_hash?: string | undefined;
        media_collection?: ({
            low: {
                width: number;
                height: number;
                url: string;
            };
            medium: {
                width: number;
                height: number;
                url: string;
            };
            high: {
                width: number;
                height: number;
                url: string;
            };
        } & {
            original: unknown;
        }) | undefined;
    } | undefined;
    minter_address?: string | undefined;
    last_token_uri_sync?: string | undefined;
    last_metadata_sync?: string | undefined;
    amount?: string | undefined;
    name: string;
    symbol: string;
    possible_spam: boolean;
}[] | undefined> | _moralisweb3_common_core.Operation<GetDateToBlockRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    date: string;
}, EvmBlockDate, {
    date: string;
    block: number;
    timestamp: number;
    block_timestamp?: string | undefined;
    hash?: string | undefined;
    parent_hash?: string | undefined;
}> | _moralisweb3_common_core.PaginatedOperation<GetErc20ApprovalsRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    limit: number | undefined;
    cursor: string | undefined;
    fromBlock: number | undefined;
    toBlock: number | undefined;
    contractAddresses: string[] | undefined;
    excludeContracts: string[] | undefined;
    walletAddresses: string[] | undefined;
    excludeWallets: string[] | undefined;
}, Erc20Approval[], {
    token_name: string;
    token_symbol: string;
    token_logo?: string | undefined;
    token_decimals: string;
    contract_address: string;
    transaction_hash: string;
    transaction_index: number;
    log_index: number;
    block_timestamp: string;
    block_number: number;
    block_hash: string;
    from_wallet: string;
    to_wallet: string;
    value: string;
    value_decimal: string;
    possible_spam: boolean;
}[] | undefined> | _moralisweb3_common_core.PaginatedOperation<GetErc20BurnsRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    limit: number | undefined;
    cursor: string | undefined;
    fromBlock: number | undefined;
    toBlock: number | undefined;
    contractAddresses: string[] | undefined;
    excludeContracts: string[] | undefined;
    walletAddresses: string[] | undefined;
    excludeWallets: string[] | undefined;
}, Erc20Burn[], {
    token_name: string;
    token_symbol: string;
    token_logo?: string | undefined;
    token_decimals: string;
    contract_address: string;
    transaction_hash: string;
    transaction_index: number;
    log_index: number;
    block_timestamp: string;
    block_number: number;
    block_hash: string;
    from_wallet: string;
    value: string;
    value_decimal: string;
    possible_spam?: boolean | undefined;
}[] | undefined> | _moralisweb3_common_core.PaginatedOperation<GetErc20MintsRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    limit: number | undefined;
    cursor: string | undefined;
    fromBlock: number | undefined;
    toBlock: number | undefined;
    contractAddresses: string[] | undefined;
    excludeContracts: string[] | undefined;
    walletAddresses: string[] | undefined;
    excludeWallets: string[] | undefined;
}, Erc20Mint[], {
    token_name: string;
    token_symbol: string;
    token_logo?: string | undefined;
    token_decimals: string;
    contract_address: string;
    transaction_hash: string;
    transaction_index: number;
    log_index: number;
    block_timestamp: string;
    block_number: number;
    block_hash: string;
    to_wallet: string;
    value: string;
    value_decimal: string;
    possible_spam?: boolean | undefined;
}[] | undefined> | _moralisweb3_common_core.Operation<GetInternalTransactionsRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    transactionHash: string;
}, EvmInternalTransaction[], {
    transaction_hash: string;
    block_number: string;
    block_hash: string;
    type: string;
    from: string;
    to: string;
    value: string;
    gas: string;
    gas_used: string;
    input: string;
    output: string;
}[]> | _moralisweb3_common_core.Operation<GetMultipleNFTsRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    normalizeMetadata: boolean | undefined;
    tokens: {
        tokenAddress: string;
        tokenId: string;
    }[];
    mediaItems: boolean | undefined;
}, (EvmNft | null)[], ({
    token_address: string;
    token_id: string;
    contract_type: string;
    owner_of: string;
    block_number: string;
    block_number_minted: string;
    token_uri?: string | undefined;
    metadata?: string | undefined;
    normalized_metadata?: {
        name?: string | undefined;
        description?: string | undefined;
        image?: string | undefined;
        external_link?: string | undefined;
        animation_url?: string | undefined;
        attributes?: {
            trait_type?: string | undefined;
            value?: {
                [key: string]: unknown;
            } | undefined;
            display_type?: string | undefined;
            max_value?: number | undefined;
            trait_count?: number | undefined;
            order?: number | undefined;
        }[] | undefined;
    } | undefined;
    media?: {
        mimetype?: string | undefined;
        category?: "image" | "video" | "audio" | undefined;
        status?: "success" | "processing" | "unsupported_media" | "invalid_url" | "host_unavailable" | "temporarily_unavailable" | undefined;
        original_media_url?: string | undefined;
        updatedAt?: string | undefined;
        parent_hash?: string | undefined;
        media_collection?: ({
            low: {
                width: number;
                height: number;
                url: string;
            };
            medium: {
                width: number;
                height: number;
                url: string;
            };
            high: {
                width: number;
                height: number;
                url: string;
            };
        } & {
            original: unknown;
        }) | undefined;
    } | undefined;
    amount?: string | undefined;
    name: string;
    symbol: string;
    token_hash: string;
    last_token_uri_sync: string;
    last_metadata_sync: string;
    possible_spam: boolean;
} | null)[]> | _moralisweb3_common_core.Operation<GetNativeBalanceRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    toBlock: number | undefined;
    address: string;
}, {
    balance: EvmNative;
}, {
    balance: string;
}> | _moralisweb3_common_core.Operation<GetNativeBalancesForAddressesRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    toBlock: number | undefined;
    walletAddresses: string[];
}, {
    chain: EvmChain;
    blockNumber: string;
    blockTimestamp: string;
    totalBalance: EvmNative;
    walletBalances: {
        address: EvmAddress;
        balance: EvmNative;
    }[];
}[], {
    chain: string;
    chain_id: string;
    total_balance: string;
    block_number: string;
    block_timestamp: string;
    total_balance_formatted: string;
    wallet_balances: {
        address: string;
        balance: string;
        balance_formatted: string;
    }[];
}[]> | _moralisweb3_common_core.Operation<GetNFTContractMetadataRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    address: string;
}, EvmNftMetadata, {
    token_address: string;
    name: string;
    synced_at?: string | undefined;
    symbol: string;
    contract_type: string;
}> | _moralisweb3_common_core.PaginatedOperation<GetNFTContractTransfersRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    format: "decimal" | "hex" | undefined;
    limit: number | undefined;
    cursor: string | undefined;
    address: string;
    fromBlock: number | undefined;
    toBlock: number | undefined;
    fromDate: string | undefined;
    toDate: string | undefined;
    disableTotal: boolean | undefined;
}, EvmNftTransfer[], {
    token_address: string;
    token_id: string;
    from_address?: string | undefined;
    to_address: string;
    value?: string | undefined;
    amount?: string | undefined;
    contract_type: string;
    block_number: string;
    block_timestamp: string;
    block_hash: string;
    transaction_hash: string;
    transaction_type?: string | undefined;
    transaction_index?: number | undefined;
    log_index: number;
    operator?: string | undefined;
    possible_spam: boolean;
}[]> | _moralisweb3_common_core.Operation<GetNFTLowestPriceRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    days: number | undefined;
    marketplace: "opensea" | undefined;
    address: string;
}, EvmTrade, {
    transaction_hash: string;
    transaction_index: string;
    token_ids: string[];
    seller_address: string;
    buyer_address: string;
    token_address: string;
    marketplace_address: string;
    price_token_address?: string | undefined;
    price: string;
    block_timestamp: string;
    block_number: string;
    block_hash: string;
}> | _moralisweb3_common_core.Operation<GetNFTMetadataRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    format: "decimal" | "hex" | undefined;
    address: string;
    tokenId: string;
    normalizeMetadata: boolean | undefined;
    mediaItems: boolean | undefined;
}, EvmNft, {
    token_address: string;
    token_id: string;
    owner_of?: string | undefined;
    token_hash?: string | undefined;
    block_number?: string | undefined;
    block_number_minted?: string | undefined;
    contract_type: string;
    token_uri?: string | undefined;
    metadata?: string | undefined;
    normalized_metadata?: {
        name?: string | undefined;
        description?: string | undefined;
        image?: string | undefined;
        external_link?: string | undefined;
        animation_url?: string | undefined;
        attributes?: {
            trait_type?: string | undefined;
            value?: {
                [key: string]: unknown;
            } | undefined;
            display_type?: string | undefined;
            max_value?: number | undefined;
            trait_count?: number | undefined;
            order?: number | undefined;
        }[] | undefined;
    } | undefined;
    media?: {
        mimetype?: string | undefined;
        category?: "image" | "video" | "audio" | undefined;
        status?: "success" | "processing" | "unsupported_media" | "invalid_url" | "host_unavailable" | "temporarily_unavailable" | undefined;
        original_media_url?: string | undefined;
        updatedAt?: string | undefined;
        parent_hash?: string | undefined;
        media_collection?: ({
            low: {
                width: number;
                height: number;
                url: string;
            };
            medium: {
                width: number;
                height: number;
                url: string;
            };
            high: {
                width: number;
                height: number;
                url: string;
            };
        } & {
            original: unknown;
        }) | undefined;
    } | undefined;
    minter_address?: string | undefined;
    last_token_uri_sync?: string | undefined;
    last_metadata_sync?: string | undefined;
    amount?: string | undefined;
    name: string;
    symbol: string;
    possible_spam: boolean;
}> | _moralisweb3_common_core.PaginatedOperation<GetNFTOwnersRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    format: "decimal" | "hex" | undefined;
    limit: number | undefined;
    cursor: string | undefined;
    address: string;
    normalizeMetadata: boolean | undefined;
    disableTotal: boolean | undefined;
    mediaItems: boolean | undefined;
}, EvmNft[], {
    token_address: string;
    token_id: string;
    contract_type: string;
    owner_of: string;
    block_number: string;
    block_number_minted: string;
    token_uri?: string | undefined;
    metadata?: string | undefined;
    normalized_metadata?: {
        name?: string | undefined;
        description?: string | undefined;
        image?: string | undefined;
        external_link?: string | undefined;
        animation_url?: string | undefined;
        attributes?: {
            trait_type?: string | undefined;
            value?: {
                [key: string]: unknown;
            } | undefined;
            display_type?: string | undefined;
            max_value?: number | undefined;
            trait_count?: number | undefined;
            order?: number | undefined;
        }[] | undefined;
    } | undefined;
    media?: {
        mimetype?: string | undefined;
        category?: "image" | "video" | "audio" | undefined;
        status?: "success" | "processing" | "unsupported_media" | "invalid_url" | "host_unavailable" | "temporarily_unavailable" | undefined;
        original_media_url?: string | undefined;
        updatedAt?: string | undefined;
        parent_hash?: string | undefined;
        media_collection?: ({
            low: {
                width: number;
                height: number;
                url: string;
            };
            medium: {
                width: number;
                height: number;
                url: string;
            };
            high: {
                width: number;
                height: number;
                url: string;
            };
        } & {
            original: unknown;
        }) | undefined;
    } | undefined;
    amount?: string | undefined;
    name: string;
    symbol: string;
    token_hash: string;
    last_token_uri_sync: string;
    last_metadata_sync: string;
    possible_spam: boolean;
}[] | undefined> | _moralisweb3_common_core.PaginatedOperation<GetNFTTokenIdOwnersRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    format: "decimal" | "hex" | undefined;
    limit: number | undefined;
    cursor: string | undefined;
    address: string;
    tokenId: string;
    normalizeMetadata: boolean | undefined;
    disableTotal: boolean | undefined;
    mediaItems: boolean | undefined;
}, EvmNft[], {
    token_address: string;
    token_id: string;
    contract_type: string;
    owner_of: string;
    block_number: string;
    block_number_minted: string;
    token_uri?: string | undefined;
    metadata?: string | undefined;
    normalized_metadata?: {
        name?: string | undefined;
        description?: string | undefined;
        image?: string | undefined;
        external_link?: string | undefined;
        animation_url?: string | undefined;
        attributes?: {
            trait_type?: string | undefined;
            value?: {
                [key: string]: unknown;
            } | undefined;
            display_type?: string | undefined;
            max_value?: number | undefined;
            trait_count?: number | undefined;
            order?: number | undefined;
        }[] | undefined;
    } | undefined;
    media?: {
        mimetype?: string | undefined;
        category?: "image" | "video" | "audio" | undefined;
        status?: "success" | "processing" | "unsupported_media" | "invalid_url" | "host_unavailable" | "temporarily_unavailable" | undefined;
        original_media_url?: string | undefined;
        updatedAt?: string | undefined;
        parent_hash?: string | undefined;
        media_collection?: ({
            low: {
                width: number;
                height: number;
                url: string;
            };
            medium: {
                width: number;
                height: number;
                url: string;
            };
            high: {
                width: number;
                height: number;
                url: string;
            };
        } & {
            original: unknown;
        }) | undefined;
    } | undefined;
    amount?: string | undefined;
    name: string;
    symbol: string;
    token_hash: string;
    last_token_uri_sync: string;
    last_metadata_sync: string;
    possible_spam: boolean;
}[] | undefined> | _moralisweb3_common_core.PaginatedOperation<GetNFTTransfersByBlockRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    limit: number | undefined;
    cursor: string | undefined;
    blockNumberOrHash: string;
    disableTotal: boolean | undefined;
}, EvmNftTransfer[], {
    token_address: string;
    token_id: string;
    from_address?: string | undefined;
    to_address: string;
    value?: string | undefined;
    amount?: string | undefined;
    contract_type: string;
    block_number: string;
    block_timestamp: string;
    block_hash: string;
    transaction_hash: string;
    transaction_type?: string | undefined;
    transaction_index?: number | undefined;
    log_index: number;
    operator?: string | undefined;
    possible_spam: boolean;
}[]> | _moralisweb3_common_core.PaginatedOperation<GetNFTTransfersFromToBlockRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    fromBlock: number | undefined;
    toBlock: number | undefined;
    fromDate: _moralisweb3_common_core.DateInput | undefined;
    toDate: _moralisweb3_common_core.DateInput | undefined;
    format: "decimal" | "hex" | undefined;
    limit: number | undefined;
    cursor: string | undefined;
    disableTotal: boolean | undefined;
}, EvmNftTransfer[], {
    token_address: string;
    token_id: string;
    from_address?: string | undefined;
    to_address: string;
    value?: string | undefined;
    amount?: string | undefined;
    contract_type: string;
    block_number: string;
    block_timestamp: string;
    block_hash: string;
    transaction_hash: string;
    transaction_type?: string | undefined;
    transaction_index?: number | undefined;
    log_index: number;
    operator?: string | undefined;
    possible_spam: boolean;
}[]> | _moralisweb3_common_core.PaginatedOperation<GetNFTTransfersRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    format: "decimal" | "hex" | undefined;
    limit: number | undefined;
    cursor: string | undefined;
    address: string;
    tokenId: string;
    disableTotal: boolean | undefined;
}, EvmNftTransfer[], {
    token_address: string;
    token_id: string;
    from_address?: string | undefined;
    to_address: string;
    value?: string | undefined;
    amount?: string | undefined;
    contract_type: string;
    block_number: string;
    block_timestamp: string;
    block_hash: string;
    transaction_hash: string;
    transaction_type?: string | undefined;
    transaction_index?: number | undefined;
    log_index: number;
    operator?: string | undefined;
    possible_spam: boolean;
}[]> | _moralisweb3_common_core.Operation<GetPairAddressRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    toBlock: string | undefined;
    toDate: string | undefined;
    exchange: _moralisweb3_common_core.Camelize<"uniswapv2" | "uniswapv3" | "sushiswapv2" | "pancakeswapv2" | "pancakeswapv1" | "quickswap">;
    token0Address: string;
    token1Address: string;
}, {
    token0: {
        token: Erc20Token;
        blockNumber: string | undefined;
        validated: number | undefined;
        createdAt: Date | undefined;
    };
    token1: {
        token: Erc20Token;
        blockNumber: string | undefined;
        validated: number | undefined;
        createdAt: Date | undefined;
    };
    pairAddress: EvmAddress | undefined;
}, {
    token0?: {
        address?: string | undefined;
        name?: string | undefined;
        symbol?: string | undefined;
        decimals?: string | undefined;
        logo?: string | undefined;
        logo_hash?: string | undefined;
        thumbnail?: string | undefined;
        block_number?: string | undefined;
        validated?: number | undefined;
        created_at?: string | undefined;
    } | undefined;
    token1?: {
        address?: string | undefined;
        name?: string | undefined;
        symbol?: string | undefined;
        decimals?: string | undefined;
        logo?: string | undefined;
        logo_hash?: string | undefined;
        thumbnail?: string | undefined;
        block_number?: string | undefined;
        validated?: number | undefined;
        created_at?: string | undefined;
    } | undefined;
    pairAddress?: string | undefined;
}> | _moralisweb3_common_core.Operation<GetPairReservesRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    toBlock: string | undefined;
    toDate: string | undefined;
    pairAddress: string;
}, {
    reserve0?: string | undefined;
    reserve1?: string | undefined;
}, {
    reserve0?: string | undefined;
    reserve1?: string | undefined;
}> | _moralisweb3_common_core.Operation<GetTokenAllowanceRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    ownerAddress: string;
    spenderAddress: string;
    address: string;
}, {
    allowance: _moralisweb3_common_core.BigNumber;
}, {
    allowance: string;
}> | _moralisweb3_common_core.Operation<GetTokenMetadataBySymbolRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    symbols: string[];
}, {
    token: Erc20Token;
    blockNumber: string | undefined;
    validated: string | undefined;
}[], {
    address: string;
    name: string;
    symbol: string;
    decimals: string;
    logo?: string | undefined;
    logo_hash?: string | undefined;
    thumbnail?: string | undefined;
    block_number?: string | undefined;
    validated?: string | undefined;
    possible_spam: boolean;
}[]> | _moralisweb3_common_core.Operation<GetTokenMetadataRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    addresses: string[];
}, {
    token: Erc20Token;
    blockNumber: string | undefined;
    validated: string | undefined;
}[], {
    address: string;
    name: string;
    symbol: string;
    decimals: string;
    logo?: string | undefined;
    logo_hash?: string | undefined;
    thumbnail?: string | undefined;
    block_number?: string | undefined;
    validated?: string | undefined;
    possible_spam: boolean;
}[]> | _moralisweb3_common_core.Operation<GetTokenPriceRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    exchange: string | undefined;
    toBlock: number | undefined;
    address: string;
}, {
    nativePrice: EvmNative | null;
    exchangeAddress: EvmAddress | null;
    tokenName?: string | undefined;
    tokenSymbol?: string | undefined;
    tokenLogo?: string | undefined;
    tokenDecimals?: string | undefined;
    usdPrice: number;
    exchangeName?: string | undefined;
    tokenAddress?: string | undefined;
}, {
    tokenName?: string | undefined;
    tokenSymbol?: string | undefined;
    tokenLogo?: string | undefined;
    tokenDecimals?: string | undefined;
    nativePrice?: {
        value: string;
        decimals: number;
        name: string;
        symbol: string;
        address: string;
    } | undefined;
    usdPrice: number;
    exchangeAddress?: string | undefined;
    exchangeName?: string | undefined;
    tokenAddress?: string | undefined;
}> | _moralisweb3_common_core.PaginatedOperation<GetTokenTransfersRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    fromBlock: number | undefined;
    toBlock: number | undefined;
    fromDate: _moralisweb3_common_core.DateInput | undefined;
    toDate: _moralisweb3_common_core.DateInput | undefined;
    limit: number | undefined;
    address: string;
    cursor: string | undefined;
    disableTotal: boolean | undefined;
}, Erc20Transaction[], ({
    token_name: string;
    token_symbol: string;
    token_logo?: string | undefined;
    token_decimals: string;
    transaction_hash: string;
    address: string;
    block_timestamp: string;
    block_number: string;
    block_hash: string;
    to_address: string;
    from_address: string;
    value: string;
    transaction_index: number;
    log_index: number;
    possible_spam: boolean;
} & {
    value_decimal: unknown;
})[] | undefined> | _moralisweb3_common_core.Operation<GetTransactionRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    transactionHash: string;
    include: "internal_transactions" | undefined;
}, EvmTransaction, {
    hash: string;
    nonce: string;
    transaction_index: string;
    from_address: string;
    to_address: unknown;
    value: string;
    gas?: string | undefined;
    gas_price: string;
    input: string;
    receipt_cumulative_gas_used: string;
    receipt_gas_used: string;
    receipt_contract_address?: unknown;
    receipt_root?: unknown;
    receipt_status: string;
    block_timestamp: string;
    block_number: string;
    block_hash: string;
    logs?: {
        log_index: string;
        transaction_hash: string;
        transaction_index: string;
        address: string;
        data: string;
        topic0: string;
        topic1?: unknown;
        topic2?: unknown;
        topic3?: unknown;
        block_timestamp: string;
        block_number: string;
        block_hash: string;
    }[] | undefined;
    internal_transactions?: {
        transaction_hash: string;
        block_number: string;
        block_hash: string;
        type: string;
        from: string;
        to: string;
        value: string;
        gas: string;
        gas_used: string;
        input: string;
        output: string;
    }[] | undefined;
}> | _moralisweb3_common_core.Operation<GetTransactionVerboseRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    transactionHash: string;
    include: "internal_transactions" | undefined;
}, EvmTransactionVerbose, {
    hash: string;
    nonce: string;
    transaction_index: string;
    from_address: string;
    to_address: string;
    value: string;
    gas?: string | undefined;
    gas_price: string;
    input: string;
    receipt_cumulative_gas_used: string;
    receipt_gas_used: string;
    receipt_contract_address?: string | undefined;
    receipt_root?: string | undefined;
    receipt_status: string;
    block_timestamp: string;
    block_number: string;
    block_hash: string;
    logs: {
        log_index: string;
        transaction_hash: string;
        transaction_index: string;
        address: string;
        data: string;
        topic0: string;
        topic1?: string | undefined;
        topic2?: string | undefined;
        topic3?: string | undefined;
        block_timestamp: string;
        block_number: string;
        block_hash: string;
        decoded_event: {
            signature?: string | undefined;
            label?: string | undefined;
            type?: string | undefined;
            params?: {
                name?: string | undefined;
                value?: string | undefined;
                type?: string | undefined;
            }[] | undefined;
        };
    }[];
    decoded_call: {
        signature?: string | undefined;
        label?: string | undefined;
        type?: string | undefined;
        params?: {
            name?: string | undefined;
            value?: string | undefined;
            type?: string | undefined;
        }[] | undefined;
    };
}> | _moralisweb3_common_core.PaginatedOperation<GetWalletNFTCollectionsRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    limit: number | undefined;
    cursor: string | undefined;
    address: string;
    disableTotal: boolean | undefined;
}, EvmNftCollection[], {
    token_address: string;
    contract_type: string;
    name: string;
    symbol: string;
}[] | undefined> | _moralisweb3_common_core.PaginatedOperation<GetWalletNFTsRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    format: "decimal" | "hex" | undefined;
    limit: number | undefined;
    tokenAddresses: string[] | undefined;
    cursor: string | undefined;
    address: string;
    normalizeMetadata: boolean | undefined;
    disableTotal: boolean | undefined;
    mediaItems: boolean | undefined;
}, EvmNft[], {
    token_address: string;
    token_id: string;
    contract_type: string;
    owner_of: string;
    block_number: string;
    block_number_minted: string;
    token_uri?: string | undefined;
    metadata?: string | undefined;
    normalized_metadata?: {
        name?: string | undefined;
        description?: string | undefined;
        image?: string | undefined;
        external_link?: string | undefined;
        animation_url?: string | undefined;
        attributes?: {
            trait_type?: string | undefined;
            value?: {
                [key: string]: unknown;
            } | undefined;
            display_type?: string | undefined;
            max_value?: number | undefined;
            trait_count?: number | undefined;
            order?: number | undefined;
        }[] | undefined;
    } | undefined;
    media?: {
        mimetype?: string | undefined;
        category?: "image" | "video" | "audio" | undefined;
        status?: "success" | "processing" | "unsupported_media" | "invalid_url" | "host_unavailable" | "temporarily_unavailable" | undefined;
        original_media_url?: string | undefined;
        updatedAt?: string | undefined;
        parent_hash?: string | undefined;
        media_collection?: ({
            low: {
                width: number;
                height: number;
                url: string;
            };
            medium: {
                width: number;
                height: number;
                url: string;
            };
            high: {
                width: number;
                height: number;
                url: string;
            };
        } & {
            original: unknown;
        }) | undefined;
    } | undefined;
    amount?: string | undefined;
    name: string;
    symbol: string;
    token_hash: string;
    last_token_uri_sync: string;
    last_metadata_sync: string;
    possible_spam: boolean;
}[] | undefined> | _moralisweb3_common_core.PaginatedOperation<GetWalletNFTTransfersRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    format: "decimal" | "hex" | undefined;
    direction: "from" | "to" | "both" | undefined;
    fromBlock: number | undefined;
    toBlock: string | undefined;
    limit: number | undefined;
    cursor: string | undefined;
    address: string;
    disableTotal: boolean | undefined;
    fromDate: string | undefined;
    toDate: string | undefined;
}, EvmNftTransfer[], {
    token_address: string;
    token_id: string;
    from_address?: string | undefined;
    to_address: string;
    value?: string | undefined;
    amount?: string | undefined;
    contract_type: string;
    block_number: string;
    block_timestamp: string;
    block_hash: string;
    transaction_hash: string;
    transaction_type?: string | undefined;
    transaction_index?: number | undefined;
    log_index: number;
    operator?: string | undefined;
    possible_spam: boolean;
}[]> | _moralisweb3_common_core.Operation<GetWalletTokenBalancesRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    tokenAddresses: string[] | undefined;
    address: string;
    toBlock: number | undefined;
}, Erc20Value[], {
    token_address: string;
    name: string;
    symbol: string;
    logo?: string | undefined;
    thumbnail?: string | undefined;
    decimals: number;
    balance: string;
    possible_spam: boolean;
}[]> | _moralisweb3_common_core.PaginatedOperation<GetWalletTransactionsRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    fromBlock: number | undefined;
    toBlock: number | undefined;
    fromDate: _moralisweb3_common_core.DateInput | undefined;
    toDate: _moralisweb3_common_core.DateInput | undefined;
    cursor: string | undefined;
    limit: number | undefined;
    address: string;
    disableTotal: boolean | undefined;
    include: "internal_transactions" | undefined;
}, EvmTransaction[], {
    hash: string;
    nonce: string;
    transaction_index: string;
    from_address: string;
    to_address: string;
    value: string;
    gas: string;
    gas_price: string;
    input: string;
    receipt_cumulative_gas_used: string;
    receipt_gas_used: string;
    receipt_contract_address: string;
    receipt_root: string;
    receipt_status: string;
    block_timestamp: string;
    block_number: string;
    block_hash: string;
    internal_transactions?: {
        transaction_hash: string;
        block_number: string;
        block_hash: string;
        type: string;
        from: string;
        to: string;
        value: string;
        gas: string;
        gas_used: string;
        input: string;
        output: string;
    }[] | undefined;
}[] | undefined> | _moralisweb3_common_core.PaginatedOperation<GetWalletTransactionsVerboseRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    fromBlock: number | undefined;
    toBlock: number | undefined;
    fromDate: _moralisweb3_common_core.DateInput | undefined;
    toDate: _moralisweb3_common_core.DateInput | undefined;
    cursor: string | undefined;
    limit: number | undefined;
    address: string;
    disableTotal: boolean | undefined;
    include: "internal_transactions" | undefined;
}, EvmTransaction[], {
    hash: string;
    nonce: string;
    transaction_index: string;
    from_address: string;
    to_address: string;
    value: string;
    gas?: string | undefined;
    gas_price: string;
    input: string;
    receipt_cumulative_gas_used: string;
    receipt_gas_used: string;
    receipt_contract_address?: string | undefined;
    receipt_root?: string | undefined;
    receipt_status: string;
    block_timestamp: string;
    block_number: string;
    block_hash: string;
    logs: {
        log_index: string;
        transaction_hash: string;
        transaction_index: string;
        address: string;
        data: string;
        topic0: string;
        topic1?: string | undefined;
        topic2?: string | undefined;
        topic3?: string | undefined;
        block_timestamp: string;
        block_number: string;
        block_hash: string;
        decoded_event: {
            signature?: string | undefined;
            label?: string | undefined;
            type?: string | undefined;
            params?: {
                name?: string | undefined;
                value?: string | undefined;
                type?: string | undefined;
            }[] | undefined;
        };
    }[];
    decoded_call: {
        signature?: string | undefined;
        label?: string | undefined;
        type?: string | undefined;
        params?: {
            name?: string | undefined;
            value?: string | undefined;
            type?: string | undefined;
        }[] | undefined;
    };
}[] | undefined> | _moralisweb3_common_core.Operation<ResolveAddressRequest, {
    address: string | undefined;
}, {
    name: string;
}, {
    name: string;
}> | _moralisweb3_common_core.Operation<ResolveDomainRequest, {
    currency: "0x1" | "eth" | undefined;
    domain: string;
}, {
    address: EvmAddress;
}, {
    address: string;
}> | _moralisweb3_common_core.Operation<ResolveENSDomainRequest, {
    domain: string;
}, {
    address: EvmAddress;
}, {
    address: string;
}> | _moralisweb3_common_core.Operation<ReSyncMetadataRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    flag: "metadata" | "uri" | undefined;
    mode: "async" | "sync" | undefined;
    address: string;
    tokenId: string;
}, {
    status: string;
}, {
    status: string;
}> | _moralisweb3_common_core.Operation<RunContractFunctionRequest, {
    address: string;
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    functionName: string;
    abi: unknown;
    params: {
        [key: string]: unknown;
    } | undefined;
}, string, string> | _moralisweb3_common_core.PaginatedOperation<SearchNFTsRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    format: "decimal" | "hex" | undefined;
    q: string;
    filter: "name" | "description" | "attributes" | "global" | "name,description" | "name,attributes" | "description,attributes" | "name,description,attributes" | undefined;
    fromBlock: number | undefined;
    toBlock: number | undefined;
    fromDate: _moralisweb3_common_core.DateInput | undefined;
    toDate: _moralisweb3_common_core.DateInput | undefined;
    addresses: string[] | undefined;
    cursor: string | undefined;
    limit: number | undefined;
    disableTotal: boolean | undefined;
}, {
    token: EvmNft;
    tokenHash: string;
    blockNumberMinted: string;
    lastMetadataSync: Date | undefined;
    lastTokenUriSync: Date | undefined;
    batchId: string;
    frozen: number;
    frozenLogIndex: {
        [key: string]: unknown;
    } | undefined;
    imported: {
        [key: string]: unknown;
    } | undefined;
    isValid: number;
    openseaLookup: {
        [key: string]: unknown;
    } | undefined;
    resyncing: number;
    syncing: number;
    updatedAt: Date;
}[], {
    token_id: string;
    token_address: string;
    token_uri: string;
    metadata: string;
    is_valid: number;
    syncing: number;
    frozen: number;
    resyncing: number;
    contract_type: string;
    token_hash: string;
    batch_id: string;
    metadata_name: string;
    metadata_description: string;
    metadata_attributes: string;
    block_number_minted: string;
    opensea_lookup?: {
        [key: string]: unknown;
    } | undefined;
    minter_address: string;
    transaction_minted: string;
    frozen_log_index?: {
        [key: string]: unknown;
    } | undefined;
    imported?: {
        [key: string]: unknown;
    } | undefined;
    last_token_uri_sync: string;
    last_metadata_sync: string;
    createdAt: string;
    updatedAt: string;
    possible_spam: boolean;
}[] | undefined> | _moralisweb3_common_core.Operation<SyncNFTContractRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    address: string;
}, {
    success: boolean;
}, unknown> | _moralisweb3_common_core.Operation<UploadFolderRequest, {
    abi: string;
}, {
    path: string;
}[], {
    path: string;
}[]>)[];
/**
 * @deprecated This list includes upgraded operations to the hybrid approach in the old format.
 */
declare const operationsV2All: (_moralisweb3_common_core.Operation<GetBlockRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    blockNumberOrHash: string;
    include: "internal_transactions" | undefined;
}, EvmBlock, {
    timestamp: string;
    number: string;
    hash: string;
    parent_hash: string;
    nonce: string;
    sha3_uncles: string;
    logs_bloom: string;
    transactions_root: string;
    state_root: string;
    receipts_root: string;
    miner: string;
    difficulty: string;
    total_difficulty: string;
    size: string;
    extra_data: string;
    gas_limit: string;
    gas_used: string;
    transaction_count: string;
    transactions: {
        hash: string;
        nonce: string;
        transaction_index: string;
        from_address: string;
        to_address: unknown;
        value: string;
        gas?: string | undefined;
        gas_price: string;
        input: string;
        receipt_cumulative_gas_used: string;
        receipt_gas_used: string;
        receipt_contract_address?: unknown;
        receipt_root?: unknown;
        receipt_status: string;
        block_timestamp: string;
        block_number: string;
        block_hash: string;
        logs?: {
            log_index: string;
            transaction_hash: string;
            transaction_index: string;
            address: string;
            data: string;
            topic0: string;
            topic1?: unknown;
            topic2?: unknown;
            topic3?: unknown;
            block_timestamp: string;
            block_number: string;
            block_hash: string;
        }[] | undefined;
        internal_transactions?: {
            transaction_hash: string;
            block_number: string;
            block_hash: string;
            type: string;
            from: string;
            to: string;
            value: string;
            gas: string;
            gas_used: string;
            input: string;
            output: string;
        }[] | undefined;
    }[];
}> | _moralisweb3_common_core.PaginatedOperation<GetContractEventsRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    fromBlock: number | undefined;
    toBlock: number | undefined;
    fromDate: string | undefined;
    toDate: string | undefined;
    topic: string;
    offset: number | undefined;
    limit: number | undefined;
    address: string;
    abi: EvmAbiItem;
    disableTotal: boolean | undefined;
}, EvmEvent[], {
    transaction_hash: string;
    address: string;
    block_timestamp: string;
    block_number: string;
    block_hash: string;
    data: {
        from?: string | undefined;
        to?: string | undefined;
        value?: string | undefined;
    };
}[] | undefined> | _moralisweb3_common_core.PaginatedOperation<GetContractLogsRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    blockNumber: string | undefined;
    fromBlock: string | undefined;
    toBlock: string | undefined;
    fromDate: string | undefined;
    toDate: string | undefined;
    topic0: string | undefined;
    topic1: string | undefined;
    topic2: string | undefined;
    topic3: string | undefined;
    limit: number | undefined;
    cursor: string | undefined;
    address: string;
    disableTotal: boolean | undefined;
}, EvmTransactionLog[], {
    transaction_hash: string;
    address: string;
    block_timestamp: string;
    block_number: string;
    block_hash: string;
    data: string;
    topic0: string;
    topic1: string;
    topic2: string;
    topic3: string;
    transaction_index: number;
    log_index: number;
}[] | undefined> | _moralisweb3_common_core.PaginatedOperation<GetContractNFTsRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    format: "decimal" | "hex" | undefined;
    limit: number | undefined;
    totalRanges: number | undefined;
    range: number | undefined;
    cursor: string | undefined;
    address: string;
    normalizeMetadata: boolean | undefined;
    disableTotal: boolean | undefined;
    mediaItems: boolean | undefined;
}, EvmNft[], {
    token_address: string;
    token_id: string;
    owner_of?: string | undefined;
    token_hash?: string | undefined;
    block_number?: string | undefined;
    block_number_minted?: string | undefined;
    contract_type: string;
    token_uri?: string | undefined;
    metadata?: string | undefined;
    normalized_metadata?: {
        name?: string | undefined;
        description?: string | undefined;
        image?: string | undefined;
        external_link?: string | undefined;
        animation_url?: string | undefined;
        attributes?: {
            trait_type?: string | undefined;
            value?: {
                [key: string]: unknown;
            } | undefined;
            display_type?: string | undefined;
            max_value?: number | undefined;
            trait_count?: number | undefined;
            order?: number | undefined;
        }[] | undefined;
    } | undefined;
    media?: {
        mimetype?: string | undefined;
        category?: "image" | "video" | "audio" | undefined;
        status?: "success" | "processing" | "unsupported_media" | "invalid_url" | "host_unavailable" | "temporarily_unavailable" | undefined;
        original_media_url?: string | undefined;
        updatedAt?: string | undefined;
        parent_hash?: string | undefined;
        media_collection?: ({
            low: {
                width: number;
                height: number;
                url: string;
            };
            medium: {
                width: number;
                height: number;
                url: string;
            };
            high: {
                width: number;
                height: number;
                url: string;
            };
        } & {
            original: unknown;
        }) | undefined;
    } | undefined;
    minter_address?: string | undefined;
    last_token_uri_sync?: string | undefined;
    last_metadata_sync?: string | undefined;
    amount?: string | undefined;
    name: string;
    symbol: string;
    possible_spam: boolean;
}[] | undefined> | _moralisweb3_common_core.Operation<GetDateToBlockRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    date: string;
}, EvmBlockDate, {
    date: string;
    block: number;
    timestamp: number;
    block_timestamp?: string | undefined;
    hash?: string | undefined;
    parent_hash?: string | undefined;
}> | _moralisweb3_common_core.PaginatedOperation<GetErc20ApprovalsRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    limit: number | undefined;
    cursor: string | undefined;
    fromBlock: number | undefined;
    toBlock: number | undefined;
    contractAddresses: string[] | undefined;
    excludeContracts: string[] | undefined;
    walletAddresses: string[] | undefined;
    excludeWallets: string[] | undefined;
}, Erc20Approval[], {
    token_name: string;
    token_symbol: string;
    token_logo?: string | undefined;
    token_decimals: string;
    contract_address: string;
    transaction_hash: string;
    transaction_index: number;
    log_index: number;
    block_timestamp: string;
    block_number: number;
    block_hash: string;
    from_wallet: string;
    to_wallet: string;
    value: string;
    value_decimal: string;
    possible_spam: boolean;
}[] | undefined> | _moralisweb3_common_core.PaginatedOperation<GetErc20BurnsRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    limit: number | undefined;
    cursor: string | undefined;
    fromBlock: number | undefined;
    toBlock: number | undefined;
    contractAddresses: string[] | undefined;
    excludeContracts: string[] | undefined;
    walletAddresses: string[] | undefined;
    excludeWallets: string[] | undefined;
}, Erc20Burn[], {
    token_name: string;
    token_symbol: string;
    token_logo?: string | undefined;
    token_decimals: string;
    contract_address: string;
    transaction_hash: string;
    transaction_index: number;
    log_index: number;
    block_timestamp: string;
    block_number: number;
    block_hash: string;
    from_wallet: string;
    value: string;
    value_decimal: string;
    possible_spam?: boolean | undefined;
}[] | undefined> | _moralisweb3_common_core.PaginatedOperation<GetErc20MintsRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    limit: number | undefined;
    cursor: string | undefined;
    fromBlock: number | undefined;
    toBlock: number | undefined;
    contractAddresses: string[] | undefined;
    excludeContracts: string[] | undefined;
    walletAddresses: string[] | undefined;
    excludeWallets: string[] | undefined;
}, Erc20Mint[], {
    token_name: string;
    token_symbol: string;
    token_logo?: string | undefined;
    token_decimals: string;
    contract_address: string;
    transaction_hash: string;
    transaction_index: number;
    log_index: number;
    block_timestamp: string;
    block_number: number;
    block_hash: string;
    to_wallet: string;
    value: string;
    value_decimal: string;
    possible_spam?: boolean | undefined;
}[] | undefined> | _moralisweb3_common_core.Operation<GetInternalTransactionsRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    transactionHash: string;
}, EvmInternalTransaction[], {
    transaction_hash: string;
    block_number: string;
    block_hash: string;
    type: string;
    from: string;
    to: string;
    value: string;
    gas: string;
    gas_used: string;
    input: string;
    output: string;
}[]> | _moralisweb3_common_core.Operation<GetMultipleNFTsRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    normalizeMetadata: boolean | undefined;
    tokens: {
        tokenAddress: string;
        tokenId: string;
    }[];
    mediaItems: boolean | undefined;
}, (EvmNft | null)[], ({
    token_address: string;
    token_id: string;
    contract_type: string;
    owner_of: string;
    block_number: string;
    block_number_minted: string;
    token_uri?: string | undefined;
    metadata?: string | undefined;
    normalized_metadata?: {
        name?: string | undefined;
        description?: string | undefined;
        image?: string | undefined;
        external_link?: string | undefined;
        animation_url?: string | undefined;
        attributes?: {
            trait_type?: string | undefined;
            value?: {
                [key: string]: unknown;
            } | undefined;
            display_type?: string | undefined;
            max_value?: number | undefined;
            trait_count?: number | undefined;
            order?: number | undefined;
        }[] | undefined;
    } | undefined;
    media?: {
        mimetype?: string | undefined;
        category?: "image" | "video" | "audio" | undefined;
        status?: "success" | "processing" | "unsupported_media" | "invalid_url" | "host_unavailable" | "temporarily_unavailable" | undefined;
        original_media_url?: string | undefined;
        updatedAt?: string | undefined;
        parent_hash?: string | undefined;
        media_collection?: ({
            low: {
                width: number;
                height: number;
                url: string;
            };
            medium: {
                width: number;
                height: number;
                url: string;
            };
            high: {
                width: number;
                height: number;
                url: string;
            };
        } & {
            original: unknown;
        }) | undefined;
    } | undefined;
    amount?: string | undefined;
    name: string;
    symbol: string;
    token_hash: string;
    last_token_uri_sync: string;
    last_metadata_sync: string;
    possible_spam: boolean;
} | null)[]> | _moralisweb3_common_core.Operation<GetNativeBalanceRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    toBlock: number | undefined;
    address: string;
}, {
    balance: EvmNative;
}, {
    balance: string;
}> | _moralisweb3_common_core.Operation<GetNativeBalancesForAddressesRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    toBlock: number | undefined;
    walletAddresses: string[];
}, {
    chain: EvmChain;
    blockNumber: string;
    blockTimestamp: string;
    totalBalance: EvmNative;
    walletBalances: {
        address: EvmAddress;
        balance: EvmNative;
    }[];
}[], {
    chain: string;
    chain_id: string;
    total_balance: string;
    block_number: string;
    block_timestamp: string;
    total_balance_formatted: string;
    wallet_balances: {
        address: string;
        balance: string;
        balance_formatted: string;
    }[];
}[]> | _moralisweb3_common_core.Operation<GetNFTContractMetadataRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    address: string;
}, EvmNftMetadata, {
    token_address: string;
    name: string;
    synced_at?: string | undefined;
    symbol: string;
    contract_type: string;
}> | _moralisweb3_common_core.PaginatedOperation<GetNFTContractTransfersRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    format: "decimal" | "hex" | undefined;
    limit: number | undefined;
    cursor: string | undefined;
    address: string;
    fromBlock: number | undefined;
    toBlock: number | undefined;
    fromDate: string | undefined;
    toDate: string | undefined;
    disableTotal: boolean | undefined;
}, EvmNftTransfer[], {
    token_address: string;
    token_id: string;
    from_address?: string | undefined;
    to_address: string;
    value?: string | undefined;
    amount?: string | undefined;
    contract_type: string;
    block_number: string;
    block_timestamp: string;
    block_hash: string;
    transaction_hash: string;
    transaction_type?: string | undefined;
    transaction_index?: number | undefined;
    log_index: number;
    operator?: string | undefined;
    possible_spam: boolean;
}[]> | _moralisweb3_common_core.Operation<GetNFTLowestPriceRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    days: number | undefined;
    marketplace: "opensea" | undefined;
    address: string;
}, EvmTrade, {
    transaction_hash: string;
    transaction_index: string;
    token_ids: string[];
    seller_address: string;
    buyer_address: string;
    token_address: string;
    marketplace_address: string;
    price_token_address?: string | undefined;
    price: string;
    block_timestamp: string;
    block_number: string;
    block_hash: string;
}> | _moralisweb3_common_core.Operation<GetNFTMetadataRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    format: "decimal" | "hex" | undefined;
    address: string;
    tokenId: string;
    normalizeMetadata: boolean | undefined;
    mediaItems: boolean | undefined;
}, EvmNft, {
    token_address: string;
    token_id: string;
    owner_of?: string | undefined;
    token_hash?: string | undefined;
    block_number?: string | undefined;
    block_number_minted?: string | undefined;
    contract_type: string;
    token_uri?: string | undefined;
    metadata?: string | undefined;
    normalized_metadata?: {
        name?: string | undefined;
        description?: string | undefined;
        image?: string | undefined;
        external_link?: string | undefined;
        animation_url?: string | undefined;
        attributes?: {
            trait_type?: string | undefined;
            value?: {
                [key: string]: unknown;
            } | undefined;
            display_type?: string | undefined;
            max_value?: number | undefined;
            trait_count?: number | undefined;
            order?: number | undefined;
        }[] | undefined;
    } | undefined;
    media?: {
        mimetype?: string | undefined;
        category?: "image" | "video" | "audio" | undefined;
        status?: "success" | "processing" | "unsupported_media" | "invalid_url" | "host_unavailable" | "temporarily_unavailable" | undefined;
        original_media_url?: string | undefined;
        updatedAt?: string | undefined;
        parent_hash?: string | undefined;
        media_collection?: ({
            low: {
                width: number;
                height: number;
                url: string;
            };
            medium: {
                width: number;
                height: number;
                url: string;
            };
            high: {
                width: number;
                height: number;
                url: string;
            };
        } & {
            original: unknown;
        }) | undefined;
    } | undefined;
    minter_address?: string | undefined;
    last_token_uri_sync?: string | undefined;
    last_metadata_sync?: string | undefined;
    amount?: string | undefined;
    name: string;
    symbol: string;
    possible_spam: boolean;
}> | _moralisweb3_common_core.PaginatedOperation<GetNFTOwnersRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    format: "decimal" | "hex" | undefined;
    limit: number | undefined;
    cursor: string | undefined;
    address: string;
    normalizeMetadata: boolean | undefined;
    disableTotal: boolean | undefined;
    mediaItems: boolean | undefined;
}, EvmNft[], {
    token_address: string;
    token_id: string;
    contract_type: string;
    owner_of: string;
    block_number: string;
    block_number_minted: string;
    token_uri?: string | undefined;
    metadata?: string | undefined;
    normalized_metadata?: {
        name?: string | undefined;
        description?: string | undefined;
        image?: string | undefined;
        external_link?: string | undefined;
        animation_url?: string | undefined;
        attributes?: {
            trait_type?: string | undefined;
            value?: {
                [key: string]: unknown;
            } | undefined;
            display_type?: string | undefined;
            max_value?: number | undefined;
            trait_count?: number | undefined;
            order?: number | undefined;
        }[] | undefined;
    } | undefined;
    media?: {
        mimetype?: string | undefined;
        category?: "image" | "video" | "audio" | undefined;
        status?: "success" | "processing" | "unsupported_media" | "invalid_url" | "host_unavailable" | "temporarily_unavailable" | undefined;
        original_media_url?: string | undefined;
        updatedAt?: string | undefined;
        parent_hash?: string | undefined;
        media_collection?: ({
            low: {
                width: number;
                height: number;
                url: string;
            };
            medium: {
                width: number;
                height: number;
                url: string;
            };
            high: {
                width: number;
                height: number;
                url: string;
            };
        } & {
            original: unknown;
        }) | undefined;
    } | undefined;
    amount?: string | undefined;
    name: string;
    symbol: string;
    token_hash: string;
    last_token_uri_sync: string;
    last_metadata_sync: string;
    possible_spam: boolean;
}[] | undefined> | _moralisweb3_common_core.PaginatedOperation<GetNFTTokenIdOwnersRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    format: "decimal" | "hex" | undefined;
    limit: number | undefined;
    cursor: string | undefined;
    address: string;
    tokenId: string;
    normalizeMetadata: boolean | undefined;
    disableTotal: boolean | undefined;
    mediaItems: boolean | undefined;
}, EvmNft[], {
    token_address: string;
    token_id: string;
    contract_type: string;
    owner_of: string;
    block_number: string;
    block_number_minted: string;
    token_uri?: string | undefined;
    metadata?: string | undefined;
    normalized_metadata?: {
        name?: string | undefined;
        description?: string | undefined;
        image?: string | undefined;
        external_link?: string | undefined;
        animation_url?: string | undefined;
        attributes?: {
            trait_type?: string | undefined;
            value?: {
                [key: string]: unknown;
            } | undefined;
            display_type?: string | undefined;
            max_value?: number | undefined;
            trait_count?: number | undefined;
            order?: number | undefined;
        }[] | undefined;
    } | undefined;
    media?: {
        mimetype?: string | undefined;
        category?: "image" | "video" | "audio" | undefined;
        status?: "success" | "processing" | "unsupported_media" | "invalid_url" | "host_unavailable" | "temporarily_unavailable" | undefined;
        original_media_url?: string | undefined;
        updatedAt?: string | undefined;
        parent_hash?: string | undefined;
        media_collection?: ({
            low: {
                width: number;
                height: number;
                url: string;
            };
            medium: {
                width: number;
                height: number;
                url: string;
            };
            high: {
                width: number;
                height: number;
                url: string;
            };
        } & {
            original: unknown;
        }) | undefined;
    } | undefined;
    amount?: string | undefined;
    name: string;
    symbol: string;
    token_hash: string;
    last_token_uri_sync: string;
    last_metadata_sync: string;
    possible_spam: boolean;
}[] | undefined> | _moralisweb3_common_core.PaginatedOperation<GetNFTTransfersByBlockRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    limit: number | undefined;
    cursor: string | undefined;
    blockNumberOrHash: string;
    disableTotal: boolean | undefined;
}, EvmNftTransfer[], {
    token_address: string;
    token_id: string;
    from_address?: string | undefined;
    to_address: string;
    value?: string | undefined;
    amount?: string | undefined;
    contract_type: string;
    block_number: string;
    block_timestamp: string;
    block_hash: string;
    transaction_hash: string;
    transaction_type?: string | undefined;
    transaction_index?: number | undefined;
    log_index: number;
    operator?: string | undefined;
    possible_spam: boolean;
}[]> | _moralisweb3_common_core.PaginatedOperation<GetNFTTransfersFromToBlockRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    fromBlock: number | undefined;
    toBlock: number | undefined;
    fromDate: _moralisweb3_common_core.DateInput | undefined;
    toDate: _moralisweb3_common_core.DateInput | undefined;
    format: "decimal" | "hex" | undefined;
    limit: number | undefined;
    cursor: string | undefined;
    disableTotal: boolean | undefined;
}, EvmNftTransfer[], {
    token_address: string;
    token_id: string;
    from_address?: string | undefined;
    to_address: string;
    value?: string | undefined;
    amount?: string | undefined;
    contract_type: string;
    block_number: string;
    block_timestamp: string;
    block_hash: string;
    transaction_hash: string;
    transaction_type?: string | undefined;
    transaction_index?: number | undefined;
    log_index: number;
    operator?: string | undefined;
    possible_spam: boolean;
}[]> | _moralisweb3_common_core.PaginatedOperation<GetNFTTransfersRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    format: "decimal" | "hex" | undefined;
    limit: number | undefined;
    cursor: string | undefined;
    address: string;
    tokenId: string;
    disableTotal: boolean | undefined;
}, EvmNftTransfer[], {
    token_address: string;
    token_id: string;
    from_address?: string | undefined;
    to_address: string;
    value?: string | undefined;
    amount?: string | undefined;
    contract_type: string;
    block_number: string;
    block_timestamp: string;
    block_hash: string;
    transaction_hash: string;
    transaction_type?: string | undefined;
    transaction_index?: number | undefined;
    log_index: number;
    operator?: string | undefined;
    possible_spam: boolean;
}[]> | _moralisweb3_common_core.Operation<GetPairAddressRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    toBlock: string | undefined;
    toDate: string | undefined;
    exchange: _moralisweb3_common_core.Camelize<"uniswapv2" | "uniswapv3" | "sushiswapv2" | "pancakeswapv2" | "pancakeswapv1" | "quickswap">;
    token0Address: string;
    token1Address: string;
}, {
    token0: {
        token: Erc20Token;
        blockNumber: string | undefined;
        validated: number | undefined;
        createdAt: Date | undefined;
    };
    token1: {
        token: Erc20Token;
        blockNumber: string | undefined;
        validated: number | undefined;
        createdAt: Date | undefined;
    };
    pairAddress: EvmAddress | undefined;
}, {
    token0?: {
        address?: string | undefined;
        name?: string | undefined;
        symbol?: string | undefined;
        decimals?: string | undefined;
        logo?: string | undefined;
        logo_hash?: string | undefined;
        thumbnail?: string | undefined;
        block_number?: string | undefined;
        validated?: number | undefined;
        created_at?: string | undefined;
    } | undefined;
    token1?: {
        address?: string | undefined;
        name?: string | undefined;
        symbol?: string | undefined;
        decimals?: string | undefined;
        logo?: string | undefined;
        logo_hash?: string | undefined;
        thumbnail?: string | undefined;
        block_number?: string | undefined;
        validated?: number | undefined;
        created_at?: string | undefined;
    } | undefined;
    pairAddress?: string | undefined;
}> | _moralisweb3_common_core.Operation<GetPairReservesRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    toBlock: string | undefined;
    toDate: string | undefined;
    pairAddress: string;
}, {
    reserve0?: string | undefined;
    reserve1?: string | undefined;
}, {
    reserve0?: string | undefined;
    reserve1?: string | undefined;
}> | _moralisweb3_common_core.Operation<GetTokenAllowanceRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    ownerAddress: string;
    spenderAddress: string;
    address: string;
}, {
    allowance: _moralisweb3_common_core.BigNumber;
}, {
    allowance: string;
}> | _moralisweb3_common_core.Operation<GetTokenMetadataBySymbolRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    symbols: string[];
}, {
    token: Erc20Token;
    blockNumber: string | undefined;
    validated: string | undefined;
}[], {
    address: string;
    name: string;
    symbol: string;
    decimals: string;
    logo?: string | undefined;
    logo_hash?: string | undefined;
    thumbnail?: string | undefined;
    block_number?: string | undefined;
    validated?: string | undefined;
    possible_spam: boolean;
}[]> | _moralisweb3_common_core.Operation<GetTokenMetadataRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    addresses: string[];
}, {
    token: Erc20Token;
    blockNumber: string | undefined;
    validated: string | undefined;
}[], {
    address: string;
    name: string;
    symbol: string;
    decimals: string;
    logo?: string | undefined;
    logo_hash?: string | undefined;
    thumbnail?: string | undefined;
    block_number?: string | undefined;
    validated?: string | undefined;
    possible_spam: boolean;
}[]> | _moralisweb3_common_core.Operation<GetTokenPriceRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    exchange: string | undefined;
    toBlock: number | undefined;
    address: string;
}, {
    nativePrice: EvmNative | null;
    exchangeAddress: EvmAddress | null;
    tokenName?: string | undefined;
    tokenSymbol?: string | undefined;
    tokenLogo?: string | undefined;
    tokenDecimals?: string | undefined;
    usdPrice: number;
    exchangeName?: string | undefined;
    tokenAddress?: string | undefined;
}, {
    tokenName?: string | undefined;
    tokenSymbol?: string | undefined;
    tokenLogo?: string | undefined;
    tokenDecimals?: string | undefined;
    nativePrice?: {
        value: string;
        decimals: number;
        name: string;
        symbol: string;
        address: string;
    } | undefined;
    usdPrice: number;
    exchangeAddress?: string | undefined;
    exchangeName?: string | undefined;
    tokenAddress?: string | undefined;
}> | _moralisweb3_common_core.PaginatedOperation<GetTokenTransfersRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    fromBlock: number | undefined;
    toBlock: number | undefined;
    fromDate: _moralisweb3_common_core.DateInput | undefined;
    toDate: _moralisweb3_common_core.DateInput | undefined;
    limit: number | undefined;
    address: string;
    cursor: string | undefined;
    disableTotal: boolean | undefined;
}, Erc20Transaction[], ({
    token_name: string;
    token_symbol: string;
    token_logo?: string | undefined;
    token_decimals: string;
    transaction_hash: string;
    address: string;
    block_timestamp: string;
    block_number: string;
    block_hash: string;
    to_address: string;
    from_address: string;
    value: string;
    transaction_index: number;
    log_index: number;
    possible_spam: boolean;
} & {
    value_decimal: unknown;
})[] | undefined> | _moralisweb3_common_core.Operation<GetTransactionRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    transactionHash: string;
    include: "internal_transactions" | undefined;
}, EvmTransaction, {
    hash: string;
    nonce: string;
    transaction_index: string;
    from_address: string;
    to_address: unknown;
    value: string;
    gas?: string | undefined;
    gas_price: string;
    input: string;
    receipt_cumulative_gas_used: string;
    receipt_gas_used: string;
    receipt_contract_address?: unknown;
    receipt_root?: unknown;
    receipt_status: string;
    block_timestamp: string;
    block_number: string;
    block_hash: string;
    logs?: {
        log_index: string;
        transaction_hash: string;
        transaction_index: string;
        address: string;
        data: string;
        topic0: string;
        topic1?: unknown;
        topic2?: unknown;
        topic3?: unknown;
        block_timestamp: string;
        block_number: string;
        block_hash: string;
    }[] | undefined;
    internal_transactions?: {
        transaction_hash: string;
        block_number: string;
        block_hash: string;
        type: string;
        from: string;
        to: string;
        value: string;
        gas: string;
        gas_used: string;
        input: string;
        output: string;
    }[] | undefined;
}> | _moralisweb3_common_core.Operation<GetTransactionVerboseRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    transactionHash: string;
    include: "internal_transactions" | undefined;
}, EvmTransactionVerbose, {
    hash: string;
    nonce: string;
    transaction_index: string;
    from_address: string;
    to_address: string;
    value: string;
    gas?: string | undefined;
    gas_price: string;
    input: string;
    receipt_cumulative_gas_used: string;
    receipt_gas_used: string;
    receipt_contract_address?: string | undefined;
    receipt_root?: string | undefined;
    receipt_status: string;
    block_timestamp: string;
    block_number: string;
    block_hash: string;
    logs: {
        log_index: string;
        transaction_hash: string;
        transaction_index: string;
        address: string;
        data: string;
        topic0: string;
        topic1?: string | undefined;
        topic2?: string | undefined;
        topic3?: string | undefined;
        block_timestamp: string;
        block_number: string;
        block_hash: string;
        decoded_event: {
            signature?: string | undefined;
            label?: string | undefined;
            type?: string | undefined;
            params?: {
                name?: string | undefined;
                value?: string | undefined;
                type?: string | undefined;
            }[] | undefined;
        };
    }[];
    decoded_call: {
        signature?: string | undefined;
        label?: string | undefined;
        type?: string | undefined;
        params?: {
            name?: string | undefined;
            value?: string | undefined;
            type?: string | undefined;
        }[] | undefined;
    };
}> | _moralisweb3_common_core.PaginatedOperation<GetWalletNFTCollectionsRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    limit: number | undefined;
    cursor: string | undefined;
    address: string;
    disableTotal: boolean | undefined;
}, EvmNftCollection[], {
    token_address: string;
    contract_type: string;
    name: string;
    symbol: string;
}[] | undefined> | _moralisweb3_common_core.PaginatedOperation<GetWalletNFTsRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    format: "decimal" | "hex" | undefined;
    limit: number | undefined;
    tokenAddresses: string[] | undefined;
    cursor: string | undefined;
    address: string;
    normalizeMetadata: boolean | undefined;
    disableTotal: boolean | undefined;
    mediaItems: boolean | undefined;
}, EvmNft[], {
    token_address: string;
    token_id: string;
    contract_type: string;
    owner_of: string;
    block_number: string;
    block_number_minted: string;
    token_uri?: string | undefined;
    metadata?: string | undefined;
    normalized_metadata?: {
        name?: string | undefined;
        description?: string | undefined;
        image?: string | undefined;
        external_link?: string | undefined;
        animation_url?: string | undefined;
        attributes?: {
            trait_type?: string | undefined;
            value?: {
                [key: string]: unknown;
            } | undefined;
            display_type?: string | undefined;
            max_value?: number | undefined;
            trait_count?: number | undefined;
            order?: number | undefined;
        }[] | undefined;
    } | undefined;
    media?: {
        mimetype?: string | undefined;
        category?: "image" | "video" | "audio" | undefined;
        status?: "success" | "processing" | "unsupported_media" | "invalid_url" | "host_unavailable" | "temporarily_unavailable" | undefined;
        original_media_url?: string | undefined;
        updatedAt?: string | undefined;
        parent_hash?: string | undefined;
        media_collection?: ({
            low: {
                width: number;
                height: number;
                url: string;
            };
            medium: {
                width: number;
                height: number;
                url: string;
            };
            high: {
                width: number;
                height: number;
                url: string;
            };
        } & {
            original: unknown;
        }) | undefined;
    } | undefined;
    amount?: string | undefined;
    name: string;
    symbol: string;
    token_hash: string;
    last_token_uri_sync: string;
    last_metadata_sync: string;
    possible_spam: boolean;
}[] | undefined> | _moralisweb3_common_core.PaginatedOperation<GetWalletNFTTransfersRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    format: "decimal" | "hex" | undefined;
    direction: "from" | "to" | "both" | undefined;
    fromBlock: number | undefined;
    toBlock: string | undefined;
    limit: number | undefined;
    cursor: string | undefined;
    address: string;
    disableTotal: boolean | undefined;
    fromDate: string | undefined;
    toDate: string | undefined;
}, EvmNftTransfer[], {
    token_address: string;
    token_id: string;
    from_address?: string | undefined;
    to_address: string;
    value?: string | undefined;
    amount?: string | undefined;
    contract_type: string;
    block_number: string;
    block_timestamp: string;
    block_hash: string;
    transaction_hash: string;
    transaction_type?: string | undefined;
    transaction_index?: number | undefined;
    log_index: number;
    operator?: string | undefined;
    possible_spam: boolean;
}[]> | _moralisweb3_common_core.Operation<GetWalletTokenBalancesRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    tokenAddresses: string[] | undefined;
    address: string;
    toBlock: number | undefined;
}, Erc20Value[], {
    token_address: string;
    name: string;
    symbol: string;
    logo?: string | undefined;
    thumbnail?: string | undefined;
    decimals: number;
    balance: string;
    possible_spam: boolean;
}[]> | _moralisweb3_common_core.PaginatedOperation<GetWalletTransactionsRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    fromBlock: number | undefined;
    toBlock: number | undefined;
    fromDate: _moralisweb3_common_core.DateInput | undefined;
    toDate: _moralisweb3_common_core.DateInput | undefined;
    cursor: string | undefined;
    limit: number | undefined;
    address: string;
    disableTotal: boolean | undefined;
    include: "internal_transactions" | undefined;
}, EvmTransaction[], {
    hash: string;
    nonce: string;
    transaction_index: string;
    from_address: string;
    to_address: string;
    value: string;
    gas: string;
    gas_price: string;
    input: string;
    receipt_cumulative_gas_used: string;
    receipt_gas_used: string;
    receipt_contract_address: string;
    receipt_root: string;
    receipt_status: string;
    block_timestamp: string;
    block_number: string;
    block_hash: string;
    internal_transactions?: {
        transaction_hash: string;
        block_number: string;
        block_hash: string;
        type: string;
        from: string;
        to: string;
        value: string;
        gas: string;
        gas_used: string;
        input: string;
        output: string;
    }[] | undefined;
}[] | undefined> | _moralisweb3_common_core.PaginatedOperation<GetWalletTransactionsVerboseRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    fromBlock: number | undefined;
    toBlock: number | undefined;
    fromDate: _moralisweb3_common_core.DateInput | undefined;
    toDate: _moralisweb3_common_core.DateInput | undefined;
    cursor: string | undefined;
    limit: number | undefined;
    address: string;
    disableTotal: boolean | undefined;
    include: "internal_transactions" | undefined;
}, EvmTransaction[], {
    hash: string;
    nonce: string;
    transaction_index: string;
    from_address: string;
    to_address: string;
    value: string;
    gas?: string | undefined;
    gas_price: string;
    input: string;
    receipt_cumulative_gas_used: string;
    receipt_gas_used: string;
    receipt_contract_address?: string | undefined;
    receipt_root?: string | undefined;
    receipt_status: string;
    block_timestamp: string;
    block_number: string;
    block_hash: string;
    logs: {
        log_index: string;
        transaction_hash: string;
        transaction_index: string;
        address: string;
        data: string;
        topic0: string;
        topic1?: string | undefined;
        topic2?: string | undefined;
        topic3?: string | undefined;
        block_timestamp: string;
        block_number: string;
        block_hash: string;
        decoded_event: {
            signature?: string | undefined;
            label?: string | undefined;
            type?: string | undefined;
            params?: {
                name?: string | undefined;
                value?: string | undefined;
                type?: string | undefined;
            }[] | undefined;
        };
    }[];
    decoded_call: {
        signature?: string | undefined;
        label?: string | undefined;
        type?: string | undefined;
        params?: {
            name?: string | undefined;
            value?: string | undefined;
            type?: string | undefined;
        }[] | undefined;
    };
}[] | undefined> | _moralisweb3_common_core.Operation<ResolveAddressRequest, {
    address: string | undefined;
}, {
    name: string;
}, {
    name: string;
}> | _moralisweb3_common_core.Operation<ResolveDomainRequest, {
    currency: "0x1" | "eth" | undefined;
    domain: string;
}, {
    address: EvmAddress;
}, {
    address: string;
}> | _moralisweb3_common_core.Operation<ResolveENSDomainRequest, {
    domain: string;
}, {
    address: EvmAddress;
}, {
    address: string;
}> | _moralisweb3_common_core.Operation<ReSyncMetadataRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    flag: "metadata" | "uri" | undefined;
    mode: "async" | "sync" | undefined;
    address: string;
    tokenId: string;
}, {
    status: string;
}, {
    status: string;
}> | _moralisweb3_common_core.Operation<RunContractFunctionRequest, {
    address: string;
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    functionName: string;
    abi: unknown;
    params: {
        [key: string]: unknown;
    } | undefined;
}, string, string> | _moralisweb3_common_core.PaginatedOperation<SearchNFTsRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    format: "decimal" | "hex" | undefined;
    q: string;
    filter: "name" | "description" | "attributes" | "global" | "name,description" | "name,attributes" | "description,attributes" | "name,description,attributes" | undefined;
    fromBlock: number | undefined;
    toBlock: number | undefined;
    fromDate: _moralisweb3_common_core.DateInput | undefined;
    toDate: _moralisweb3_common_core.DateInput | undefined;
    addresses: string[] | undefined;
    cursor: string | undefined;
    limit: number | undefined;
    disableTotal: boolean | undefined;
}, {
    token: EvmNft;
    tokenHash: string;
    blockNumberMinted: string;
    lastMetadataSync: Date | undefined;
    lastTokenUriSync: Date | undefined;
    batchId: string;
    frozen: number;
    frozenLogIndex: {
        [key: string]: unknown;
    } | undefined;
    imported: {
        [key: string]: unknown;
    } | undefined;
    isValid: number;
    openseaLookup: {
        [key: string]: unknown;
    } | undefined;
    resyncing: number;
    syncing: number;
    updatedAt: Date;
}[], {
    token_id: string;
    token_address: string;
    token_uri: string;
    metadata: string;
    is_valid: number;
    syncing: number;
    frozen: number;
    resyncing: number;
    contract_type: string;
    token_hash: string;
    batch_id: string;
    metadata_name: string;
    metadata_description: string;
    metadata_attributes: string;
    block_number_minted: string;
    opensea_lookup?: {
        [key: string]: unknown;
    } | undefined;
    minter_address: string;
    transaction_minted: string;
    frozen_log_index?: {
        [key: string]: unknown;
    } | undefined;
    imported?: {
        [key: string]: unknown;
    } | undefined;
    last_token_uri_sync: string;
    last_metadata_sync: string;
    createdAt: string;
    updatedAt: string;
    possible_spam: boolean;
}[] | undefined> | _moralisweb3_common_core.Operation<SyncNFTContractRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    address: string;
}, {
    success: boolean;
}, unknown> | _moralisweb3_common_core.Operation<UploadFolderRequest, {
    abi: string;
}, {
    path: string;
}[], {
    path: string;
}[]> | _moralisweb3_common_core.Operation<EndpointWeightsRequest, undefined, {
    endpoint: string;
    path: string;
    rateLimitCost: string;
    price: string;
}[], {
    endpoint: string;
    path: string;
    rateLimitCost: string;
    price: string;
}[]> | _moralisweb3_common_core.Operation<Web3ApiVersionRequest, undefined, {
    version: string;
}, {
    version: string;
}> | _moralisweb3_common_core.PaginatedOperation<GetNFTTradesRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    fromBlock: number | undefined;
    toBlock: string | undefined;
    fromDate: _moralisweb3_common_core.DateInput | undefined;
    toDate: _moralisweb3_common_core.DateInput | undefined;
    marketplace: "opensea" | undefined;
    cursor: string | undefined;
    limit: number | undefined;
    address: string;
    disableTotal: boolean | undefined;
}, EvmTrade[], {
    transaction_hash: string;
    transaction_index: string;
    token_ids: string[];
    seller_address: string;
    buyer_address: string;
    token_address: string;
    marketplace_address: string;
    price_token_address?: string | undefined;
    price: string;
    block_timestamp: string;
    block_number: string;
    block_hash: string;
}[] | undefined> | _moralisweb3_common_core.PaginatedOperation<GetErc20TransfersRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0xfa2" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4b1" | "0x7e4" | "0x66eed" | "0xa";
    limit: number | undefined;
    cursor: string | undefined;
    fromBlock: number | undefined;
    toBlock: number | undefined;
    contractAddresses: string[] | undefined;
    excludeContracts: string[] | undefined;
    walletAddresses: string[] | undefined;
    excludeWallets: string[] | undefined;
}, EvmErc20Transfer[], {
    token_name: string;
    token_symbol: string;
    token_logo?: string | undefined;
    token_decimals: string;
    contract_address: string;
    transaction_hash: string;
    transaction_index: string;
    log_index: string;
    block_timestamp: string;
    block_number: string;
    block_hash: string;
    from_wallet: string;
    to_wallet: string;
    value: string;
    value_decimal: string;
    possible_spam: boolean;
}[] | undefined>)[];

declare const CommonEvmUtilsConfig: {
    defaultEvmApiChain: ConfigKey<EvmChainish>;
};

declare class CommonEvmUtilsConfigSetup {
    static register(config: Config): void;
}

export { CommonEvmUtils, CommonEvmUtilsConfig, CommonEvmUtilsConfigSetup, EndpointWeightsJSONRequest, EndpointWeightsJSONResponse, EndpointWeightsOperation, EndpointWeightsOperationRequest, EndpointWeightsOperationRequestJSON, EndpointWeightsOperationResponse, EndpointWeightsOperationResponseJSON, EndpointWeightsRequest, EndpointWeightsResponse, EndpointWeightsResponseAdapter, Erc20Approval, Erc20ApprovalData, Erc20ApprovalInput, Erc20Burn, Erc20BurnData, Erc20BurnInput, Erc20Data, Erc20Input, Erc20Mint, Erc20MintData, Erc20MintInput, Erc20Options, Erc20Token, Erc20Tokenish, Erc20Transaction, Erc20TransactionData, Erc20TransactionInput, Erc20Transactionish, Erc20Transfer, Erc20TransferInput, Erc20Transferish, Erc20Value, Erc20ValueData, Erc20ValueInputAmount, Erc20ValueInputDecimals, Erc20Valueish, EvmAbiItem, EvmAbiItemVariable, EvmAddress, EvmAddressInput, EvmAddressJSON, EvmAddressish, EvmBlock, EvmBlockData, EvmBlockDate, EvmBlockDateData, EvmBlockDateInput, EvmBlockDateish, EvmBlockInput, EvmBlockish, EvmChain, EvmChainFeature, EvmChainInput, EvmChainJSON, EvmChainList, EvmChainListDataEntry, EvmChainListInput, EvmChainListJSON, EvmChainListValue, EvmChainParser, EvmChainResolver, EvmChainish, EvmContractsReviewDto, EvmContractsReviewDtoInput, EvmContractsReviewDtoJSON, EvmContractsReviewItem, EvmContractsReviewItemContractTypeEnum, EvmContractsReviewItemContractTypeEnumInput, EvmContractsReviewItemContractTypeEnumJSON, EvmContractsReviewItemContractTypeEnumValue, EvmContractsReviewItemInput, EvmContractsReviewItemJSON, EvmContractsReviewItemReportTypeEnum, EvmContractsReviewItemReportTypeEnumInput, EvmContractsReviewItemReportTypeEnumJSON, EvmContractsReviewItemReportTypeEnumValue, EvmEndpointWeights, EvmEndpointWeightsInput, EvmEndpointWeightsJSON, EvmErc20Transfer, EvmErc20TransferInput, EvmErc20TransferJSON, EvmErc20TransfersResponse, EvmErc20TransfersResponseInput, EvmErc20TransfersResponseJSON, EvmEvent, EvmEventData, EvmEventInput, EvmEventish, EvmGetNFTTradesMarketplaceEnum, EvmGetNFTTradesMarketplaceEnumInput, EvmGetNFTTradesMarketplaceEnumJSON, EvmGetNFTTradesMarketplaceEnumValue, EvmInternalTransaction, EvmInternalTransactionData, EvmInternalTransactionInput, EvmInternalTransactionish, EvmMarketDataERC20TokenItem, EvmMarketDataERC20TokenItemInput, EvmMarketDataERC20TokenItemJSON, EvmMarketDataERC20TokensByPriceMovers, EvmMarketDataERC20TokensByPriceMoversInput, EvmMarketDataERC20TokensByPriceMoversJSON, EvmMarketDataHottestNFTCollectionByTradingVolumeItem, EvmMarketDataHottestNFTCollectionByTradingVolumeItemInput, EvmMarketDataHottestNFTCollectionByTradingVolumeItemJSON, EvmMarketDataTopNFTCollectionByMarketCapItem, EvmMarketDataTopNFTCollectionByMarketCapItemInput, EvmMarketDataTopNFTCollectionByMarketCapItemJSON, EvmNative, EvmNativeCurrency, EvmNativeInput, EvmNativeJSON, EvmNativeUnit, EvmNativeish, EvmNft, EvmNftCollection, EvmNftCollectionData, EvmNftCollectionInput, EvmNftCollectionish, EvmNftData, EvmNftInput, EvmNftMedia, EvmNftMediaCategory, EvmNftMediaData, EvmNftMediaInput, EvmNftMediaItem, EvmNftMediaStatus, EvmNftMetadata, EvmNftMetadataData, EvmNftMetadataInput, EvmNftMetadataish, EvmNftTrade, EvmNftTradeish, EvmNftTransfer, EvmNftTransferData, EvmNftTransferInput, EvmNftTransferish, EvmNftish, EvmReviewContracts, EvmReviewContractsInput, EvmReviewContractsJSON, EvmSignature, EvmSignatureInput, EvmSignatureInputRSV, EvmSignatureish, EvmSimpleBlock, EvmSimpleBlockData, EvmSimpleBlockInput, EvmSimpleBlockish, EvmTrade, EvmTradeCollection, EvmTradeCollectionInput, EvmTradeCollectionJSON, EvmTradeInput, EvmTradeJSON, EvmTransaction, EvmTransactionData, EvmTransactionInput, EvmTransactionLog, EvmTransactionLogData, EvmTransactionLogDecoded, EvmTransactionLogDecodedData, EvmTransactionLogDecodedEvent, EvmTransactionLogDecodedEventParam, EvmTransactionLogDecodedInput, EvmTransactionLogDecodedish, EvmTransactionLogInput, EvmTransactionLogish, EvmTransactionVerbose, EvmTransactionVerboseData, EvmTransactionVerboseInput, EvmTransactionVerboseish, EvmTransactionish, EvmWeb3version, EvmWeb3versionInput, EvmWeb3versionJSON, GetBlockJSONRequest, GetBlockJSONResponse, GetBlockRequest, GetBlockResponse, GetBlockResponseAdapter, GetContractEventsJSONRequest, GetContractEventsJSONResponse, GetContractEventsRequest, GetContractEventsResponse, GetContractEventsResponseAdapter, GetContractLogsJSONRequest, GetContractLogsJSONResponse, GetContractLogsRequest, GetContractLogsResponse, GetContractLogsResponseAdapter, GetContractNFTsJSONRequest, GetContractNFTsJSONResponse, GetContractNFTsRequest, GetContractNFTsResponse, GetContractNFTsResponseAdapter, GetDateToBlockJSONRequest, GetDateToBlockJSONResponse, GetDateToBlockRequest, GetDateToBlockResponse, GetDateToBlockResponseAdapter, GetErc20ApprovalsJSONRequest, GetErc20ApprovalsJSONResponse, GetErc20ApprovalsRequest, GetErc20ApprovalsResponse, GetErc20ApprovalsResponseAdapter, GetErc20BurnsJSONRequest, GetErc20BurnsJSONResponse, GetErc20BurnsRequest, GetErc20BurnsResponse, GetErc20BurnsResponseAdapter, GetErc20MintsJSONRequest, GetErc20MintsJSONResponse, GetErc20MintsRequest, GetErc20MintsResponse, GetErc20MintsResponseAdapter, GetErc20TransfersJSONRequest, GetErc20TransfersJSONResponse, GetErc20TransfersOperation, GetErc20TransfersOperationRequest, GetErc20TransfersOperationRequestJSON, GetErc20TransfersOperationResponse, GetErc20TransfersOperationResponseJSON, GetErc20TransfersRequest, GetErc20TransfersResponse, GetErc20TransfersResponseAdapter, GetHottestNFTCollectionsByTradingVolumeOperation, GetHottestNFTCollectionsByTradingVolumeOperationRequest, GetHottestNFTCollectionsByTradingVolumeOperationRequestJSON, GetHottestNFTCollectionsByTradingVolumeOperationResponse, GetHottestNFTCollectionsByTradingVolumeOperationResponseJSON, GetInternalTransactionsJSONRequest, GetInternalTransactionsJSONResponse, GetInternalTransactionsRequest, GetInternalTransactionsResponse, GetInternalTransactionsResponseAdapter, GetMultipleNFTsJSONRequest, GetMultipleNFTsJSONResponse, GetMultipleNFTsRequest, GetMultipleNFTsResponse, GetMultipleNFTsResponseAdapter, GetNFTContractMetadataJSONRequest, GetNFTContractMetadataJSONResponse, GetNFTContractMetadataRequest, GetNFTContractMetadataResponse, GetNFTContractMetadataResponseAdapter, GetNFTContractTransfersJSONRequest, GetNFTContractTransfersJSONResponse, GetNFTContractTransfersRequest, GetNFTContractTransfersResponse, GetNFTContractTransfersResponseAdapter, GetNFTLowestPriceJSONRequest, GetNFTLowestPriceJSONResponse, GetNFTLowestPriceRequest, GetNFTLowestPriceResponse, GetNFTLowestPriceResponseAdapter, GetNFTMetadataJSONRequest, GetNFTMetadataJSONResponse, GetNFTMetadataRequest, GetNFTMetadataResponse, GetNFTMetadataResponseAdapter, GetNFTOwnersJSONRequest, GetNFTOwnersJSONResponse, GetNFTOwnersRequest, GetNFTOwnersResponse, GetNFTOwnersResponseAdapter, GetNFTTokenIdOwnersJSONRequest, GetNFTTokenIdOwnersJSONResponse, GetNFTTokenIdOwnersRequest, GetNFTTokenIdOwnersResponse, GetNFTTokenIdOwnersResponseAdapter, GetNFTTradesJSONRequest, GetNFTTradesJSONResponse, GetNFTTradesOperation, GetNFTTradesOperationRequest, GetNFTTradesOperationRequestJSON, GetNFTTradesOperationResponse, GetNFTTradesOperationResponseJSON, GetNFTTradesRequest, GetNFTTradesResponse, GetNFTTradesResponseAdapter, GetNFTTransfersByBlockJSONRequest, GetNFTTransfersByBlockJSONResponse, GetNFTTransfersByBlockRequest, GetNFTTransfersByBlockResponse, GetNFTTransfersByBlockResponseAdapter, GetNFTTransfersFromToBlockJSONRequest, GetNFTTransfersFromToBlockJSONResponse, GetNFTTransfersFromToBlockRequest, GetNFTTransfersFromToBlockResponse, GetNFTTransfersFromToBlockResponseAdapter, GetNFTTransfersJSONRequest, GetNFTTransfersJSONResponse, GetNFTTransfersRequest, GetNFTTransfersResponse, GetNFTTransfersResponseAdapter, GetNativeBalanceJSONRequest, GetNativeBalanceJSONResponse, GetNativeBalanceRequest, GetNativeBalanceResponse, GetNativeBalanceResponseAdapter, GetNativeBalancesForAddressesJSONRequest, GetNativeBalancesForAddressesJSONResponse, GetNativeBalancesForAddressesRequest, GetNativeBalancesForAddressesResponse, GetNativeBalancesForAddressesResponseAdapter, GetPairAddressJSONRequest, GetPairAddressJSONResponse, GetPairAddressRequest, GetPairAddressResponse, GetPairAddressResponseAdapter, GetPairReservesJSONRequest, GetPairReservesJSONResponse, GetPairReservesRequest, GetPairReservesResponse, GetPairReservesResponseAdapter, GetTokenAllowanceJSONRequest, GetTokenAllowanceJSONResponse, GetTokenAllowanceRequest, GetTokenAllowanceResponse, GetTokenAllowanceResponseAdapter, GetTokenMetadataBySymbolJSONRequest, GetTokenMetadataBySymbolJSONResponse, GetTokenMetadataBySymbolRequest, GetTokenMetadataBySymbolResponse, GetTokenMetadataBySymbolResponseAdapter, GetTokenMetadataJSONRequest, GetTokenMetadataJSONResponse, GetTokenMetadataRequest, GetTokenMetadataResponse, GetTokenMetadataResponseAdapter, GetTokenPriceJSONRequest, GetTokenPriceJSONResponse, GetTokenPriceRequest, GetTokenPriceResponse, GetTokenPriceResponseAdapter, GetTokenTransfersJSONRequest, GetTokenTransfersJSONResponse, GetTokenTransfersRequest, GetTokenTransfersResponse, GetTokenTransfersResponseAdapter, GetTopERC20TokensByMarketCapOperation, GetTopERC20TokensByMarketCapOperationRequest, GetTopERC20TokensByMarketCapOperationRequestJSON, GetTopERC20TokensByMarketCapOperationResponse, GetTopERC20TokensByMarketCapOperationResponseJSON, GetTopERC20TokensByPriceMoversOperation, GetTopERC20TokensByPriceMoversOperationRequest, GetTopERC20TokensByPriceMoversOperationRequestJSON, GetTopERC20TokensByPriceMoversOperationResponse, GetTopERC20TokensByPriceMoversOperationResponseJSON, GetTopNFTCollectionsByMarketCapOperation, GetTopNFTCollectionsByMarketCapOperationRequest, GetTopNFTCollectionsByMarketCapOperationRequestJSON, GetTopNFTCollectionsByMarketCapOperationResponse, GetTopNFTCollectionsByMarketCapOperationResponseJSON, GetTransactionJSONRequest, GetTransactionJSONResponse, GetTransactionRequest, GetTransactionResponse, GetTransactionResponseAdapter, GetTransactionVerboseJSONRequest, GetTransactionVerboseJSONResponse, GetTransactionVerboseRequest, GetTransactionVerboseResponse, GetTransactionVerboseResponseAdapter, GetWalletNFTCollectionsJSONRequest, GetWalletNFTCollectionsJSONResponse, GetWalletNFTCollectionsRequest, GetWalletNFTCollectionsResponse, GetWalletNFTCollectionsResponseAdapter, GetWalletNFTTransfersJSONRequest, GetWalletNFTTransfersJSONResponse, GetWalletNFTTransfersRequest, GetWalletNFTTransfersResponse, GetWalletNFTTransfersResponseAdapter, GetWalletNFTsJSONRequest, GetWalletNFTsJSONResponse, GetWalletNFTsRequest, GetWalletNFTsResponse, GetWalletNFTsResponseAdapter, GetWalletTokenBalancesJSONRequest, GetWalletTokenBalancesJSONResponse, GetWalletTokenBalancesRequest, GetWalletTokenBalancesResponse, GetWalletTokenBalancesResponseAdapter, GetWalletTokenTransfersJSONRequest, GetWalletTokenTransfersJSONResponse, GetWalletTokenTransfersRequest, GetWalletTokenTransfersResponse, GetWalletTokenTransfersResponseAdapter, GetWalletTransactionsJSONRequest, GetWalletTransactionsJSONResponse, GetWalletTransactionsRequest, GetWalletTransactionsResponse, GetWalletTransactionsResponseAdapter, GetWalletTransactionsVerboseJSONRequest, GetWalletTransactionsVerboseJSONResponse, GetWalletTransactionsVerboseRequest, GetWalletTransactionsVerboseResponse, GetWalletTransactionsVerboseResponseAdapter, InputChainId, InputEvmNative, LogTopic, ReSyncMetadataJSONRequest, ReSyncMetadataJSONResponse, ReSyncMetadataRequest, ReSyncMetadataResponse, ReSyncMetadataResponseAdapter, ResolveAddressJSONRequest, ResolveAddressJSONResponse, ResolveAddressRequest, ResolveAddressResponse, ResolveAddressResponseAdapter, ResolveDomainJSONRequest, ResolveDomainJSONResponse, ResolveDomainRequest, ResolveDomainResponse, ResolveDomainResponseAdapter, ResolveENSDomainJSONRequest, ResolveENSDomainJSONResponse, ResolveENSDomainRequest, ResolveENSDomainResponse, ResolveENSDomainResponseAdapter, ReviewContractsOperation, ReviewContractsOperationBody, ReviewContractsOperationRequest, ReviewContractsOperationRequestJSON, ReviewContractsOperationResponse, ReviewContractsOperationResponseJSON, RunContractFunctionJSONRequest, RunContractFunctionJSONResponse, RunContractFunctionRequest, RunContractFunctionResponse, RunContractFunctionResponseAdapter, SearchNFTsJSONRequest, SearchNFTsJSONResponse, SearchNFTsRequest, SearchNFTsResponse, SearchNFTsResponseAdapter, SyncNFTContractJSONRequest, SyncNFTContractJSONResponse, SyncNFTContractRequest, SyncNFTContractResponse, SyncNFTContractResponseAdapter, UploadFolderJSONRequest, UploadFolderJSONResponse, UploadFolderRequest, UploadFolderResponse, UploadFolderResponseAdapter, Web3ApiVersionJSONRequest, Web3ApiVersionJSONResponse, Web3ApiVersionOperation, Web3ApiVersionOperationRequest, Web3ApiVersionOperationRequestJSON, Web3ApiVersionOperationResponse, Web3ApiVersionOperationResponseJSON, Web3ApiVersionRequest, Web3ApiVersionResponse, Web3ApiVersionResponseAdapter, endpointWeightsOperation, getBlockOperation, getContractEventsOperation, getContractLogsOperation, getContractNFTsOperation, getDateToBlockOperation, getErc20ApprovalsOperation, getErc20BurnsOperation, getErc20MintsOperation, getErc20TransfersOperation, getInternalTransactionsOperation, getMultipleNFTsOperation, getNFTContractMetadataOperation, getNFTContractTransfersOperation, getNFTLowestPriceOperation, getNFTMetadataOperation, getNFTOwnersOperation, getNFTTokenIdOwnersOperation, getNFTTradesOperation, getNFTTransfersByBlockOperation, getNFTTransfersFromToBlockOperation, getNFTTransfersOperation, getNativeBalanceOperation, getNativeBalancesForAddressesOperation, getPairAddressOperation, getPairReservesOperation, getTokenAllowanceOperation, getTokenMetadataBySymbolOperation, getTokenMetadataOperation, getTokenPriceOperation, getTokenTransfersOperation, getTransactionOperation, getTransactionVerboseOperation, getWalletNFTCollectionsOperation, getWalletNFTTransfersOperation, getWalletNFTsOperation, getWalletTokenBalancesOperation, getWalletTokenTransfersOperation, getWalletTransactionsOperation, getWalletTransactionsVerboseOperation, operations, operationsV2, operationsV2All, reSyncMetadataOperation, resolveAddressOperation, resolveDomainOperation, resolveENSDomainOperation, runContractFunctionOperation, searchNFTsOperation, syncNFTContractOperation, uploadFolderOperation, web3ApiVersionOperation };
