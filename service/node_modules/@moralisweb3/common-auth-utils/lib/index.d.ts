import { AptosNetwork, AptosAddress, AptosAddressInput, AptosNetworkInput } from '@moralisweb3/common-aptos-utils';
import * as _moralisweb3_common_core from '@moralisweb3/common-core';
import { Camelize, ResponseAdapter, Operation, DateInput, Core } from '@moralisweb3/common-core';
import { EvmChain, EvmAddress, EvmAddressish, EvmChainish } from '@moralisweb3/common-evm-utils';
import { SolNetwork, SolAddress, SolAddressish, SolNetworkish } from '@moralisweb3/common-sol-utils';

interface components {
    schemas: {
        EvmChallengeRequestDto: {
            /**
             * Format: hostname
             * @description RFC 4501 dns authority that is requesting the signing.
             * @example defi.finance
             */
            domain: string;
            /**
             * @description Human-readable ASCII assertion that the user will sign, and it must not contain `
             * `.
             * @example Please confirm
             */
            statement?: string;
            /**
             * Format: uri
             * @description RFC 3986 URI referring to the resource that is the subject of the signing (as in the __subject__ of a claim).
             * @example https://defi.finance/
             */
            uri: string;
            /**
             * Format: date-time
             * @description ISO 8601 datetime string that, if present, indicates when the signed authentication message is no longer valid.
             * @example 2020-01-01T00:00:00.000Z
             */
            expirationTime?: string;
            /**
             * Format: date-time
             * @description ISO 8601 datetime string that, if present, indicates when the signed authentication message will become valid.
             * @example 2020-01-01T00:00:00.000Z
             */
            notBefore?: string;
            /**
             * @description List of information or references to information the user wishes to have resolved as part of authentication by the relying party. They are expressed as RFC 3986 URIs separated by new lines.
             * @example [
             *   "https://docs.moralis.io/"
             * ]
             */
            resources?: string[];
            /**
             * @description Time in seconds before the challenge is expired
             * @default 15
             * @example 15
             */
            timeout: number;
            /**
             * @description EIP-155 Chain ID to which the session is bound, and the network where Contract Accounts must be resolved.
             * @example 1
             * @enum {string}
             */
            chainId: "1" | "5" | "25" | "56" | "97" | "137" | "250" | "338" | "1337" | "43113" | "43114" | "80001" | "11155111";
            /**
             * @description Ethereum address performing the signing conformant to capitalization encoded checksum specified in EIP-55 where applicable.
             * @example 0xAb5801a7D398351b8bE11C439e05C5B3259aeC9B
             */
            address: string;
        };
        EvmChallengeResponseDto: {
            /**
             * @description 17-characters Alphanumeric string Secret Challenge ID used to identify this particular request. Is should be used at the backend of the calling service to identify the completed request.
             * @example fRyt67D3eRss3RrXa
             */
            id: string;
            /**
             * @description Unique identifier with a length of 66 characters
             * @example 0xbfbcfab169c67072ff418133124480fea02175f1402aaa497daa4fd09026b0e1
             */
            profileId: string;
            /**
             * @description Message that needs to be signed by the end user
             * @example defi.finance wants you to sign in with your Ethereum account:
             * 0xAb5801a7D398351b8bE11C439e05C5B3259aeC9B
             *
             * Please confirm
             *
             * URI: https://defi.finance/
             * Version: 1
             * Chain ID: 1
             * Nonce: DbU1DCTmdzR4lg3wi
             * Issued At: 2022-06-12T12:15:31.290Z
             * Expiration Time: 2020-01-01T00:00:00.000Z
             * Not Before: 2020-01-01T00:00:00.000Z
             * Resources:
             * - https://docs.moralis.io/
             */
            message: string;
        };
        EvmCompleteChallengeRequestDto: {
            /**
             * @description Message that needs to be signed by the end user.
             * @example defi.finance wants you to sign in with your Ethereum account:
             * 0xAb5801a7D398351b8bE11C439e05C5B3259aeC9B
             *
             *
             * URI: https://defi.finance
             * Version: 1
             * Chain ID: 1
             * Nonce: Px7Nh1RPzlCLwqgOb
             * Issued At: 2022-11-30T10:20:00.262Z
             */
            message: string;
            /**
             * @description EIP-191 compliant signature signed by the Ethereum account address requesting authentication.
             * @example 0xa8f89a58bf9b433d3100f9e41ee35b5e31fb8c7cd62547acb113162ec6f2e4140207e2dfbd4e387e1801ebc7f08a9dd105ac1d22b2e2ff0df5fa8b6d9bdcfe491c
             */
            signature: string;
        };
        EvmCompleteChallengeResponseDto: {
            /**
             * @description 17-characters Alphanumeric string Secret Challenge ID used to identify this particular request. Is should be used at the backend of the calling service to identify the completed request.
             * @example fRyt67D3eRss3RrX
             */
            id: string;
            /**
             * Format: hostname
             * @description RFC 4501 dns authority that is requesting the signing.
             * @example defi.finance
             */
            domain: string;
            /**
             * @description Human-readable ASCII assertion that the user will sign, and it must not contain `
             * `.
             * @example Please confirm
             */
            statement?: string;
            /**
             * Format: uri
             * @description RFC 3986 URI referring to the resource that is the subject of the signing (as in the __subject__ of a claim).
             * @example https://defi.finance/
             */
            uri: string;
            /**
             * Format: date-time
             * @description ISO 8601 datetime string that, if present, indicates when the signed authentication message is no longer valid.
             * @example 2020-01-01T00:00:00.000Z
             */
            expirationTime?: string;
            /**
             * Format: date-time
             * @description ISO 8601 datetime string that, if present, indicates when the signed authentication message will become valid.
             * @example 2020-01-01T00:00:00.000Z
             */
            notBefore?: string;
            /**
             * @description List of information or references to information the user wishes to have resolved as part of authentication by the relying party. They are expressed as RFC 3986 URIs separated by `
             * - `.
             * @example [
             *   "https://docs.moralis.io/"
             * ]
             */
            resources?: string[];
            /**
             * @description EIP-155 Chain ID to which the session is bound, and the network where Contract Accounts must be resolved.
             * @example 1.0
             */
            version: string;
            /** @example 0x1234567890abcdef0123456789abcdef1234567890abcdef */
            nonce: string;
            /**
             * @description Unique identifier with a length of 66 characters
             * @example 0xbfbcfab169c67072ff418133124480fea02175f1402aaa497daa4fd09026b0e1
             */
            profileId: string;
            /**
             * @description EIP-155 Chain ID to which the session is bound, and the network where Contract Accounts must be resolved.
             * @example 1
             * @enum {string}
             */
            chainId: "1" | "5" | "25" | "56" | "97" | "137" | "250" | "338" | "1337" | "43113" | "43114" | "80001" | "11155111";
            /**
             * @description Ethereum address performing the signing conformant to capitalization encoded checksum specified in EIP-55 where applicable.
             * @example 0xAb5801a7D398351b8bE11C439e05C5B3259aeC9B
             */
            address: string;
        };
        SolanaChallengeRequestDto: {
            /**
             * Format: hostname
             * @description RFC 4501 dns authority that is requesting the signing.
             * @example defi.finance
             */
            domain: string;
            /**
             * @description Human-readable ASCII assertion that the user will sign, and it must not contain `
             * `.
             * @example Please confirm
             */
            statement?: string;
            /**
             * Format: uri
             * @description RFC 3986 URI referring to the resource that is the subject of the signing (as in the __subject__ of a claim).
             * @example https://defi.finance/
             */
            uri: string;
            /**
             * Format: date-time
             * @description ISO 8601 datetime string that, if present, indicates when the signed authentication message is no longer valid.
             * @example 2020-01-01T00:00:00.000Z
             */
            expirationTime?: string;
            /**
             * Format: date-time
             * @description ISO 8601 datetime string that, if present, indicates when the signed authentication message will become valid.
             * @example 2020-01-01T00:00:00.000Z
             */
            notBefore?: string;
            /**
             * @description List of information or references to information the user wishes to have resolved as part of authentication by the relying party. They are expressed as RFC 3986 URIs separated by new lines.
             * @example [
             *   "https://docs.moralis.io/"
             * ]
             */
            resources?: string[];
            /**
             * @description Time in seconds before the challenge is expired
             * @default 15
             * @example 15
             */
            timeout: number;
            /**
             * @description The network where Contract Accounts must be resolved.
             * @example mainnet
             * @enum {string}
             */
            network: "mainnet" | "testnet" | "devnet";
            /**
             * @description Solana address with a length of 32 - 44 characters that is used to perform the signing
             * @example 26qv4GCcx98RihuK3c4T6ozB3J7L6VwCuFVc7Ta2A3Uo
             */
            address: string;
        };
        SolanaChallengeResponseDto: {
            /**
             * @description 17-characters Alphanumeric string Secret Challenge ID used to identify this particular request. Is should be used at the backend of the calling service to identify the completed request.
             * @example fRyt67D3eRss3RrXa
             */
            id: string;
            /**
             * @description Unique identifier with a length of 66 characters
             * @example 0xbfbcfab169c67072ff418133124480fea02175f1402aaa497daa4fd09026b0e1
             */
            profileId: string;
            /**
             * @description Message that needs to be signed by the end user
             * @example defi.finance wants you to sign in with your Solana account:
             * 26qv4GCcx98RihuK3c4T6ozB3J7L6VwCuFVc7Ta2A3Uo
             *
             * I am a third party API
             *
             * URI: http://defi.finance
             * Version: 1
             * Network: mainnet
             * Nonce: PYxxb9msdjVXsMQ9x
             * Issued At: 2022-08-25T11:02:34.097Z
             * Expiration Time: 2022-08-25T11:12:38.243Z
             * Resources:
             * - https://docs.moralis.io/
             */
            message: string;
        };
        SolanaCompleteChallengeRequestDto: {
            /**
             * @description Message that needs to be signed by the end user
             * @example defi.finance wants you to sign in with your Solana account:
             * 26qv4GCcx98RihuK3c4T6ozB3J7L6VwCuFVc7Ta2A3Uo
             *
             * I am a third party API
             *
             * URI: http://defi.finance
             * Version: 1
             * Network: mainnet
             * Nonce: PYxxb9msdjVXsMQ9x
             * Issued At: 2022-08-25T11:02:34.097Z
             * Expiration Time: 2022-08-25T11:12:38.243Z
             * Resources:
             * - https://docs.moralis.io/
             */
            message: string;
            /**
             * @description Base58 signature that needs to be used to verify end user
             * @example 2pH9DqD5rve2qV4yBDshcAjWd2y8TqMx8BPb7f3KoNnuLEhE5JwjruYi4jaFaD4HN6wriLz2Vdr32kRBAJmHcyny
             */
            signature: string;
        };
        SolanaCompleteChallengeResponseDto: {
            /**
             * @description 17-characters Alphanumeric string Secret Challenge ID used to identify this particular request. Is should be used at the backend of the calling service to identify the completed request.
             * @example fRyt67D3eRss3RrX
             */
            id: string;
            /**
             * Format: hostname
             * @description RFC 4501 dns authority that is requesting the signing.
             * @example defi.finance
             */
            domain: string;
            /**
             * @description Human-readable ASCII assertion that the user will sign, and it must not contain `
             * `.
             * @example Please confirm
             */
            statement?: string;
            /**
             * Format: uri
             * @description RFC 3986 URI referring to the resource that is the subject of the signing (as in the __subject__ of a claim).
             * @example https://defi.finance/
             */
            uri: string;
            /**
             * Format: date-time
             * @description ISO 8601 datetime string that, if present, indicates when the signed authentication message is no longer valid.
             * @example 2020-01-01T00:00:00.000Z
             */
            expirationTime?: string;
            /**
             * Format: date-time
             * @description ISO 8601 datetime string that, if present, indicates when the signed authentication message will become valid.
             * @example 2020-01-01T00:00:00.000Z
             */
            notBefore?: string;
            /**
             * @description List of information or references to information the user wishes to have resolved as part of authentication by the relying party. They are expressed as RFC 3986 URIs separated by `
             * - `.
             * @example [
             *   "https://docs.moralis.io/"
             * ]
             */
            resources?: string[];
            /**
             * @description EIP-155 Chain ID to which the session is bound, and the network where Contract Accounts must be resolved.
             * @example 1.0
             */
            version: string;
            /** @example 0x1234567890abcdef0123456789abcdef1234567890abcdef */
            nonce: string;
            /**
             * @description Unique identifier with a length of 66 characters
             * @example 0xbfbcfab169c67072ff418133124480fea02175f1402aaa497daa4fd09026b0e1
             */
            profileId: string;
            /**
             * @description The network where Contract Accounts must be resolved.
             * @example mainnet
             * @enum {string}
             */
            network: "mainnet" | "testnet" | "devnet";
            /**
             * @description Solana address with a length of 32 - 44 characters that is used to perform the signing
             * @example 26qv4GCcx98RihuK3c4T6ozB3J7L6VwCuFVc7Ta2A3Uo
             */
            address: string;
        };
        AptosChallengeRequestDto: {
            /**
             * Format: hostname
             * @description RFC 4501 dns authority that is requesting the signing.
             * @example defi.finance
             */
            domain: string;
            /**
             * @description Human-readable ASCII assertion that the user will sign, and it must not contain `
             * `.
             * @example Please confirm
             */
            statement?: string;
            /**
             * Format: uri
             * @description RFC 3986 URI referring to the resource that is the subject of the signing (as in the __subject__ of a claim).
             * @example https://defi.finance/
             */
            uri: string;
            /**
             * Format: date-time
             * @description ISO 8601 datetime string that, if present, indicates when the signed authentication message is no longer valid.
             * @example 2020-01-01T00:00:00.000Z
             */
            expirationTime?: string;
            /**
             * Format: date-time
             * @description ISO 8601 datetime string that, if present, indicates when the signed authentication message will become valid.
             * @example 2020-01-01T00:00:00.000Z
             */
            notBefore?: string;
            /**
             * @description List of information or references to information the user wishes to have resolved as part of authentication by the relying party. They are expressed as RFC 3986 URIs separated by new lines.
             * @example [
             *   "https://docs.moralis.io/"
             * ]
             */
            resources?: string[];
            /**
             * @description Time in seconds before the challenge is expired
             * @default 15
             * @example 15
             */
            timeout: number;
            /**
             * @description The network where Contract Accounts must be resolved.
             * @example mainnet
             * @enum {string}
             */
            network: "mainnet" | "testnet";
            /**
             * @description Aptos address performing the signing conformant.
             * @example 0xfb2853744bb8afd58d9386d1856afd8e08de135019961dfa3a10d8c9bf83b99d
             */
            address: string;
            /**
             * @description Aptos public key performing the signing conformant.
             * @example 0xfb2853744bb8afd58d9386d1856afd8e08de135019961dfa3a10d8c9bf83b99d
             */
            publicKey: string;
        };
        AptosChallengeResponseDto: {
            /**
             * @description 17-characters Alphanumeric string Secret Challenge ID used to identify this particular request. Is should be used at the backend of the calling service to identify the completed request.
             * @example fRyt67D3eRss3RrXa
             */
            id: string;
            /**
             * @description Unique identifier with a length of 66 characters
             * @example 0xbfbcfab169c67072ff418133124480fea02175f1402aaa497daa4fd09026b0e1
             */
            profileId: string;
            /**
             * @description Message that needs to be signed by the end user
             * @example defi.finance wants you to sign in with your Aptos account:
             * 0xfb2853744bb8afd58d9386d1856afd8e08de135019961dfa3a10d8c9bf83b99d
             *
             * Please confirm
             *
             * URI: https://defi.finance/
             * Version: 1
             * Chain ID: 1
             * Nonce: DbU1DCTmdzR4lg3wi
             * Issued At: 2022-06-12T12:15:31.290Z
             * Expiration Time: 2020-01-01T00:00:00.000Z
             * Not Before: 2020-01-01T00:00:00.000Z
             * Resources:
             * - https://docs.moralis.io/
             */
            message: string;
        };
        AptosCompleteChallengeRequestDto: {
            /**
             * @description Message that needs to be signed by the end user.
             * @example defi.finance wants you to sign in with your Aptos account:
             * 0xfb2853744bb8afd58d9386d1856afd8e08de135019961dfa3a10d8c9bf83b99d
             *
             *
             * URI: https://defi.finance
             * Version: 1
             * Chain ID: 1
             * Nonce: Px7Nh1RPzlCLwqgOb
             * Issued At: 2022-11-30T10:20:00.262Z
             */
            message: string;
            /**
             * @description EIP-191 compliant signature signed by the Aptos account address requesting authentication.
             * @example 0xa8f89a58bf9b433d3100f9e41ee35b5e31fb8c7cd62547acb113162ec6f2e4140207e2dfbd4e387e1801ebc7f08a9dd105ac1d22b2e2ff0df5fa8b6d9bdcfe491c
             */
            signature: string;
        };
        AptosCompleteChallengeResponseDto: {
            /**
             * @description 17-characters Alphanumeric string Secret Challenge ID used to identify this particular request. Is should be used at the backend of the calling service to identify the completed request.
             * @example fRyt67D3eRss3RrX
             */
            id: string;
            /**
             * Format: hostname
             * @description RFC 4501 dns authority that is requesting the signing.
             * @example defi.finance
             */
            domain: string;
            /**
             * @description Human-readable ASCII assertion that the user will sign, and it must not contain `
             * `.
             * @example Please confirm
             */
            statement?: string;
            /**
             * Format: uri
             * @description RFC 3986 URI referring to the resource that is the subject of the signing (as in the __subject__ of a claim).
             * @example https://defi.finance/
             */
            uri: string;
            /**
             * Format: date-time
             * @description ISO 8601 datetime string that, if present, indicates when the signed authentication message is no longer valid.
             * @example 2020-01-01T00:00:00.000Z
             */
            expirationTime?: string;
            /**
             * Format: date-time
             * @description ISO 8601 datetime string that, if present, indicates when the signed authentication message will become valid.
             * @example 2020-01-01T00:00:00.000Z
             */
            notBefore?: string;
            /**
             * @description List of information or references to information the user wishes to have resolved as part of authentication by the relying party. They are expressed as RFC 3986 URIs separated by `
             * - `.
             * @example [
             *   "https://docs.moralis.io/"
             * ]
             */
            resources?: string[];
            /**
             * @description EIP-155 Chain ID to which the session is bound, and the network where Contract Accounts must be resolved.
             * @example 1.0
             */
            version: string;
            /** @example 0x1234567890abcdef0123456789abcdef1234567890abcdef */
            nonce: string;
            /**
             * @description Unique identifier with a length of 66 characters
             * @example 0xbfbcfab169c67072ff418133124480fea02175f1402aaa497daa4fd09026b0e1
             */
            profileId: string;
            /**
             * @description The network where Contract Accounts must be resolved.
             * @example mainnet
             * @enum {string}
             */
            network: "mainnet" | "testnet";
            /**
             * @description Aptos address performing the signing conformant.
             * @example 0xfb2853744bb8afd58d9386d1856afd8e08de135019961dfa3a10d8c9bf83b99d
             */
            address: string;
            /**
             * @description Aptos public key performing the signing conformant.
             * @example 0xfb2853744bb8afd58d9386d1856afd8e08de135019961dfa3a10d8c9bf83b99d
             */
            publicKey: string;
        };
        AddressInfoDto: {
            /**
             * @description The chain in which the address belongs to
             * @example evm
             * @enum {string}
             */
            blockchainType: "evm" | "solana" | "aptos";
            /**
             * @description Address performing the signing conformant to capitalization encoded checksum specified in EIP-55 where applicable.
             * @example 0x57af6B90c2237d2F888bf4CAe56f25FE1b14e531
             */
            address: string;
            /**
             * @description Public key performing the signing conformant. (This is only needed for Aptos address)
             * @example 0xfb2853744bb8afd58d9386d1856afd8e08de135019961dfa3a10d8c9bf83b99d
             */
            publicKey?: string;
        };
        BindRequestDto: {
            /** @description An array of addresses that needs to be bind */
            addresses: components["schemas"]["AddressInfoDto"][];
        };
        BindRequestResponseDto: {
            /**
             * @description Message that needs to be signed by the end user
             * @example [
             *   "Please sign this message to bind:\nProfile Ids:\n- 0x0b2bbac1251651c0cbbdbbb29fed5a03adc8b05a2a9eb10a02aaa489b9c1f8ff\n\nwith\n\nAddress: 0x6ed338bcB610640e81465FCfb9894DDfA354Cc91\nNonce: 5pXWu7aGkY2J7II0X",
             *   "Please sign this message to bind:\nProfile Ids:\n- 0x0b2bbac1251651c0cbbdbbb29fed5a03adc8b05a2a9eb10a02aaa489b9c1f8ff\n\nwith\n\nAddress: 0x6ed338bcB610640e81465FCfb9894DDfA354Cc91\nNonce: 5pXWu7aGkY2J7II0X"
             * ]
             */
            messages: string[];
        };
        VerificationDto: {
            /**
             * @description Message that needs to be signed by the end user
             * @example Please sign this message to bind:
             * Profile Ids:
             * - 0x0b2bbac1251651c0cbbdbbb29fed5a03adc8b05a2a9eb10a02aaa489b9c1f8ff
             *
             * with
             *
             * Address: 0x6ed338bcB610640e81465FCfb9894DDfA354Cc91
             * Nonce: 5pXWu7aGkY2J7II0X
             */
            message: string;
            /**
             * @description EIP-191 compliant signature signed by the Ethereum account address requesting authentication.
             * @example 0xc4f2f59d80e036ecab4eaaac5d4ee713ab94264ca584839c98b5743c4f6777322038225a4bc1e0f13b8382166816737369f26bd66f0479cfa80d4c52c02eb2cb1b
             */
            signature: string;
        };
        BindVerifyRequestDto: {
            /** @description Message that needs to be signed by the end user */
            verifications: components["schemas"]["VerificationDto"][];
        };
        BindVerifyRequestResponseDto: {
            /**
             * @description Unique identifier with a length of 66 characters
             * @example 0xbfbcfab169c67072ff418133124480fea02175f1402aaa497daa4fd09026b0e1
             */
            profileId: string;
        };
        BindRemoveDto: {
            /**
             * @description The chain in which the address belongs to
             * @example evm
             * @enum {string}
             */
            blockchainType: "evm" | "solana" | "aptos";
            /**
             * @description Address performing the signing conformant to capitalization encoded checksum specified in EIP-55 where applicable.
             * @example 0x57af6B90c2237d2F888bf4CAe56f25FE1b14e531
             */
            address: string;
            /**
             * @description Public key performing the signing conformant. (This is only needed for Aptos address)
             * @example 0xfb2853744bb8afd58d9386d1856afd8e08de135019961dfa3a10d8c9bf83b99d
             */
            publicKey?: string;
            /**
             * @description Unique identifier with a length of 66 characters
             * @example 0xbfbcfab169c67072ff418133124480fea02175f1402aaa497daa4fd09026b0e1
             */
            profileId: string;
        };
        BindRemoveResponseDto: {
            /**
             * @description Message that needs to be signed by the end user
             * @example Please sign this message to unbind:
             * Address: 0x6ed338bcB610640e81465FCfb9894DDfA354Cc91
             * from
             * Profile Id:
             * - 0x0b2bbac1251651c0cbbdbbb29fed5a03adc8b05a2a9eb10a02aaa489b9c1f8ff
             * Nonce: 5pXWu7aGkY2J7II0X
             */
            message: string;
        };
        BindVerifyRemoveDto: {
            /**
             * @description Message that needs to be signed by the end user
             * @example Please sign this message to unbind:
             * Address: 0x6ed338bcB610640e81465FCfb9894DDfA354Cc91
             * from
             * Profile Id:
             * - 0x0b2bbac1251651c0cbbdbbb29fed5a03adc8b05a2a9eb10a02aaa489b9c1f8ff
             * Nonce: 5pXWu7aGkY2J7II0X
             */
            message: string;
            /**
             * @description EIP-191 compliant signature signed by the Ethereum account address requesting authentication.
             * @example 0xc4f2f59d80e036ecab4eaaac5d4ee713ab94264ca584839c98b5743c4f6777322038225a4bc1e0f13b8382166816737369f26bd66f0479cfa80d4c52c02eb2cb1b
             */
            signature: string;
        };
        BindVerifyRemoveResponseDto: {
            /**
             * @description Unique identifier with a length of 66 characters
             * @example 0xbfbcfab169c67072ff418133124480fea02175f1402aaa497daa4fd09026b0e1
             */
            profileId: string;
        };
    };
}
interface operations$1 {
    requestChallengeEvm: {
        parameters: {};
        responses: {
            /** The back channel challenge containing the id to store on the api and the message to be signed by the user */
            201: {
                content: {
                    "application/json": components["schemas"]["EvmChallengeResponseDto"];
                };
            };
        };
        /** Request EVM challenge message. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["EvmChallengeRequestDto"];
            };
        };
    };
    verifyChallengeEvm: {
        parameters: {};
        responses: {
            /** The token to be used to call the third party API from the client */
            201: {
                content: {
                    "application/json": components["schemas"]["EvmCompleteChallengeResponseDto"];
                };
            };
        };
        /** Verify EVM challenge message. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["EvmCompleteChallengeRequestDto"];
            };
        };
    };
    requestChallengeSolana: {
        parameters: {};
        responses: {
            /** The back channel challenge containing the id to store on the api and the message to be signed by the user */
            201: {
                content: {
                    "application/json": components["schemas"]["SolanaChallengeResponseDto"];
                };
            };
        };
        /** Request Solana challenge message. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["SolanaChallengeRequestDto"];
            };
        };
    };
    verifyChallengeSolana: {
        parameters: {};
        responses: {
            /** The token to be used to call the third party API from the client */
            201: {
                content: {
                    "application/json": components["schemas"]["SolanaCompleteChallengeResponseDto"];
                };
            };
        };
        /** Verify Solana challenge message. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["SolanaCompleteChallengeRequestDto"];
            };
        };
    };
    requestChallengeAptos: {
        parameters: {};
        responses: {
            /** The back channel challenge containing the id to store on the api and the message to be signed by the user */
            201: {
                content: {
                    "application/json": components["schemas"]["AptosChallengeResponseDto"];
                };
            };
        };
        /** Request Aptos challenge message. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["AptosChallengeRequestDto"];
            };
        };
    };
    verifyChallengeAptos: {
        parameters: {};
        responses: {
            /** The token to be used to call the third party API from the client */
            201: {
                content: {
                    "application/json": components["schemas"]["AptosCompleteChallengeResponseDto"];
                };
            };
        };
        /** Verify Aptos challenge message. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["AptosCompleteChallengeRequestDto"];
            };
        };
    };
    getAddresses: {
        parameters: {
            path: {
                /** Unique identifier with a length of 66 characters */
                profileId: string;
            };
        };
        responses: {
            /** The addresses that are bound to the speicifc profileId */
            201: {
                content: {
                    "application/json": string[];
                };
            };
        };
    };
    /**
     * Request for message to bind profile that is belong to the two addresses<br>
     *         All profiles under the addresses will be bound and new profile will be generated.
     */
    requestBind: {
        parameters: {};
        responses: {
            /** The messages that is required to be signed by each of the address */
            201: {
                content: {
                    "application/json": components["schemas"]["BindRequestResponseDto"];
                };
            };
        };
        /** The two addresses that are required to be bind. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["BindRequestDto"];
            };
        };
    };
    verifyRequestBind: {
        parameters: {};
        responses: {
            /** The profileId that all the addresses have been bind into. */
            201: {
                content: {
                    "application/json": components["schemas"]["BindVerifyRequestResponseDto"];
                };
            };
        };
        /** Messages and its signatures that is used for verification */
        requestBody: {
            content: {
                "application/json": components["schemas"]["BindVerifyRequestDto"];
            };
        };
    };
    removeBind: {
        parameters: {};
        responses: {
            /** The messages that is required to be signed by each of the address */
            201: {
                content: {
                    "application/json": components["schemas"]["BindRemoveResponseDto"];
                };
            };
        };
        /** The address that is required to be removed from the bind of the profileId. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["BindRemoveDto"];
            };
        };
    };
    verifyRemoveBind: {
        parameters: {};
        responses: {
            /** The new profileId that is being generated for this address. */
            201: {
                content: {
                    "application/json": components["schemas"]["BindVerifyRemoveResponseDto"];
                };
            };
        };
        /** Messages and its signatures that is used for verification */
        requestBody: {
            content: {
                "application/json": components["schemas"]["BindVerifyRemoveDto"];
            };
        };
    };
}

type OperationId$a = 'verifyChallengeAptos';
type BodyParams$9 = operations$1[OperationId$a]['requestBody']['content']['application/json'];
type RequestParams$a = BodyParams$9;
type SuccessResponse$a = operations$1[OperationId$a]['responses']['201']['content']['application/json'];
interface VerifyChallengeAptosRequest extends Camelize<RequestParams$a> {
}
type VerifyChallengeAptosJSONRequest = ReturnType<typeof serializeRequest$a>;
type VerifyChallengeAptosJSONResponse = SuccessResponse$a;
type VerifyChallengeAptosResponse = ReturnType<typeof deserializeResponse$a>;
interface VerifyChallengeAptosResponseAdapter extends ResponseAdapter<VerifyChallengeAptosResponse, VerifyChallengeAptosJSONResponse> {
}
declare const verifyChallengeAptosOperation: Operation<VerifyChallengeAptosRequest, VerifyChallengeAptosJSONRequest, VerifyChallengeAptosResponse, VerifyChallengeAptosJSONResponse>;
declare function deserializeResponse$a({ network, ...jsonResponse }: VerifyChallengeAptosJSONResponse): {
    network: AptosNetwork;
    address: AptosAddress;
    expirationTime: Date | undefined;
    notBefore: Date | undefined;
    id: string;
    domain: string;
    statement?: string | undefined;
    uri: string;
    resources?: string[] | undefined;
    version: string;
    nonce: string;
    profileId: string;
    publicKey: string;
};
declare function serializeRequest$a(request: VerifyChallengeAptosRequest): {
    message: string;
    signature: string;
};

type OperationId$9 = 'requestChallengeAptos';
type BodyParams$8 = operations$1[OperationId$9]['requestBody']['content']['application/json'];
type RequestParams$9 = BodyParams$8;
type SuccessResponse$9 = operations$1[OperationId$9]['responses']['201']['content']['application/json'];
interface RequestChallengeAptosRequest extends Camelize<Omit<RequestParams$9, 'address' | 'network' | 'expirationTime' | 'notBefore'>> {
    address: AptosAddressInput;
    network: AptosNetworkInput;
    expirationTime?: DateInput;
    notBefore?: DateInput;
}
type RequestChallengeAptosJSONRequest = ReturnType<typeof serializeRequest$9>;
type RequestChallengeAptosJSONResponse = SuccessResponse$9;
type RequestChallengeAptosResponse = ReturnType<typeof deserializeResponse$9>;
interface RequestChallengeAptosResponseAdapter extends ResponseAdapter<RequestChallengeAptosResponse, RequestChallengeAptosJSONResponse> {
}
/** The back channel challenge containing the id to store on the api and the message to be signed by the user */
declare const requestChallengeAptosOperation: Operation<RequestChallengeAptosRequest, RequestChallengeAptosJSONRequest, RequestChallengeAptosResponse, RequestChallengeAptosJSONResponse>;
declare function deserializeResponse$9(jsonResponse: RequestChallengeAptosJSONResponse): {
    id: string;
    profileId: string;
    message: string;
};
declare function serializeRequest$9(request: RequestChallengeAptosRequest, core: Core): {
    domain: string;
    network: "mainnet" | "testnet" | "devnet";
    address: string;
    publicKey: string;
    statement: string | undefined;
    uri: string;
    expirationTime: DateInput | undefined;
    notBefore: DateInput | undefined;
    resources: string[] | undefined;
    timeout: number;
};

type OperationId$8 = 'verifyChallengeEvm';
type BodyParams$7 = operations$1[OperationId$8]['requestBody']['content']['application/json'];
type RequestParams$8 = BodyParams$7;
type SuccessResponse$8 = operations$1[OperationId$8]['responses']['201']['content']['application/json'];
interface VerifyChallengeEvmRequest extends Camelize<RequestParams$8> {
}
type VerifyChallengeEvmJSONRequest = ReturnType<typeof serializeRequest$8>;
type VerifyChallengeEvmJSONResponse = SuccessResponse$8;
type VerifyChallengeEvmResponse = ReturnType<typeof deserializeResponse$8>;
interface VerifyChallengeEvmResponseAdapter extends ResponseAdapter<VerifyChallengeEvmResponse, VerifyChallengeEvmJSONResponse> {
}
declare const verifyChallengeEvmOperation: Operation<VerifyChallengeEvmRequest, VerifyChallengeEvmJSONRequest, VerifyChallengeEvmResponse, VerifyChallengeEvmJSONResponse>;
declare function deserializeResponse$8({ chainId, ...jsonResponse }: VerifyChallengeEvmJSONResponse): {
    chain: EvmChain;
    address: EvmAddress;
    expirationTime: Date | undefined;
    notBefore: Date | undefined;
    id: string;
    domain: string;
    statement?: string | undefined;
    uri: string;
    resources?: string[] | undefined;
    version: string;
    nonce: string;
    profileId: string;
};
declare function serializeRequest$8(request: VerifyChallengeEvmRequest): {
    message: string;
    signature: string;
};

type OperationId$7 = 'requestChallengeEvm';
type BodyParams$6 = operations$1[OperationId$7]['requestBody']['content']['application/json'];
type RequestParams$7 = BodyParams$6;
type SuccessResponse$7 = operations$1[OperationId$7]['responses']['201']['content']['application/json'];
interface RequestChallengeEvmRequest extends Camelize<Omit<RequestParams$7, 'address' | 'chainId' | 'expirationTime' | 'notBefore'>> {
    address: EvmAddressish;
    chainId: EvmChainish;
    expirationTime?: DateInput;
    notBefore?: DateInput;
}
type RequestChallengeEvmJSONRequest = ReturnType<typeof serializeRequest$7>;
type RequestChallengeEvmJSONResponse = SuccessResponse$7;
type RequestChallengeEvmResponse = ReturnType<typeof deserializeResponse$7>;
interface RequestChallengeEvmResponseAdapter extends ResponseAdapter<RequestChallengeEvmResponse, RequestChallengeEvmJSONResponse> {
}
/** The back channel challenge containing the id to store on the api and the message to be signed by the user */
declare const requestChallengeEvmOperation: Operation<RequestChallengeEvmRequest, RequestChallengeEvmJSONRequest, RequestChallengeEvmResponse, RequestChallengeEvmJSONResponse>;
declare function deserializeResponse$7(jsonResponse: RequestChallengeEvmJSONResponse): {
    id: string;
    profileId: string;
    message: string;
};
declare function serializeRequest$7(request: RequestChallengeEvmRequest, core: Core): {
    domain: string;
    chainId: string;
    address: string;
    statement: string | undefined;
    uri: string;
    expirationTime: DateInput | undefined;
    notBefore: DateInput | undefined;
    resources: string[] | undefined;
    timeout: number;
};

type OperationId$6 = 'getAddresses';
type PathParams = operations$1[OperationId$6]['parameters']['path'];
type RequestParams$6 = PathParams;
type SuccessResponse$6 = operations$1[OperationId$6]['responses']['201']['content']['application/json'];
interface GetAddressesRequest extends Camelize<RequestParams$6> {
}
type GetAddressesJSONRequest = ReturnType<typeof serializeRequest$6>;
type GetAddressesJSONResponse = SuccessResponse$6;
type GetAddressesResponse = ReturnType<typeof deserializeResponse$6>;
interface GetAddressesResponseAdapter extends ResponseAdapter<GetAddressesResponse, GetAddressesJSONResponse> {
}
declare const getAddressesOperation: Operation<GetAddressesRequest, GetAddressesJSONRequest, GetAddressesResponse, GetAddressesJSONResponse>;
declare function deserializeResponse$6(jsonResponse: GetAddressesJSONResponse): string[];
declare function serializeRequest$6(request: GetAddressesRequest): GetAddressesRequest;

type OperationId$5 = 'removeBind';
type BodyParams$5 = operations$1[OperationId$5]['requestBody']['content']['application/json'];
type RequestParams$5 = BodyParams$5;
type SuccessResponse$5 = operations$1[OperationId$5]['responses']['201']['content']['application/json'];
interface RemoveBindRequest extends Camelize<Omit<RequestParams$5, 'address'>> {
    address: EvmAddressish;
}
type RemoveBindJSONRequest = ReturnType<typeof serializeRequest$5>;
type RemoveBindJSONResponse = SuccessResponse$5;
type RemoveBindResponse = ReturnType<typeof deserializeResponse$5>;
interface RemoveBindResponseAdapter extends ResponseAdapter<RemoveBindResponse, RemoveBindJSONResponse> {
}
declare const removeBindOperation: Operation<RemoveBindRequest, RemoveBindJSONRequest, RemoveBindResponse, RemoveBindJSONResponse>;
declare function deserializeResponse$5(jsonResponse: RemoveBindJSONResponse): {
    message: string;
};
declare function serializeRequest$5(request: RemoveBindRequest): {
    blockchainType: Camelize<"evm" | "solana" | "aptos">;
    address: string;
    profileId: string;
    publicKey: string | undefined;
};

type OperationId$4 = 'requestBind';
type BodyParams$4 = operations$1[OperationId$4]['requestBody']['content']['application/json'];
type RequestParams$4 = BodyParams$4;
type SuccessResponse$4 = operations$1[OperationId$4]['responses']['201']['content']['application/json'];
interface RequestBindRequest extends Camelize<Omit<RequestParams$4, 'addresses'>> {
    addresses: {
        blockchainType: 'evm' | 'solana';
        address: EvmAddressish;
    }[];
}
type RequestBindJSONRequest = ReturnType<typeof serializeRequest$4>;
type RequestBindJSONResponse = SuccessResponse$4;
type RequestBindResponse = ReturnType<typeof deserializeResponse$4>;
interface RequestBindResponseAdapter extends ResponseAdapter<RequestBindResponse, RequestBindJSONResponse> {
}
declare const requestBindOperation: Operation<RequestBindRequest, RequestBindJSONRequest, RequestBindResponse, RequestBindJSONResponse>;
declare function deserializeResponse$4(jsonResponse: RequestBindJSONResponse): {
    messages: string[];
};
declare function serializeRequest$4(request: RequestBindRequest): {
    addresses: {
        blockchainType: "evm" | "solana";
        address: string;
    }[];
};

type OperationId$3 = 'verifyRemoveBind';
type BodyParams$3 = operations$1[OperationId$3]['requestBody']['content']['application/json'];
type RequestParams$3 = BodyParams$3;
type SuccessResponse$3 = operations$1[OperationId$3]['responses']['201']['content']['application/json'];
interface VerifyRemoveBindRequest extends Camelize<RequestParams$3> {
}
type VerifyRemoveBindJSONRequest = ReturnType<typeof serializeRequest$3>;
type VerifyRemoveBindJSONResponse = SuccessResponse$3;
type VerifyRemoveBindResponse = ReturnType<typeof deserializeResponse$3>;
interface VerifyRemoveBindResponseAdapter extends ResponseAdapter<VerifyRemoveBindResponse, VerifyRemoveBindJSONResponse> {
}
declare const verifyRemoveBindOperation: Operation<VerifyRemoveBindRequest, VerifyRemoveBindJSONRequest, VerifyRemoveBindResponse, VerifyRemoveBindJSONResponse>;
declare function deserializeResponse$3(jsonResponse: VerifyRemoveBindJSONResponse): {
    profileId: string;
};
declare function serializeRequest$3(request: VerifyRemoveBindRequest): {
    message: string;
    signature: string;
};

type OperationId$2 = 'verifyRequestBind';
type BodyParams$2 = operations$1[OperationId$2]['requestBody']['content']['application/json'];
type RequestParams$2 = BodyParams$2;
type SuccessResponse$2 = operations$1[OperationId$2]['responses']['201']['content']['application/json'];
interface VerifyRequestBindRequest extends Camelize<RequestParams$2> {
}
type VerifyRequestBindJSONRequest = ReturnType<typeof serializeRequest$2>;
type VerifyRequestBindJSONResponse = SuccessResponse$2;
type VerifyRequestBindResponse = ReturnType<typeof deserializeResponse$2>;
interface VerifyRequestBindResponseAdapter extends ResponseAdapter<VerifyRequestBindResponse, VerifyRequestBindJSONResponse> {
}
declare const verifyRequestBindOperation: Operation<VerifyRequestBindRequest, VerifyRequestBindJSONRequest, VerifyRequestBindResponse, VerifyRequestBindJSONResponse>;
declare function deserializeResponse$2(jsonResponse: VerifyRequestBindJSONResponse): {
    profileId: string;
};
declare function serializeRequest$2(request: VerifyRequestBindRequest): {
    verifications: Camelize<{
        message: string;
        signature: string;
    }>[];
};

type OperationId$1 = 'verifyChallengeSolana';
type BodyParams$1 = operations$1[OperationId$1]['requestBody']['content']['application/json'];
type RequestParams$1 = BodyParams$1;
type SuccessResponse$1 = operations$1[OperationId$1]['responses']['201']['content']['application/json'];
interface VerifyChallengeSolanaRequest extends Camelize<RequestParams$1> {
}
type VerifyChallengeSolanaJSONRequest = ReturnType<typeof serializeRequest$1>;
type VerifyChallengeSolanaJSONResponse = SuccessResponse$1;
type VerifyChallengeSolanaResponse = ReturnType<typeof deserializeResponse$1>;
interface VerifyChallengeSolanaResponseAdapter extends ResponseAdapter<VerifyChallengeSolanaResponse, VerifyChallengeSolanaJSONResponse> {
}
declare const verifyChallengeSolanaOperation: Operation<VerifyChallengeSolanaRequest, VerifyChallengeSolanaJSONRequest, VerifyChallengeSolanaResponse, VerifyChallengeSolanaJSONResponse>;
declare function deserializeResponse$1({ network, ...jsonResponse }: VerifyChallengeSolanaJSONResponse): {
    solNetwork: SolNetwork;
    address: SolAddress;
    expirationTime: Date | undefined;
    notBefore: Date | undefined;
    id: string;
    domain: string;
    statement?: string | undefined;
    uri: string;
    resources?: string[] | undefined;
    version: string;
    nonce: string;
    profileId: string;
};
declare function serializeRequest$1(request: VerifyChallengeSolanaRequest): {
    message: string;
    signature: string;
};

type OperationId = 'requestChallengeSolana';
type BodyParams = operations$1[OperationId]['requestBody']['content']['application/json'];
type RequestParams = BodyParams;
type SuccessResponse = operations$1[OperationId]['responses']['201']['content']['application/json'];
interface RequestChallengeSolanaRequest extends Camelize<Omit<RequestParams, 'address' | 'network' | 'expirationTime' | 'notBefore'>> {
    address: SolAddressish;
    network: SolNetworkish;
    expirationTime?: DateInput;
    notBefore?: DateInput;
}
type RequestChallengeSolanaJSONRequest = ReturnType<typeof serializeRequest>;
type RequestChallengeSolanaJSONResponse = SuccessResponse;
type RequestChallengeSolanaResponse = ReturnType<typeof deserializeResponse>;
interface RequestChallengeSolanaResponseAdapter extends ResponseAdapter<RequestChallengeSolanaResponse, RequestChallengeSolanaJSONResponse> {
}
/** The back channel challenge containing the id to store on the api and the message to be signed by the user */
declare const requestChallengeSolanaOperation: Operation<RequestChallengeSolanaRequest, RequestChallengeSolanaJSONRequest, RequestChallengeSolanaResponse, RequestChallengeSolanaJSONResponse>;
declare function deserializeResponse(jsonResponse: RequestChallengeSolanaJSONResponse): {
    id: string;
    profileId: string;
    message: string;
};
declare function serializeRequest(request: RequestChallengeSolanaRequest): {
    domain: string;
    network: "mainnet" | "devnet";
    address: string;
    statement: string | undefined;
    uri: string;
    expirationTime: DateInput | undefined;
    notBefore: DateInput | undefined;
    resources: string[] | undefined;
    timeout: number;
};

declare const operations: (_moralisweb3_common_core.Operation<RequestChallengeSolanaRequest, {
    domain: string;
    network: "mainnet" | "devnet";
    address: string;
    statement: string | undefined;
    uri: string;
    expirationTime: _moralisweb3_common_core.DateInput | undefined;
    notBefore: _moralisweb3_common_core.DateInput | undefined;
    resources: string[] | undefined;
    timeout: number;
}, {
    id: string;
    profileId: string;
    message: string;
}, {
    id: string;
    profileId: string;
    message: string;
}> | _moralisweb3_common_core.Operation<RequestChallengeEvmRequest, {
    domain: string;
    chainId: string;
    address: string;
    statement: string | undefined;
    uri: string;
    expirationTime: _moralisweb3_common_core.DateInput | undefined;
    notBefore: _moralisweb3_common_core.DateInput | undefined;
    resources: string[] | undefined;
    timeout: number;
}, {
    id: string;
    profileId: string;
    message: string;
}, {
    id: string;
    profileId: string;
    message: string;
}> | _moralisweb3_common_core.Operation<RequestChallengeAptosRequest, {
    domain: string;
    network: "mainnet" | "devnet" | "testnet";
    address: string;
    publicKey: string;
    statement: string | undefined;
    uri: string;
    expirationTime: _moralisweb3_common_core.DateInput | undefined;
    notBefore: _moralisweb3_common_core.DateInput | undefined;
    resources: string[] | undefined;
    timeout: number;
}, {
    id: string;
    profileId: string;
    message: string;
}, {
    id: string;
    profileId: string;
    message: string;
}> | _moralisweb3_common_core.Operation<GetAddressesRequest, GetAddressesRequest, string[], string[]> | _moralisweb3_common_core.Operation<RemoveBindRequest, {
    blockchainType: _moralisweb3_common_core.Camelize<"evm" | "solana" | "aptos">;
    address: string;
    profileId: string;
    publicKey: string | undefined;
}, {
    message: string;
}, {
    message: string;
}> | _moralisweb3_common_core.Operation<RequestBindRequest, {
    addresses: {
        blockchainType: "evm" | "solana";
        address: string;
    }[];
}, {
    messages: string[];
}, {
    messages: string[];
}> | _moralisweb3_common_core.Operation<VerifyRemoveBindRequest, {
    message: string;
    signature: string;
}, {
    profileId: string;
}, {
    profileId: string;
}> | _moralisweb3_common_core.Operation<VerifyRequestBindRequest, {
    verifications: _moralisweb3_common_core.Camelize<{
        message: string;
        signature: string;
    }>[];
}, {
    profileId: string;
}, {
    profileId: string;
}>)[];

export { GetAddressesJSONRequest, GetAddressesJSONResponse, GetAddressesRequest, GetAddressesResponse, GetAddressesResponseAdapter, RemoveBindJSONRequest, RemoveBindJSONResponse, RemoveBindRequest, RemoveBindResponse, RemoveBindResponseAdapter, RequestBindJSONRequest, RequestBindJSONResponse, RequestBindRequest, RequestBindResponse, RequestBindResponseAdapter, RequestChallengeAptosJSONRequest, RequestChallengeAptosJSONResponse, RequestChallengeAptosRequest, RequestChallengeAptosResponse, RequestChallengeAptosResponseAdapter, RequestChallengeEvmJSONRequest, RequestChallengeEvmJSONResponse, RequestChallengeEvmRequest, RequestChallengeEvmResponse, RequestChallengeEvmResponseAdapter, RequestChallengeSolanaJSONRequest, RequestChallengeSolanaJSONResponse, RequestChallengeSolanaRequest, RequestChallengeSolanaResponse, RequestChallengeSolanaResponseAdapter, VerifyChallengeAptosJSONRequest, VerifyChallengeAptosJSONResponse, VerifyChallengeAptosRequest, VerifyChallengeAptosResponse, VerifyChallengeAptosResponseAdapter, VerifyChallengeEvmJSONRequest, VerifyChallengeEvmJSONResponse, VerifyChallengeEvmRequest, VerifyChallengeEvmResponse, VerifyChallengeEvmResponseAdapter, VerifyChallengeSolanaJSONRequest, VerifyChallengeSolanaJSONResponse, VerifyChallengeSolanaRequest, VerifyChallengeSolanaResponse, VerifyChallengeSolanaResponseAdapter, VerifyRemoveBindJSONRequest, VerifyRemoveBindJSONResponse, VerifyRemoveBindRequest, VerifyRemoveBindResponse, VerifyRemoveBindResponseAdapter, VerifyRequestBindJSONRequest, VerifyRequestBindJSONResponse, VerifyRequestBindRequest, VerifyRequestBindResponse, VerifyRequestBindResponseAdapter, getAddressesOperation, operations, removeBindOperation, requestBindOperation, requestChallengeAptosOperation, requestChallengeEvmOperation, requestChallengeSolanaOperation, verifyChallengeAptosOperation, verifyChallengeEvmOperation, verifyChallengeSolanaOperation, verifyRemoveBindOperation, verifyRequestBindOperation };
